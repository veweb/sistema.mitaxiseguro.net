<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>9.3. Zend_Db_Select</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Przewodnik Programisty">
<link rel="up" href="zend.db.html" title="Rozdział 9. Zend_Db">
<link rel="prev" href="zend.db.profiler.html" title="9.2. Zend_Db_Profiler">
<link rel="next" href="zend.db.table.html" title="9.4. Zend_Db_Table">
<link rel="chapter" href="zend.html" title="Rozdział 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Rozdział 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Rozdział 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Rozdział 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Rozdział 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Rozdział 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Rozdział 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Rozdział 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Rozdział 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Rozdział 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Rozdział 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Rozdział 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Rozdział 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Rozdział 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Rozdział 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Rozdział 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Rozdział 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Rozdział 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Rozdział 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Rozdział 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Rozdział 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Rozdział 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Rozdział 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Rozdział 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Rozdział 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Rozdział 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Rozdział 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Rozdział 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Rozdział 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Dodatek A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="Dodatek B. Informacje o prawach autorskich">
<link rel="index" href="the.index.html" title="Indeks">
<link rel="subsection" href="zend.db.select.html#zend.db.select.introduction" title="9.3.1. Wprowadzenie">
<link rel="subsection" href="zend.db.select.html#zend.db.select.fromcols" title="9.3.2. Kolumny z tabel (FROM)">
<link rel="subsection" href="zend.db.select.html#zend.db.select.joincols" title="9.3.3. Kolumny ze złączonych tabel (JOIN)">
<link rel="subsection" href="zend.db.select.html#zend.db.select.where" title="9.3.4. Warunki WHERE">
<link rel="subsection" href="zend.db.select.html#zend.db.select.group" title="9.3.5. Warunek GROUP BY">
<link rel="subsection" href="zend.db.select.html#zend.db.select.having" title="9.3.6. Warunki HAVING">
<link rel="subsection" href="zend.db.select.html#zend.db.select.order" title="9.3.7. Warunek ORDER BY">
<link rel="subsection" href="zend.db.select.html#zend.db.select.limit" title="9.3.8. LIMIT w oparciu o ilość wyników i offset">
<link rel="subsection" href="zend.db.select.html#zend.db.select.paging" title="9.3.9. LIMIT w oparciu o ilość wyników i numer strony">
<link rel="subsection" href="zend.db.select.html#id4823667" title="9.3.10. Inne metody">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">9.3. Zend_Db_Select</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.profiler.html">Poprzedni</a> </td>
<th width="60%" align="center">Rozdział 9. Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.table.html">Następny</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pl">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.select"></a>9.3. Zend_Db_Select</h2></div></div></div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.introduction"></a>9.3.1. Wprowadzenie</h3></div></div></div>
<p>
            Zend_Db_Select jest narzędziem pomagającym w budowaniu zapytań SQL 
            SELECT w sposób niezależny od rodzaju bazy danych. Oczywiście nie 
            może to być perfekcyjne, ale pomaga w tym, aby zapytania były 
            przenośne pomiędzy różnymi systemami bazodanowymi. Dodatkowo
            pomaga to w uodpornieniu zapytań na ataki SQL injection.
        </p>
<p>
            Najprostszy sposób utworzenia instancji Zend_Db_Select to użycie 
            metody Zend_Db_Adapter::select().
        </p>
<pre class="programlisting">&lt;?php
	
require_once 'Zend/Db.php';

$params = array (
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'malory',
    'password' =&gt; '******',
    'dbname'   =&gt; 'camelot'
);

$db = Zend_Db::factory('PDO_MYSQL', $params);

$select = $db-&gt;select();
// $select jest teraz obiektem Zend_Db_Select skonfigurowanym do użycia z adapterem PDO_MYSQL.

?&gt;</pre>
<p>
            Wtedy konstruujesz zapytanie SELECT używając tego obiektu i jego metod,
            a następnie generujesz łańcuch znaków który przekazujesz spowrotem 
            do obiektu Zend_Db_Adapter w celu wykonania zapytania.
        </p>
<pre class="programlisting">&lt;?php
	
//
// SELECT round_table.*
// FROM `round_table` round_table
// WHERE `noble_title` = 'Sir'
// ORDER BY `first_name`
// LIMIT 10 OFFSET 20
//

// możesz użyć stylu iteracyjnego...
$select-&gt;from('round_table');
$select-&gt;where('noble_title = ?', 'Sir');
$select-&gt;order('first_name');
$select-&gt;limit(10,20);

// ...lub stylu łańcuchowego:
$select-&gt;from('round_table')
       -&gt;where('noble_title = ?', 'Sir')
       -&gt;order('first_name')
       -&gt;limit(10,20);

// pobieramy dane:
$sql = $select-&gt;__toString();
$result = $db-&gt;fetchAll($sql);

// druga alternatywa: możesz przekazać sam obiekt $select;
$result = $db-&gt;fetchAll($select);

// trzecia alternatywa: tworzysz obiekt Zend_Db_Statement
// lub PDOStatement bezpośrednio z obiektu $select:
$stmt = $select-&gt;query();
$result = $stmt-&gt;fetchAll();

?&gt;</pre>
<p>
            Możesz także użyć parametrów wstawianych w miejsce nazwanych 
            znaczników, zamiast cytowania parametrów po kolei.
        </p>
<pre class="programlisting">&lt;?php
	
//
// SELECT round_table.*
// FROM `round_table` round_table
// WHERE noble_title = 'Sir'
// ORDER BY `first_name`
// LIMIT 10 OFFSET 20
//

$select-&gt;from('round_table', '*')
       -&gt;where('noble_title = :title')
       -&gt;order('first_name')
       -&gt;limit(10,20);

// pobieramy wyniki używająć parametrów wstawianych w miejsce znaczników
$params = array('title' =&gt; 'Sir');
$result = $db-&gt;fetchAll($select, $params);

?&gt;</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.fromcols"></a>9.3.2. Kolumny z tabel (FROM)</h3></div></div></div>
<p>
            Aby wybrać kolumny z określonej tabeli, użyj metody from(),
            określając tabelę oraz kolumny których potrzebujesz. Możesz 
            użyć aliasów dla tabel oraz kolumn, i możesz używać metody from() 
            tyle razy ile potrzebujesz.
        </p>
<pre class="programlisting">&lt;?php
	
// tworzymy obiekt $db, zakładając, że adapter to Mysql
$select = $db-&gt;select();

// SELECT some_table.`a`, some_table.`b`, some_table.`c`
// FROM `some_table` some_table

$select-&gt;from('some_table', array('a', 'b', 'c'));

// SELECT bar.`col`
// FROM `foo` bar

$select-&gt;from(array('foo' =&gt; 'bar'), 'col');

?&gt;</pre>
<p>
            Drugi argument do metody from() jest wartością skalarną dla 
            pojedynczej nazwy kolumny, lub tablicą dla wielu nazw kolumn. 
            Wartość skalarna lub element tablicy może być łańcuchem znaków,
            który jest interpretowany jako prosta nazwa kolmny i jest ona 
            cytowana, a na początek nazwy dołączany jest alias tabeli. Jeśli
            pominiesz drugi argument, przyjęta zostanie jego domyślna wartość
            <code class="code">'*'</code>, co nie jest cytowane, ale do tej wartości też
            zostanie dołączony alias tabeli. Jeśli nie chcesz by kolumny z tej
            tabeli znajdowały się w zestawie wyników, użyj pustej tablicy 
            <code class="code">array()</code>.
        </p>
<p>
            Nie określaj wielu kolumn jako pojedynczego łańcucha znaków z 
            nazwami kolumn oddzielonymi przecinkami. Taka składnia była używana
            we wcześniejszych wydaniach Zend_Db i nie jest ona już obsługiwana.
            Użyj zamiast tego tablicy.
        </p>
<p>
            Alias tabeli jest dołączany do każdego elementu będącego łańcuchem 
            znaków znajdującym się w drugim argumencie, ale jeśli element jest
            obiektem typu Zend_Db_Expr, to jego wartość w postaci łańcucha
            znaków jest używana bez cytowania oraz dodawania alisu tabeli.
        </p>
<pre class="programlisting">&lt;?php

$select = $db-&gt;select();

// SELECT foo.col AS col1, bar.col AS col2
// FROM foo, bar
$select-&gt;from('foo', array(
    new Zend_Db_Expr('foo.col AS col1'),
    new Zend_Db_Expr('CURDATE()')
);
$select-&gt;from('bar', new Zend_Db_Expr('bar.col AS col2'));

?&gt;</pre>
<p>
            Użyj tablicy asocjacyjnej aby zadeklarować aliasy dla tabel. Klucz
            tablicy jest nazwą tabeli, a wartośc jest aliasem. Jeśli zamiast
            tego określisz nazwę tabeli jako zwykły łańcuch znaków, a nie jako 
            asocjacyjną tablicę, to Zend_Db_Select wygeneruje alias dla tabeli.
            Domyślnie generowany jest alias o tej samej nazwie jak tabela, czyli
            tak jak na przykład w zapytaniu SQL 
            "<code class="code">SELECT foo.* FROM `foo` foo</code>". Jeśli dodasz tę samą
            tabelę więcej niż raz, na przykład w złączeniu SELF JOIN, 
            Zend_Db_Select zadeklaruje unikalny alias dla każdej instancji 
            tabeli, jak np. "<code class="code">foo_1</code>", "<code class="code">foo_2</code>", itd.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.joincols"></a>9.3.3. Kolumny ze złączonych tabel (JOIN)</h3></div></div></div>
<p>
            Aby wybrać kolumny używając złączonych tabel, użyj metody join().
            Wpierw określ nazwę złączanej tabeli, następnie wyrażenie łączące,
            a na końcu kolumny które potrzebujesz dołączyć. Możesz użyć metody
            join() tyle razy ile potrzebujesz.
        </p>
<pre class="programlisting">&lt;?php
	
// tworzymy obiekt $db, zakładając, że adapter to Mysql
$select = $db-&gt;select();

// SELECT foo.*, bar.*
// FROM `foo` foo
// JOIN `bar` bar ON foo.id = bar.id

$select-&gt;from('foo');
$select-&gt;join('bar', 'foo.id = bar.id');

?&gt;</pre>
<p>
            Pierwszy argument dla metody join() określa tabelę. Działa to
            analogicznie jak pierwszy argument metody from(), w którym nazwa
            tabeli może być łańcuchem znaków lub asocjacyjną tablicą mapującą
            nazwę tabeli do aliasu.
        </p>
<p>
            Drugi argument dla metody join() jest wyrażeniem tworzącym warunek
            złączenia. Możesz tu użyć aliasów tabel, ale pamiętaj, że jeśli nie 
            określiłeś aliasów tabel, to Zend_Db_Select sam je wygeneruje.
            Jeśli pominiesz warunek złączenia, będzie to odpowiadało użyciu
            złączenia krzyżowego CROSS JOIN lub iloczynu kartezjańskiego.
        </p>
<p>
            Trzeci argument dla metody join()jest listą kolumn ze złączonej 
            tabeli, które mają być dołączone do listy wyników. Działa to
            analogicznie jak drugi argument dla metody from(), w którym może
            być wartość skalarna z nazwą tabeli, lub tablica wartości 
            skalarnych w celu wybrania wielu kolumn. Każda wartość skalarna może
            być łańcuchem znakow lub obiektem typu Zend_Db_Expr. Jeśli pominiesz
            ten argument, jako wartość domyślna zostanie przyjęty znak 
            <code class="code">'*'</code>. Jeśli nie chcesz by kolumny z dołączonej
            tabeli znajdowały się w zestawie wyników, użyj pustej tablicy 
            <code class="code">array()</code>.
        </p>
<p>
            Nie określaj wielu kolumn jako pojedynczego łańcucha znaków z 
            nazwami kolumn oddzielonymi przecinkami. Taka składnia była używana
            we wcześniejszych wydaniach Zend_Db i nie jest ona już obsługiwana.
            Użyj zamiast tego tablicy.
        </p>
<p>
            Obsługiwane są następujące typy złączeń:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <span><strong class="command">INNER JOIN</strong></span> za pomocą metody
                    <code class="code">join()</code> lub <code class="code">joinInner()</code>.
                    Wszystkie rodzaje RDBMS obsługują ten typ złączeń.
                </p></li>
<li><p>
                    <span><strong class="command">LEFT JOIN</strong></span> za pomocą metody
                    <code class="code">joinLeft()</code>.
                    Wszystkie rodzaje RDBMS obsługują ten typ złączeń.
                </p></li>
<li><p>
                    <span><strong class="command">RIGHT JOIN</strong></span> za pomocą metody
                    <code class="code">joinRight()</code>.
                    Niektóre rodzaje RDBMS nie obsługują tego typu złączeń.
                </p></li>
<li><p>
                    <span><strong class="command">FULL JOIN</strong></span> za pomocą metody
                    <code class="code">joinFull()</code>.
                    Niektóre rodzaje RDBMS nie obsługują tego typu złączeń.
                </p></li>
<li><p>
                    <span><strong class="command">CROSS JOIN</strong></span> za pomocą metody
                    <code class="code">joinCross()</code>.
                    Nie ma żadnego parametru dla tej metody do określania
                    warunku złączenia.
                    Niektóre rodzaje RDBMS nie obsługują tego typu złączeń.
                </p></li>
<li><p>
                    <span><strong class="command">NATURAL JOIN</strong></span> za pomocą metody
                    <code class="code">joinNatural()</code>.
                    Nie ma żadnego parametru dla tej metody do określania
                    warunku złączenia; przy złączeniu naturalnym zakładane jest,
                    że jest tworzone równościowe złączenie kolumn o tej samej 
                    nazwie w obu tabelach.
                    Obsługiwane jest jedynie złączenie NATURAL INNER JOIN.
                </p></li>
</ul></div>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.where"></a>9.3.4. Warunki WHERE</h3></div></div></div>
<p>
            Aby dodać warunki WHERE, użyj metody where(). Możesz przekazać
            zwykły łańcuch znaków lub możesz przekazać łańcuch znaków
            ze znacznikiem w postaci znaku zapytania oraz wartość która
            ma być zacytowana. (wartość będzie zacytowana za pomocą
            metody Zend_Db_Adapter::quoteInto).
        </p>
<p>
            Kolejne wywołania where() będą łączyć warunki za pomocą AND;
            jeśli chcesz je złączyć za pomocą OR, użyj metody orWhere().
        </p>
<pre class="programlisting">&lt;?php
	
// tworzymy obiekt $db, a następie odbieramy narzędzie SELECT.
$select = $db-&gt;select();

// SELECT r.*
// FROM `round_table` r
// WHERE noble_title = 'Sir'
//   AND favorite_color = 'yellow'

$select-&gt;from(array('round_table' =&gt; 'r'));
$select-&gt;where("noble_title = 'Sir'"); // osadzona wartość
$select-&gt;where('favorite_color = ?', 'yellow'); // cytowana wartość

// SELECT foo.*
//     FROM `foo` foo
//     WHERE bar = 'baz'
//     OR id IN('1', '2', '3')

$select-&gt;from('foo');
$select-&gt;where('bar = ?', 'baz');
$select-&gt;orWhere('id IN(?)', array(1, 2, 3));

?&gt;</pre>
<p>
            Zend_Db_Select nie stosuje cytowania oraz aliasów tabeli dla 
            nazwanych kolumn w wyrażeniach WHERE. Jeśli zmiennych PHP używasz
            do tworzenia łańcucha znaków dla wyyrażenia WHERE, powinienes użyć
            metody Zend_Db_Adapter quoteIdentifier() aby ochronić twoje 
            zapytania przed niedozwoloną składnią.
        </p>
<pre class="programlisting">&lt;?php
...
$columnName = 'bar'; // lub ustawione przez niezaufane źródło
$whereExpr = $db-&gt;quoteIdentifier($columnName) . ' = ?';
$select-&gt;where($whereExpr, 'baz');
?&gt;</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.group"></a>9.3.5. Warunek GROUP BY</h3></div></div></div>
<p>
            Aby grupować wiersze użyj metody group() tyle razy ile potrzebujesz.
        </p>
<pre class="programlisting">&lt;?php
	
// tworzymy obiekt $db, a następie odbieramy narzędzie SELECT.
$select = $db-&gt;select();

// SELECT COUNT(id)
// FROM `foo` foo
// GROUP BY `bar`, `baz`

$select-&gt;from('foo', new Zend_Db_Expr('COUNT(id)'));
$select-&gt;group('bar');
$select-&gt;group('baz');

// wywołanie metody group():
$select-&gt;group(array('bar', 'baz'));

?&gt;</pre>
<p>
            Nie określaj wielu kolumn jako pojedynczego łańcucha znaków z 
            nazwami kolumn oddzielonymi przecinkami. Taka składnia była używana
            we wcześniejszych wydaniach Zend_Db i nie jest ona już obsługiwana.
            Użyj zamiast tego tablicy.
        </p>
<p>
            Cytowanie jest stosowane do każdego elementu będącego łańcuchem
            znakow, znajdującym się argumencie dla group(), ale jeśli element
            ten jest obiektem typu Zend_Db_Expr, jego wartość jest używana bez
            cytowania.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.having"></a>9.3.6. Warunki HAVING</h3></div></div></div>
<p>
            Aby dodać warunki HAVING dla wybranych wyników użyj metody having().
            Ta metoda jest identyczna w użyciu jak metoda where().
        </p>
<p>
            Kolejne wywołania having() będą łączyć warunki za pomocą AND;
            jeśli chcesz je złączyć za pomocą OR, użyj metody orHaving().
        </p>
<pre class="programlisting">&lt;?php
	
// tworzymy obiekt $db, a następie odbieramy narzędzie SELECT.
$select = $db-&gt;select();

// SELECT COUNT(id) AS count_id
//     FROM `foo` foo
//     GROUP BY `bar`, `baz`
//     HAVING count_id &gt; '1'

$select-&gt;from('foo', new Zend_Db_Expr('COUNT(id) AS count_id'));
$select-&gt;group(array('bar', 'baz'));
$select-&gt;having('count_id &gt; ?', 1);

?&gt;</pre>
<p>
            Zend_Db_Select does not apply quoting or table aliases to
            columns named in HAVING clauses.  If you combine PHP 
            variables into the string for a HAVING expression, you
            should use the Zend_Db_Adapter quoteIdentifier() method
            to protect against illegal syntax.
        </p>
<pre class="programlisting">&lt;?php
...
$columnName = 'count_id'; // lub ustawione przez niezaufane źródło
$havingExpr = $db-&gt;quoteIdentifier($columnName) . ' &gt; ?';
$select-&gt;having($havingExpr, 1);
?&gt;</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.order"></a>9.3.7. Warunek ORDER BY</h3></div></div></div>
<p>
            Aby sortować dane użyj metody order() tyle razy ile potrzebujesz.
        </p>
<pre class="programlisting">&lt;?php
	
// tworzymy obiekt $db, a następie odbieramy narzędzie SELECT.
$select = $db-&gt;select();

// SELECT r.*
// FROM `round_table` r
// ORDER BY `noble_title` DESC, `first_name` ASC

$select-&gt;from('round_table');
$select-&gt;order('noble_title DESC');
$select-&gt;order('first_name');

// wywołanie metody order():
$select-&gt;order(array('noble_title DESC', 'first_name'));

?&gt;</pre>
<p>
            Nie określaj wielu kolumn jako pojedynczego łańcucha znaków z 
            nazwami kolumn oddzielonymi przecinkami. Taka składnia była używana
            we wcześniejszych wydaniach Zend_Db i nie jest ona już obsługiwana.
            Użyj zamiast tego tablicy.
        </p>
<p>
            Cytowanie jest stosowane do każdego elementu będącego łańcuchem
            znakow, znajdującym się argumencie dla order(), ale jeśli element
            ten jest obiektem typu Zend_Db_Expr, jego wartość jest używana bez
            cytowania.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.limit"></a>9.3.8. LIMIT w oparciu o ilość wyników i offset</h3></div></div></div>
<p>
            Zend_Db_Select oferuje obsługę bazodanowej składni LIMIT.
            Dla wielu baz danych, np. MySQL czy PostgreSQL, jest to
            relatywnie proste, ponieważ obsługują one składnię "LIMIT :count
            [OFFSET :offset]".
        </p>
<p>
            Dla niektórych innych baz danych, nie jets to takie proste, ponieważ 
            nie obsługują one składni LIMIT. Microsoft SQL Server posiada 
            składnię TOP, która daje taki sam rezultat. Oracle oraz DB2 wymagają 
            zapytań napisanych w specjalny sposób  aby emulować składnię LIMIT.
            Zend_Db_Select może przepisać zapytanie SELECT odpowiednio dla 
            każdego ze sterowników bazy danych aby umożliwiać obsługę 
            funkcjonalności LIMIT.
        </p>
<p>
            Aby limitować zwracane wyniki na podstawie ilości i offsetu użyj 
            metody limit() podając ilość oraz opcjonalny offset.
        </p>
<pre class="programlisting">&lt;?php
	
// na początek prosty "LIMIT :count"
$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('id');
$select-&gt;limit(10);

// W MySQL/PostgreSQL/SQLite odpowiada to zapytaniu:
//
// SELECT foo.*
// FROM "foo" foo
// ORDER BY "id" ASC
// LIMIT 10
//
// A w Microsoft SQL Server odpowiada to zapytaniu:
//
// SELECT TOP 10 foo.*
// FROM [foo] foo
// ORDER BY [id] ASC

// a teraz bardziej złożony "LIMIT :count OFFSET :offset"
$select = $db-&gt;select();
$select-&gt;from('foo', '*');
$select-&gt;order('id');
$select-&gt;limit(10, 20);

// W MySQL/PostgreSQL/SQLite odpowiada to zapytaniu:
//
// SELECT foo.*
// FROM "foo" foo
// ORDER BY "id" ASC
// LIMIT 10 OFFSET 20
//
// Microsoft SQL Server nie obsługuje offset, więc odpowiada to zapytaniu:
//
// SELECT * FROM (
//     SELECT TOP 10 * FROM (
//         SELECT TOP 30 *
//         FROM [foo] foo
//         ORDER BY [id] DESC
//     ) ORDER BY id ASC
// )
//
// Zend_Db_Adapter automatycznie tłumaczy zapytanie.

?&gt;</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.paging"></a>9.3.9. LIMIT w oparciu o ilość wyników i numer strony</h3></div></div></div>
<p>
            Zend_Db_Select oferuje limitowanie wyników oparte na stronach. Jeśli
            chcesz pobrać pewną stronę wyników, użyj metody limitPage();
            wpierw przekaż numer strony którą potrzebujesz, a nąstępnie ilość
            wierszy jaka ma się pojawiać na każdej ze stron.
        </p>
<pre class="programlisting">&lt;?php
	
// budujemy podstawowe zapytanie select...
$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('id');

// ... i limitujemy do strony 3 gdzie każda strona ma 10 wierszy
$select-&gt;limitPage(3, 10);

// W MySQL/PostgreSQL/SQLite, odpowiada to zapytaniu:
//
// SELECT foo.*
// FROM `foo` foo
// ORDER BY `id` ASC
// LIMIT 10 OFFSET 20

?&gt;</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="id4823667"></a>9.3.10. Inne metody</h3></div></div></div>
<p>
            Metoda distinct() pozwala dodać słowo kluczowe DISTINCT do twojego
            zapytania SQL.
        </p>
<pre class="programlisting">&lt;?php

// SELECT DISTINCT foo.`non_unique_column`
// FROM `foo` foo

$select = $db-&gt;select();
$select-&gt;distinct();
$select-&gt;from('foo', 'non_unique_column');

?&gt;</pre>
<p>
            Metoda forUpdate() pozwala dodać ci słowa kluczowe FOR UPDATE do
            twojego zapytania SQL.
        </p>
<pre class="programlisting">&lt;?php

// SELECT FOR UPDATE foo.*
// FROM `foo` foo

$select = $db-&gt;select();
$select-&gt;forUpdate();
$select-&gt;from('foo');

?&gt;</pre>
<p>
            Metoda query() działa podobnie jak metoda query() obiektu klasy
            Zend_Db_Adapter. Zwraca ona obiekt typu Zend_Db_Statement lub 
            PDOStatement, zależnie od typu używanego sterownika.
        </p>
<pre class="programlisting">&lt;?php

$select = $db-&gt;select();
$select-&gt;from('foo');
$stmt = $select-&gt;query();
$result = $stmt-&gt;fetchAll();

// Jest to równoznaczne z poniższym:
$select = $db-&gt;select();
$select-&gt;from('foo');
$stmt = $db-&gt;query($select);
$result = $stmt-&gt;fetchAll();

?&gt;</pre>
<p>
            Metoda getPart() zwraca dane, ktore przypisałeś do części zapytania
            SQL. Klasa Zend_Db_Select zawiera definicje stałych, których możesz
            użyć dla części zapytania SQL.
        </p>
<pre class="programlisting">&lt;?php

// SELECT foo.*
// FROM `foo` foo
// ORDER `keyColumn`

$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('keyColumn');

print_r( $select-&gt;getPart( Zend_Db_Select::ORDER ) );

?&gt;</pre>
<p>
            Metoda reset() pozwala ci na wyczyszczenie jednej określonej części
            zapytania SQL, lub na wyczyszczenie wszystkich części zapytania SQL,
            jeśli pominiesz argument podczas wywołania.
        </p>
<pre class="programlisting">&lt;?php

// SELECT foo.*
// FROM `foo` foo
// ORDER BY `column1`

$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('column1');

// Chcemy zmienić kryteria sortowania
//
// SELECT foo.*
// FROM `foo` foo
// ORDER BY `column2`

// Czyścimy jedną część aby zdefiniować ją ponownie
$select-&gt;reset( Zend_Db_Select::ORDER );
$select-&gt;order('column2');

// Czyścimy wszystkie części zapytania
$select-&gt;reset();

?&gt;</pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.profiler.html">Poprzedni</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Początek rozdziału</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.table.html">Następny</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">9.2. Zend_Db_Profiler </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Spis treści</a></td>
<td width="40%" align="right" valign="top"> 9.4. Zend_Db_Table</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
