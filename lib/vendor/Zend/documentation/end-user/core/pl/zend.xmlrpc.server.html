<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>29.3. Zend_XmlRpc_Server</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Przewodnik Programisty">
<link rel="up" href="zend.xmlrpc.html" title="Rozdział 29. Zend_XmlRpc">
<link rel="prev" href="zend.xmlrpc.client.html" title="29.2. Zend_XmlRpc_Client">
<link rel="next" href="coding-standard.html" title="Dodatek A. Zend Framework PHP Coding Standard">
<link rel="chapter" href="zend.html" title="Rozdział 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Rozdział 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Rozdział 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Rozdział 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Rozdział 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Rozdział 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Rozdział 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Rozdział 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Rozdział 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Rozdział 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Rozdział 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Rozdział 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Rozdział 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Rozdział 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Rozdział 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Rozdział 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Rozdział 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Rozdział 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Rozdział 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Rozdział 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Rozdział 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Rozdział 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Rozdział 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Rozdział 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Rozdział 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Rozdział 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Rozdział 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Rozdział 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Rozdział 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Dodatek A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="Dodatek B. Informacje o prawach autorskich">
<link rel="index" href="the.index.html" title="Indeks">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.introduction" title="29.3.1. Wprowadzenie">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.usage" title="29.3.2. Podstawowe użycie">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.structure" title="29.3.3. Struktura serwera">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.conventions" title="29.3.4. Konwencje">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.namespaces" title="29.3.5. Używanie przestrzeni nazw">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.request" title="29.3.6. Własny obiekt żądania">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.response" title="29.3.7. Własne odpowiedzi">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.fault" title="29.3.8. Handling Exceptions via Faults">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.caching" title="29.3.9. Buforowanie definicji serwera pomiędzy żądaniami">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.use" title="29.3.10. Przykład użycia">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">29.3. Zend_XmlRpc_Server</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.xmlrpc.client.html">Poprzedni</a> </td>
<th width="60%" align="center">Rozdział 29. Zend_XmlRpc</th>
<td width="20%" align="right"> <a accesskey="n" href="coding-standard.html">Następny</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pl">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.xmlrpc.server"></a>29.3. Zend_XmlRpc_Server</h2></div></div></div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.introduction"></a>29.3.1. Wprowadzenie</h3></div></div></div>
<p>Klasa Zend_XmlRpc_Server jest przeznaczona do użycia jako 
            pełnofunkcjonalny serwer XML-RPC, zgodny ze
            <a href="http://www.xmlrpc.com/spec" target="_top">specyfikacją przedstawioną
            na www.xmlrpc.com</a>. Dodatkowo implementuje ona metodę
            system.multicall(), pozwalającą na wywołanie wielu metod podczas
            jednego żądania.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.usage"></a>29.3.2. Podstawowe użycie</h3></div></div></div>
<p>
            Przykład najbardziej podstawowego przypadku użycia:
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'My/Service/Class.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('My_Service_Class');
echo $server-&gt;handle();</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.structure"></a>29.3.3. Struktura serwera</h3></div></div></div>
<p>
            Zend_XmlRpc_Server składa się z wielu różnych komponentów, od
            samego serwera, przez obiekty żądania, obiekty odpowiedzi aż do 
            obiektów błędów.
        </p>
<p>
            Aby uruchomić serwer Zend_XmlRpc_Server, programista musi dołączyć
            jedną lub więcej klas albo funkcji do serwera, za pomocą metod
            <code class="code">setClass()</code> oraz <code class="code">addFunction()</code>.
        </p>
<p>
            Kiedy jest to już zrobione, możesz przekazać obiekt 
            <code class="code">Zend_XmlRpc_Request</code> do metody 
            <code class="code">Zend_XmlRpc_Server::handle()</code>, lub zostanie utworzona
            instancja obiektu <code class="code">Zend_XmlRpc_Request_Http</code> w przypadku
            gdy nie zostanie zapewniony żaden obiekt -- spowoduje to pobieranie
            żądań z <code class="code">php://input</code>.
        </p>
<p>
            <code class="code">Zend_XmlRpc_Server::handle()</code> próbuje wtedy uruchomić
            odpowiednią klasę obsługującą, zależnie od użytej metody dostępu.
            Zwraca wtedy obiekt oparty na <code class="code">Zend_XmlRpc_Response</code> lub
            obiekt <code class="code">Zend_XmlRpc_Server_Fault</code>. Oba te obiekty mają
            dostępne metody <code class="code">__toString()</code>, ktore tworzą poprawne
            odpowiedzi XML-RPC, pozwalając na bezpośrednie ich wyświetlenie.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.conventions"></a>29.3.4. Konwencje</h3></div></div></div>
<p>
            Zend_XmlRpc_Server pozwala programiście dołączać funkcje oraz metody
            klas jako uruchamialne metody XML-RPC. Poprzez Zend_Server_Reflection, 
            przeprowadzana jest introspekcja dla wszystkich dołączanych metod, 
            używając bloków dokumentacji funkcji i metod do określenia opisów
            pomocy dla metod oraz sygnatur metod.
        </p>
<p>
            XML-RPC types do not necessarily map one-to-one to PHP types.
            However, the code will do its best to guess the appropriate type
            based on the values listed in @param and @return lines. Some XML-RPC
            types have no immediate PHP equivalent, however, and should be
            hinted using the XML-RPC type in the phpdoc. These include:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>dateTime.iso8601, łańcuch znaków sformatowany jako
                    YYYYMMDDTHH:mm:ss</p></li>
<li><p>base64, dane zakodowane jako base64</p></li>
<li><p>struct, dowolna tablica asocjacyjna</p></li>
</ul></div>
<p>
            Przykład wywołania przykładowej funkcji:
        </p>
<pre class="programlisting">&lt;?php
/**
* To jest przykładowa funkcja
*
* @param base64 $val1 Dane zakodowane jako Base64
* @param dateTime.iso8601 $val2 Data ISO
* @param struct $val3 Tablica asocjacyjna
* @return struct
*/
function myFunc($val1, $val2, $val3)
{
}</pre>
<p>
            PhpDocumentor nie przeprowadza walidacji typów określonych dla
            parametrów lub zwracanych wartości, więc nie będzie to miało wpływu
            na twoją dokumentację API
            Providing the hinting is necessary, however, when the
            server is validating the parameters provided to the method call.
        </p>
<p>
            It is perfectly valid to specify multiple types for both params and
            return values; the XML-RPC specification even suggests that
            system.methodSignature should return an array of all possible method
            signatures (i.e., all possible combinations of param and return
            values). You may do so just as you normally would with
            PhpDocumentor, using the '|' operator:
        </p>
<pre class="programlisting">&lt;?php
/**
* To jest przykładowa funkcja
*
* @param string|base64 $val1 Łańcuch znaków lub dane zakodowane jako base64
* @param string|dateTime.iso8601 $val2 Łańcuch znaków lub data ISO
* @param array|struct $val3 Normalnie indeksowana tablica lub tablica asocjacyjna
* @return boolean|struct
*/
function myFunc($val1, $val2, $val3)
{
}</pre>
<p>
            One note, however: allowing multiple signatures can lead to
            confusion for developers using the services; generally speaking, an
            XML-RPC method should only have a single signature.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.namespaces"></a>29.3.5. Używanie przestrzeni nazw</h3></div></div></div>
<p>
            XML-RPC has a concept of namespacing; basically, it allows grouping
            XML-RPC methods by dot-delimited namespaces. This helps prevent
            naming collisions between methods served by different classes. As an
            example, the XML-RPC server is expected to server several methods in
            the 'system' namespace:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>system.listMethods</p></li>
<li><p>system.methodHelp</p></li>
<li><p>system.methodSignature</p></li>
</ul></div>
<p>
            Wewnątrz odpowiada to metodom o tych samych w obiekcie 
            Zend_XmlRpc_Server.
        </p>
<p>
            Jeśli chcesz dodać przestrzenie nazw do metod, które oferujesz, po 
            prostu podaj przestrzeń nazw do odpowiedniej metody wtedy, gdy
            dołączasz funkcję lub klasę:
        </p>
<pre class="programlisting">&lt;?php
// Wszystkie publiczne metody klasy My_Service_Class będą dostępne jako
// myservice.METHODNAME
$server-&gt;setClass('My_Service_Class', 'myservice');

// Funkcja 'somefunc' będzie dostępna jako funcs.somefunc
$server-&gt;addFunction('somefunc', 'funcs');</pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.request"></a>29.3.6. Własny obiekt żądania</h3></div></div></div>
<p>
            Most of the time, you'll simply use the default request type
            included with Zend_XmlRpc_Server, Zend_XmlRpc_Request_Http. However,
            there may be times when you need XML-RPC to be available via the CLI,
            a GUI, or other environment, or want to log incoming requests. To do
            so, you may create a custom request object that extends
            Zend_XmlRpc_Request. The most important thing to remember is to
            ensure that the getMethod() and getParams() methods are implemented
            so that the XML-RPC server can retrieve that information in order to
            dispatch the request.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.response"></a>29.3.7. Własne odpowiedzi</h3></div></div></div>
<p>
            Podobnie jak obiekty żądania, Zend_XmlRpc_Server może zwracać własne
            obiekty odpowiedzi; domyślnie zwracany jest obiekt 
            Zend_XmlRpc_Response_Http, który wysyła odpowiedni nagłówek HTPP
            Content-Type do użycia z XML-RPC. Możliwym powodem użycia własnego
            obiektu może być potrzeba logowania odpowiedzi, lub wysyłanie 
            odpowiedzi spowrotem do STDOUT.
        </p>
<p>
            Aby użyć własnej klasy odpowiedzi, użyj metody
            Zend_XmlRpc_Server::setResponseClass() przed wywołaniem handle().
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.fault"></a>29.3.8. Handling Exceptions via Faults</h3></div></div></div>
<p>
            Zend_XmlRpc_Server catches Exceptions generated by a dispatched
            method, and generates an XML-RPC fault response when such an
            exception is caught. By default, however, the exception messages and
            codes are not used in a fault response. This is an intentional
            decision to protect your code; many exceptions expose more
            information about the code or environment than a developer would
            necessarily intend (a prime example includes database abstraction or
            access layer exceptions).
        </p>
<p>
            Exception classes can be whitelisted to be used as fault responses,
            however. To do so, simply utilize
            Zend_XmlRpc_Server_Fault::attachFaultException() to pass an
            exception class to whitelist:
        </p>
<pre class="programlisting">&lt;?php
Zend_XmlRpc_Server_Fault::attachFaultException('My_Project_Exception');</pre>
<p>
            If you utilize an exception class that your other project exceptions
            inherit, you can then whitelist a whole family of exceptions at a
            time. Zend_XmlRpc_Server_Exceptions are always whitelisted, to
            allow reporting specific internal errors (undefined methods, etc.).
        </p>
<p>
            Any exception not specifically whitelisted will generate a fault
            response with a code of '404' and a message of 'Unknown error'.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.caching"></a>29.3.9. Buforowanie definicji serwera pomiędzy żądaniami</h3></div></div></div>
<p>
            Dołączanie wielu klas do instancji serwera XML-RPC może zajmować
            wiele zasobów; za pomocą Reflection API (przez Zend_Server_Reflection)
            musi być dokonana introspekcja każdej klasy co w rezultacie wygeneruje
            listę wszystkich możliwych sygnatur metod w celu przekazania jej
            do klasy serwera.
        </p>
<p>
            Aby zredukować straty wydajności, możemy użyć obiektu 
            Zend_XmlRpc_Server_Cache do buforowania definicji serwera pomiędzy 
            żądaniami. Gdy połączymy to z funkcją __autoload(), może to mocno 
            zwiększyć wydajność.
        </p>
<p>
            Przykładowe użycie:
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend.php';
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Cache.php';

function __autoload($class)
{
    Zend::loadClass($class);
}

$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';
$server = new Zend_XmlRpc_Server();

if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    require_once 'My/Services/Glue.php';
    require_once 'My/Services/Paste.php';
    require_once 'My/Services/Tape.php';

    $server-&gt;setClass('My_Services_Glue', 'glue');   // przestrzeń nazwa glue
    $server-&gt;setClass('My_Services_Paste', 'paste'); // przestrzeń nazwa paste
    $server-&gt;setClass('My_Services_Tape', 'tape');   // przestrzeń nazwa tape

    Zend_XmlRpc_Server_Cache::save($cacheFile, $server);
}

echo $server-&gt;handle();</pre>
<p>
            Powyższy przykład próbuje pobrać definicję serwera z pliku bufora
            xmlrpc.cache znajdującego się w tym samym katalogu co skrypt. Jeśli
            się to nie uda, załaduje on potrzebne klasy serwisu, dołączy do
            instancji serwera i spróbuje utworzyć nowy plik bufora z definicją
            sderwera.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.use"></a>29.3.10. Przykład użycia</h3></div></div></div>
<p>
            Poniżej znajduje się kilka przykładów użycia, pokazując pełne 
            spektrum opcji dostępnych dla programistów. Każdy z przykładów
            użycia jest oparty na poprzednich przykładach.
        </p>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case1"></a>29.3.10.1. Podstawowe użycie</h4></div></div></div>
<p>
                Poniższy przykład dołącza funkcję jaką uruchamialną przez
                XML-RPC metodę i obsługuje przychodzące wywołania.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';

/**
 * Zwraca sumę MD5 zadanej wartości
 *
 * @param string $value wartość do obliczenia sumy md5
 * @return string MD5 suma wartości
 */
function md5Value($value)
{
    return md5($value);
}

$server = new Zend_XmlRpc_Server();
$server-&gt;addFunction('md5Value');
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case2"></a>29.3.10.2. Dołączanie klasy</h4></div></div></div>
<p>
                Poniższy przykład pokazuje dołączanie publicznych metod klasy 
                jako uruchamialnych metod XML-RPC.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Services/Comb.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb');
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case3"></a>29.3.10.3. Dołączanie wielu klas używając przestrzeni nazw</h4></div></div></div>
<p>
                Poniższy przykład pokazuje dołączanie kilku klas, każdej z 
                własną przestrzenią nazw.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // metody wywoływane jako comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // metody wywoływane jako brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // metody wywoływane jako pick.*
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case4"></a>29.3.10.4. Określenie wyjątków dla odpowiedzi błędów</h4></div></div></div>
<p>
                Poniższy przykład pozwala dowolnej klasie pochodzącej od
                Services_Exception na przekazywanie informacji o wyjątkach w
                postaci kodu i wiadomości w odpowiedzi błędu.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Pozwala na wyrzucanie wyjątku Services_Exceptions dla odpowiedzi błędu
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // metody wywoływane jako comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // metody wywoływane jako brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // metody wywoływane jako pick.*
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case5"></a>29.3.10.5. Użycie własnego obiektu żądania</h4></div></div></div>
<p>
                Poniższy przykład tworzy instancję własnego obiektu żądania i
                przekazuje go do obiektu serwera.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Request.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Pozwala na wyrzucanie wyjątku Services_Exceptions dla odpowiedzi błędu
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // metody wywoływane jako comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // metody wywoływane jako brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // metody wywoływane jako pick.*

// Tworzenie obiektu żądania
$request = new Services_Request();

echo $server-&gt;handle($request);</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case6"></a>29.3.10.6. Użycie własnego obiektu odpowiedzi</h4></div></div></div>
<p>
                Poniższy przykład pokazuje określanie własnej klasy odpowiedzi
                dla zwracanej odpowiedzi.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Pozwala na wyrzucanie wyjątku Services_Exceptions dla odpowiedzi błędu
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // metody wywoływane jako comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // metody wywoływane jako brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // metody wywoływane jako pick.*

// Utwórz obiekt żądania
$request = new Services_Request();

// Użyj własnego obiektu żądania
$server-&gt;setResponseClass('Services_Response');

echo $server-&gt;handle($request);</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case7"></a>29.3.10.7. Buforowanie definicji serwera pomiędzy żądaniami</h4></div></div></div>
<p>
                Poniższy przykład pokazuje buforowanie definicji serwera pomiędzy
                żądaniami.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Zend/XmlRpc/Server/Cache.php';
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Określ plik cache
$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';

// Pozwala na wyrzucanie wyjątku Services_Exceptions dla odpowiedzi błędu
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();

// Spróbuj pobrać definicje serwera z bufora
if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    $server-&gt;setClass('Services_Comb', 'comb');   // metody wywoływane jako comb.*
    $server-&gt;setClass('Services_Brush', 'brush'); // metody wywoływane jako brush.*
    $server-&gt;setClass('Services_Pick', 'pick');   // metody wywoływane jako pick.*

    // Zapisz cache
    Zend_XmlRpc_Server_Cache::save($cacheFile, $server));
}

// Utwórz obiekt żądania
$request = new Services_Request();

// Użyj własnej klasy odpowiedzi
$server-&gt;setResponseClass('Services_Response');

echo $server-&gt;handle($request);</pre>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.xmlrpc.client.html">Poprzedni</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.xmlrpc.html">Początek rozdziału</a></td>
<td width="40%" align="right"> <a accesskey="n" href="coding-standard.html">Następny</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">29.2. Zend_XmlRpc_Client </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Spis treści</a></td>
<td width="40%" align="right" valign="top"> Dodatek A. Zend Framework PHP Coding Standard</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
