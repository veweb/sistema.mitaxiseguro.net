<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>28.4. Klasy pomocników</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Przewodnik Programisty">
<link rel="up" href="zend.view.html" title="Rozdział 28. Zend_View">
<link rel="prev" href="zend.view.scripts.html" title="28.3. Skrypty widoków">
<link rel="next" href="zend.xmlrpc.html" title="Rozdział 29. Zend_XmlRpc">
<link rel="chapter" href="zend.html" title="Rozdział 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Rozdział 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Rozdział 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Rozdział 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Rozdział 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Rozdział 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Rozdział 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Rozdział 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Rozdział 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Rozdział 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Rozdział 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Rozdział 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Rozdział 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Rozdział 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Rozdział 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Rozdział 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Rozdział 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Rozdział 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Rozdział 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Rozdział 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Rozdział 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Rozdział 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Rozdział 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Rozdział 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Rozdział 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Rozdział 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Rozdział 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Rozdział 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Rozdział 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Dodatek A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="Dodatek B. Informacje o prawach autorskich">
<link rel="index" href="the.index.html" title="Indeks">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.initial" title="28.4.1. Wbudowane klasy pomocników">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.paths" title="28.4.2. Ścieżki klas pomocników">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.custom" title="28.4.3. Pisanie własnych klas pomocników">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">28.4. Klasy pomocników</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.view.scripts.html">Poprzedni</a> </td>
<th width="60%" align="center">Rozdział 28. Zend_View</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.xmlrpc.html">Następny</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pl">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.view.helpers"></a>28.4. Klasy pomocników</h2></div></div></div>
<p>
        W skryptach widoków często potrzebne jest przeprowadzanie złożonych 
        funkcji; na przykład formatowanie daty, generowanie elementów formularzy, 
        czy wyświetlanie odnośnikow akcji. Możesz użyć klas pomocników w tym celu.
    </p>
<p>
        Aby użyć pomocnika w swoim skrypcie widoku, wywołaj go za pomocą
        $this-&gt;nazwaPomocnika(). Obiekt Zend_View załaduje klasę 
        Zend_View_Helper_NazwaPomocnika, utworzy obiekt tej klasy i wywoła
        metodę nazwaPomocnika(). Instancja obiektu istnieje teraz w instancji
        Zend_View i będzie ona ponownie używana przy następnych wywołaniach 
        $this-&gt;nazwaPomocnika().
    </p>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.initial"></a>28.4.1. Wbudowane klasy pomocników</h3></div></div></div>
<p>
            Zend_View posiada wbudowany zbiór klas pomocników, z których
            wszystkie odnoszą się do generowania formularzy. Każda z nich
            autmatycznie filtruje dane wyjściowe. Są to:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                formButton($name, $value, $attribs): Tworzy element &lt;input
                type="button" /&gt;.
            </p></li>
<li><p>
                formCheckbox($name, $value, $attribs, $options): Tworzy element 
                &lt;input type="checkbox" /&gt;. Parametr $options jest tablicą
                w której pierwszy element jest wartością dla pola zaznaczonego 
                ("checked"), a drugi wartością dla niezaznaczonego ("unchecked")
                (domyślnie są to wartości '1' i '0'). Jeśli wartość $value odpowiada
                wartości pola zaznaczonego ("checked"), to pole zostanie zaznaczone.
            </p></li>
<li><p>
                formFile($name, $value, $attribs): Tworzy element &lt;input
                type="file" /&gt;.
            </p></li>
<li><p>
                formHidden($name, $value, $attribs): Tworzy element &lt;input
                type="hidden" /&gt;.
            </p></li>
<li><p>
                formPassword($name, $value, $attribs): Tworzy element &lt;input
                type="password" /&gt;.
            </p></li>
<li><p>
                formRadio($name, $value, $attribs, $options): Tworzy serię
                elementów &lt;input type="radio" /&gt;, po jednym dla każdego
                elementu tablicy $options. W tablicy $options, klucz
                jest wartością przycisku radio, a wartość elementu tablicy 
                jest etykietą przycisku radio. Zmienna $value określa wartość
                przycisku, który ma być początkowo zaznaczony.
            </p></li>
<li><p>
                formReset($name, $value, $attribs): Tworzy element &lt;input
                type="reset" /&gt;.
            </p></li>
<li><p>
                formSelect($name, $value, $attribs, $options): Tworzy blok
                &lt;select&gt;...&lt;/select&gt;, z elementami 
                &lt;option&gt; po jednym dla każdego elementu tablicy $options.  
                W tablicy $options klucz jest wartościa elementu, a wartość
                jest etykietą. Zmienna $value określa wartośc elementu (lub
                elementów), który ma być początkowo zaznaczony.
            </p></li>
<li><p>
                formSubmit($name, $value, $attribs): Tworzy element &lt;input
                type="submit" /&gt;.
            </p></li>
<li><p>
                formText($name, $value, $attribs): Tworzy element &lt;input
                type="text" /&gt;.
            </p></li>
<li><p>
                formTextarea($name, $value, $attribs): Tworzy element 
                &lt;textarea&gt;...&lt;/textarea&gt;.
            </p></li>
</ul></div>
<p>
            Użycie tych metod w Twoim skrypcie jest bardzo łatwe, poniżej
            znajduje się przykład. Zauważ, że wszystko czego potrzebujesz
            to wywołanie tych metod; załadowanie ich i utworzenie instancji
            odbędzie się automatycznie.
        </p>
<pre class="programlisting">&lt;?php
// wewnątrz skryptu widoku, $this odnosi się do instancji Zend_View.
// 
// załóżmy, że już przypisałeś serię elementów opcji jako tablicę
// o nazwie $countries = array('us' =&gt; 'United States', 'il' =&gt;
// 'Israel', 'de' =&gt; 'Germany').
?&gt;
&lt;form action="action.php" method="post"&gt;
    &lt;p&gt;&lt;label&gt;Adres Email:
        &lt;?php echo $this-&gt;formText('email', 'you@example.com', array('size' =&gt; 32)) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Kraj:
        &lt;?php echo $this-&gt;formSelect('country', 'us', null, $this-&gt;countries) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Czy zgadzasz się?
        &lt;?php echo $this-&gt;formCheckbox('opt_in', 'yes', null, array('yes', 'no')) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
        </pre>
<p>
            Rezultat wyglądałby w ten sposób:    
        </p>
<pre class="programlisting">&lt;form action="action.php" method="post"&gt;
    &lt;p&gt;&lt;label&gt;Adres Email:
        &lt;input type="text" name="email" value="you@example.com" size="32" /&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Kraj:
        &lt;select name="country"&gt;
            &lt;option value="us" selected="selected"&gt;United States&lt;/option&gt;
            &lt;option value="il"&gt;Israel&lt;/option&gt;
            &lt;option value="de"&gt;Germany&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Czy zgadzasz się?
        &lt;input type="hidden" name="opt_in" value="no" /&gt;
        &lt;input type="checkbox" name="opt_in" value="yes" checked="checked" /&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
        </pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.paths"></a>28.4.2. Ścieżki klas pomocników</h3></div></div></div>
<p>
            Tak jak ze skryptami widoków, kontroler może określić stos ścieżek,
            w których Zend_View ma szukać klas pomocników. Domyślnie Zend_View 
            szuka klas pomocników w katalogu "Zend/View/Helper/*". Możesz wybrać
            inny katalog używając metod setHelperPath() oraz addHelperPath().
            Dodatkowo możesz określić przedrostek klas pomocników znajdujących 
            się w podanej ścieżce aby utworzyć przestrzenie nazw dla klas pomocników.
            Domyślnie, gdy żaden przedrostek nie zostanie określony, przyjęty
            zostanie przedrostek 'Zend_View_Helper_'.
        </p>
<pre class="programlisting">&lt;?php
$view = new Zend_View();
// Ustaw ścieżkę na /path/to/more/helpers, z przedrostkiem 'My_View_Helper'
$view-&gt;setHelperPath('/path/to/more/helpers', 'My_View_Helper');
?&gt;
        </pre>
<p>
            Oczywiście możesz dodawać ścieżki na stos używająć metody addHelperPath().
            Gdy dodajesz ścieżki na stos, Zend_View będzie szukać klasy pomocnika
            począwszy od ostatnio dodanej ścieżki. To pozwala na dodanie (lub 
            nawet nadpisanie) podstawowego pakietu klas pomocników swoimi własnymi 
            klasami.
        </p>
<pre class="programlisting">&lt;?php
$view = new Zend_View();
// Add /path/to/some/helpers with class prefix 'My_View_Helper'
$view-&gt;addHelperPath('/path/to/some/helpers');
// Add /other/path/to/helpers with class prefix 'Your_View_Helper'
$view-&gt;addHelperPath('/other/path/to/helpers');

// teraz kiedy wywołasz $this-&gt;helperName(), Zend_View będzie wpierw szukał w
// "/other/path/to/helpers/HelperName.php" używając nazwy klasy "My_View_Helper_HelperName", 
// następnie w "/path/to/some/helpers/HelperName" używając nazwy klasy "Your_View_Helper_HelperName", 
// i ostatecznie w "Zend/View/Helper/HelperName.php" używając nazwy klasy "Zend_View_Helper_HelperName".
?&gt;
        </pre>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.custom"></a>28.4.3. Pisanie własnych klas pomocników</h3></div></div></div>
<p>
            Pisanie własnych klas pomocników jest łatwe; po prostu pisz według 
            poniższych zasad:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                Minimalna nazwa klasy musi kończyć się nazwą pomocnika przy
                użyciu CamelCaps. Przykładowo, jeśli piszesz klasę pomocnika
                zwaną "specialPurpose", minimalną nazwą klasy musi być 
                "SpecialPurpose". Możesz, a nawet powinieneś nadać nazwie klasy
                przedrostek i jest zalecane, abyś użył 'View_Helper' jako
                części przedrostka: "My_View_Helper_SpecialPurpose". (Przedrostek
                będziesz musiał przekazać wraz z końcowym znakiem podkreślenia
                lub bez niego, do metod <code class="code">addHelperPath()</code> oraz
                <code class="code">setHelperPath()</code>).
            </p></li>
<li><p>
                Klasa musi posiadać publiczną metodę która jest taka jak nazwa 
                pomocnika; jest to metoda która zostanie wywołana gdy skrypt
                widoku wywoła "$this-&gt;twojPomocnik()". W przykładzie pomocnika
                "twojPomocnik", wymaganą deklaracją metody powinno być
                "public function twojPomocnik()". 
            </p></li>
<li><p>
                Klasa nie powinna wyświetlać ani w inny sposób generować danych 
                wyjściowych. Zamiast tego powinna zwrócić dane do wyświetlenia.
                Zwracane wartości powinny być odpowiednio przefiltrowane.
            </p></li>
<li><p>
                Klasa musi znajdować się w pliku odpowiednio do nazwy pomocnika.
                Przykladowo dla pomocnika o nazwie "twojPomocnik", plik powinien
                nazywać się "TwojPomocnik.php".
            </p></li>
</ul></div>
<p>
            Umieść plik klasy pomocnika w katalogu który był dodany do stosu 
            ścieżek, a Zend_View automatycznie załaduje klasę, utworzy instancję,
            i uruchomi metodę. 
        </p>
<p>
            Poniżej przykład kodu naszego przykładowego pomocnika twojPomocnik:
        </p>
<pre class="programlisting">&lt;?php
class My_View_Helper_TwojPomocnik {
    protected $_count = 0;
    public function twojPomocnik()
    {
        $this-&gt;_count++;
        $output = "I have seen 'The Jerk' {$this-&gt;_count} time(s).";
        return htmlspecialchars($output);
    }
}
?&gt;
        </pre>
<p>
            Teraz w skrypcie widoku możesz wywołać pomocnika TwojPomocnik
            tyle razy ile zechcesz; instancja zostanie utworzona raz i będzie
            ona istniała przez cały okres istnienia instancji Zend_View.
        </p>
<pre class="programlisting">&lt;?php
// pamiętaj, że w skrypcie widoku $this odnosi się do instancji Zend_View.
echo $this-&gt;twojPomocnik();
echo $this-&gt;twojPomocnik();
echo $this-&gt;twojPomocnik();
?&gt;
        </pre>
<p>
            Dane wyjściowe wyglądałyby w ten sposób:
        </p>
<pre class="programlisting">I have seen 'The Jerk' 1 time(s).
I have seen 'The Jerk' 2 time(s).
I have seen 'The Jerk' 3 time(s).
        </pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.view.scripts.html">Poprzedni</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.view.html">Początek rozdziału</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.xmlrpc.html">Następny</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">28.3. Skrypty widoków </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Spis treści</a></td>
<td width="40%" align="right" valign="top"> Rozdział 29. Zend_XmlRpc</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
