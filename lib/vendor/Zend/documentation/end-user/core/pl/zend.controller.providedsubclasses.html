<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>7.4. Dostępne podklasy</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Przewodnik Programisty">
<link rel="up" href="zend.controller.html" title="Rozdział 7. Zend_Controller">
<link rel="prev" href="zend.controller.subclassing.html" title="7.3. Rozszerzanie">
<link rel="next" href="zend.controller.action.html" title="7.5. Action Controllers">
<link rel="chapter" href="zend.html" title="Rozdział 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Rozdział 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Rozdział 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Rozdział 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Rozdział 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Rozdział 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Rozdział 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Rozdział 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Rozdział 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Rozdział 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Rozdział 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Rozdział 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Rozdział 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Rozdział 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Rozdział 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Rozdział 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Rozdział 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Rozdział 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Rozdział 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Rozdział 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Rozdział 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Rozdział 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Rozdział 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Rozdział 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Rozdział 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Rozdział 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Rozdział 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Rozdział 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Rozdział 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Dodatek A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="Dodatek B. Informacje o prawach autorskich">
<link rel="index" href="the.index.html" title="Indeks">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.introduction" title="7.4.1. Wprowadzenie">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http" title="7.4.2. Zend_Controller_Request_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.rewriterouter" title="7.4.3. Zend_Controller_Router_Rewrite">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.http" title="7.4.4. Zend_Controller_Response_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.cli" title="7.4.5. Zend_Controller_Response_Cli">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">7.4. Dostępne podklasy</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Poprzedni</a> </td>
<th width="60%" align="center">Rozdział 7. Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.controller.action.html">Następny</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pl">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.providedsubclasses"></a>7.4. Dostępne podklasy</h2></div></div></div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.introduction"></a>7.4.1. Wprowadzenie</h3></div></div></div>
<p>
            Zend Framework zapewnia kilka alternatyw dla domyślnych klas,
            włączając w to alternatywne obiekty żądania, routery oraz obiekty
            odpowiedzi.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.request.http"></a>7.4.2. Zend_Controller_Request_Http</h3></div></div></div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.introduction"></a>7.4.2.1. Wprowadzenie</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> zapewnia obiekt 
                żądania do użycia w środowisku HTTP. Klasa  
                <code class="code">Zend_Controller_Request_Http</code> jest domyślną klasą
                żądania używaną przez <code class="code">Zend_Controller_Dispatcher</code>.
            </p>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.dataaccess"></a>7.4.2.2. Dostęp do danych żądania</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> obudowuje dostęp
                do odpowiednich wartości takich jak nazwa klucza i wartość
                dla zmiennych kontrolera i akcji routera, oraz do dodatkowych
                parametrów pobranych z adresu URI. Rozszerzając
                <code class="code">Zend_Controller_Request_Http</code> dodatkowo pozwala na 
                uzyskanie dostępu do wartości zawartych w superglobalnych 
                tablicach jako do publicznych właściwości obiektu i zarządza 
                obecnym bazowym adresem URL oraz adresem URL żądania. 
                Superglobalne wartości nie mogą być ustawione w obiekcie 
                żądania, zamiast tego użyj metod setParam/getParam aby ustawić 
                lub odebrać parametry użytkownika.
            </p>
<div class="note"><table border="0" summary="Note: Dane superglobalne">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Dane superglobalne</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Kiedy uzyskujemy dostęp do danych superglobalnych za pomocą
                    klasy <code class="code">Zend_Controller_Request_Http</code> jak do jej 
                    publicznych właściwości, ważne jest aby pamiętać, że nazwa właściwości 
                    (klucz tablicy superglobalnej) jest dopasowana do superglobalnych 
                    w określonej kolejności: 1. GET, 2. POST, 3. COOKIE, 4. SERVER, 5. ENV.
                </p></td></tr>
</table></div>
<p>
                Konkretne zmienne superglobalne mogą być alternatywnie dostępne 
                za pomocą publicznej metody. Na przykład, wartość 
                <code class="code">$_POST['user']</code> może być dostępna przez wywołanie 
                metody <code class="code">getPost('user')</code> na obiekcie żądania.
            </p>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.baseurl"></a>7.4.2.3. Bazowy Url oraz podkatalogi</h4></div></div></div>
<p>
                Klasa <code class="code">Zend_Controller_Request_Http</code> pozwala na użycie 
                klasy Zend_Controller_Router_Rewrite w podkatalogach. 
                Zend_Controller_Request_Http spróbuje automatycznie wykryć twój 
                bazowy adres URL i ustawi go odpowiednio.
            </p>
<p>
                Na przykład jeśli twój plik <code class="code">index.php</code> jest w
                podkatalogu nazwanym <code class="code">/projects/myapp/index.php</code>, 
                bazowy URL (bazowy adres przepisania) powinien być ustawiony na
                <code class="code">/projects/myapp</code>. Ten łańcuch znaków zostanie 
                obcięty z początu ścieżki zanim będą dopasowane jakiekolwiek trasy.
                To zwalnia z konieczności dołączania tego adresu do każdej z tras. 
                Trasa <code class="code">'user/:username'</code> dopasuje adresy URI takie
                jak <code class="code">http://localhost/projects/myapp/user/martel</code> oraz
                <code class="code">http://example.com/user/martel</code>.
            </p>
<div class="note"><table border="0" summary="Note: Detekcja URL jest wrażliwa na małe i duże litery">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Detekcja URL jest wrażliwa na małe i duże litery</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Automatyczna detekcja adresów URL jest wrażliwa na małe i duże
                    litery, więc upewnij się, że adres URL zostanie dobrze dopasowany
                    do nazwy podkatalogu w systemie plików (nawet w systemie 
                    Windows). Jeśli nie zostanie, zostanie wywołana akcja noRoute.
                </p></td></tr>
</table></div>
<p>
                Jeśli bazowy adres URL jest wykrywany nieprawidłowo, możesz
                go nadpisać w obiekcie Zend_Http_Request wywołując metodę
                <code class="code">setBaseUrl()</code> lub tą samą metodę klasy
                <code class="code">Zend_Controller_Request_Http</code> lub klasy
                <code class="code">Zend_Controller_Front</code>. Najłatwiejszy sposób
                to ustawienie tego w klasie <code class="code">Zend_Controller_Front</code>, 
                która przekaże to do obiektu żądania. Przykładowe użycie
                ustawiania własnego bazowego adresu URL:
            </p>
<pre class="programlisting">
/** 
 * Uruchom żądanie z własnym bazowym URL za pomocą Zend_Controller_Front.
 */
$router     = new Zend_Controller_Router_Rewrite();
$controller = Zend_Controller_Front::getInstance();
$controller-&gt;setControllerDirectory('./application/controllers')
           -&gt;setRouter($router)
           -&gt;setBaseUrl('/projects/myapp'); // ustaw bazowy URL!
$response   = $controller-&gt;dispatch();</pre>
</div>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter"></a>7.4.3. Zend_Controller_Router_Rewrite</h3></div></div></div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.introduction"></a>7.4.3.1. Wprowadzenie</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Router_Rewrite</code> jest standardowym
                routerem we frameworku. Routing jest procesem pobrania adresu 
                URI i rozłożenia go w celu ustalenia jaki kontroler i jaka akcja 
                powinny otrzymać żądanie. Ta informacja o kontrolerze, akcji i 
                opcjonalnych parametrach jest pakowana do obiektu 
                <code class="code">Zend_Controller_Request_Http</code>, który jest potem 
                przetwarzany przez <code class="code">Zend_Controller_Dispatcher_Standard</code>. 
                Routing ma miejsce tylko raz: wtedy gdy żądanie jest po raz 
                pierwszy otrzymane, przed wywołaniem pierwszego kontrolera.
            </p>
<p>
                <code class="code">Zend_Controller_Router_Rewrite</code> jest zaprojektowany w 
                celu uzyskania w czystym PHP takiej funkcjonalności jak w 
                mod_rewrite. Jest to luźno wzorowane na routingu Ruby on Rails i 
                nie wymaga żadnej wiedzy o przepisywaniu adresów przez serwer 
                www. Jest to zaprojektowane w taki sposób, aby działało po 
                dodaniu tylko jednej reguły mod_rewrite (jednej z poniższych):
            </p>
<pre class="programlisting">
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php</pre>
<p>
            lub:
            </p>
<pre class="programlisting">
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 </pre>
<p>
                Rewrite router może być także użyty z serwerem IIS, jeśli moduł
                <a href="http://www.isapirewrite.com" target="_top">Isapi_Rewrite</a>
                jest zainstalowany jako rozszerzenie Isapi, z taką regułą 
                przepisywania:
            </p>
<pre class="programlisting">
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]</pre>
<div class="note"><table border="0" summary="Note: IIS Isapi_Rewrite">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">IIS Isapi_Rewrite</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Jeśli używasz serwera IIS, to wartość 
                    <code class="code">$_SERVER['REQUEST_URI']</code> nie istnieje lub jest 
                    pustym łańcuchem znaków. W takim wypadku, 
                    <code class="code">Zend_Controller_Request_Http</code> spróbuje użyć wartości 
                    <code class="code">$_SERVER['HTTP_X_REWRITE_URL']</code> ustawionej przez 
                    rozszerzenie Isapi_Rewrite.
                </p></td></tr>
</table></div>
<p>Jeśli używasz serwera Lighttpd, poniższa reguła jest prawidłowa:</p>
<pre class="programlisting">
url.rewrite-once = ( ".*\.(js|ico|gif|jpg|png|css)$" =&gt; "$0", "" =&gt; "/index.php")</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.usage"></a>7.4.3.2. Użycie routera</h4></div></div></div>
<p>
                Aby prawidłowo użyć rewrite routera musisz utworzyć jego 
                instancję, zdefiniować jakieś trasy i przekazać ten obiekt do 
                kontrolera. Poniższy kod pokazuje tą procedurę:
            </p>
<pre class="programlisting">
/* Utwórz router */

$router = $ctrl-&gt;getRouter(); // domyślnie zwraca rewrite router
$router-&gt;addRoute(
	'user',
	new Zend_Controller_Router_Route('user/:username', array('controller' =&gt; 'user', 'action' =&gt; 'info'))
);
</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.basic"></a>7.4.3.3. Podstawowe trasy</h4></div></div></div>
<p>
                Sercem RewriteRoutera jest definicja tras określonych przez 
                użytkownika. Trasy są tworzone przez wywołanie metody addRoute 
                obiektu RewriteRouter i przekazanie do niej nowej instancji
                obiektu <code class="code">Zend_Controller_Router_Route</code>:
            </p>
<pre class="programlisting">
$router-&gt;addRoute('user', new Zend_Controller_Router_Route('user/:username'));</pre>
<p>
                Pierwszy parametr jest nazwą trasy. Obecnie nie jest konieczne 
                jego definiowanie, jednak będzie on używany w przyszłości w 
                klasie pomocniczej widoku ułatwiającej łatwe generowanie adresów 
                URL. Jeśli chcesz użyć wcześniej skonfigurowanej trasy, możesz 
                ją odebrać za pomocą metody getRoute RewriteRoutera. Drugi 
                parametr jest instancją <code class="code">Zend_Controller_Router_Route</code>.
            </p>
<p>
                Pierwszy parametr konstruktora obiektu 
                <code class="code">Zend_Controller_Router_Route</code> jest trasą, która ma
                być dopasowana do adresu URL - na przykład powyższa trasa 
                zostanie dopasowana do adresu <code class="code">http://example.com/user/martel</code>. 
                Dwukropek w trasie oznacza zmienną adresu URL. Po udanym dopasowaniu
                trasy, wartości wszystkich zdefiniowanych zmiennych zostaną przekazane
                do obiektu Zend_Controller_Request. Po tym będą one dostępne za pomocą
                metod Zend_Controller_Request::getParam oraz
                Zend_Controller_Action::_getParam. W naszym przykładzie
                parametr nazwany username będzie miał ustawioną wartość 'martel'.
            </p>
<div class="note"><table border="0" summary="Note: Odwrotne dopasowywanie">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Odwrotne dopasowywanie</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Trasy są dopasowywane w odwrotnej kolejności więc musisz 
                    pamiętać żeby podstawowe trasy były zdefiniowane na początku.
                </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note: Użycie znaków">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Użycie znaków</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Teraz obecna implementacja pozwala na użycie w nazwie 
                    zmiennej dowolnych znaków z wyjątkiem ukośnika (/), ale jest 
                    mocno zalecane używanie jedynie znaków, które są 
                    bezproblemowo obsługiwane ptzrz PHP. W przyszłości 
                    implementacja prawdopodobnie zostanie zmodyfikowana co 
                    mogłoby wprowadzić do twojego kodu błędy.
                </p></td></tr>
</table></div>
<p>
                Są dwie specjalne zmienne które nie mogą być użyte w twoich 
                trasach - ':controller' oraz ':action'. Te specjalne zmienne 
                będą użyte aby znaleść kotroler oraz akcję w danym adresie URL. 
                Zmienna ':action' zawsze musi być zdefiniowana w trasie lub jako 
                domyślny parametr. Zmienna ':controller' będzie domyślnie 
                ustawiona na IndexController jeśli nie będzie zdefiniowana.
            </p>
<div class="note"><table border="0" summary="Note: Specjalne zmienne">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Specjalne zmienne</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Nazwy tych specjalnych zmiennych mogą być inne, jeśli zdecydujesz
                    zmienić je w obiekcie <code class="code">Zend_Controller_Request_Http</code>  
                    za pomocą metod setControllerKey oraz setActionKey.
                </p></td></tr>
</table></div>
<pre class="programlisting">
$router-&gt;addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);</pre>
<p>
                Jeśli skierujesz przeglądarkę na adres 
                'http://example.com/news/latest' ze zdefiniowaną powyższą trasą 
                <code class="code">Zend_Controller_Dispatcher</code> odwoła się do akcji 
                latestAction z kontrolera NewsController.
            </p>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-defaults"></a>7.4.3.4. Domyślne wartości zmiennych</h4></div></div></div>
<p>
                Każda zmienna w trasie może mieć wartość domyślną. Aby to 
                zrobić, musisz przekazać drugi parametr do konstruktora 
                <code class="code">Zend_Controller_Router_Route</code>. Ten parametr jest 
                tablicą z nazwami zmiennych jako kluczami i z wartościami, 
                które mają być uznane za domyślne.
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006))
);</pre>
<p>
                Może nie jest wyraźnie widoczne to, że powyższa trasa dopasuje 
                adresy URL takie jak 'http://example.com/archive/2005' oraz 
                'http://example.com/archive'. Ostatecznie zmienna year i tak 
                będzie miała wartość 2006.
            </p>
<p>
                Powyższy przykład spowoduje jedynie przekazanie zmiennej 
                oznaczającej rok do żądania. Nie będzie miał miejsca routing, 
                ponieważ parametry oznaczające kontroler i akcję nie są ustawione.
                Aby było to bardziej użyteczne, musisz zapewnić prawidłową nazwę
                kontrolera i akcji jako domyślne wartości.
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006, 'controller' =&gt; 'archive', 'action' =&gt; 'show')
);</pre>
<p>
				Ta trasa spowoduje uruchomienie akcji showAction kontrolera ArchiveController.
            </p>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-requirements"></a>7.4.3.5. Wymagania zmiennych</h4></div></div></div>
<p>
                Można dodać trzeci parametr do konstruktora 
                <code class="code">Zend_Controller_Router_Route</code> w którym będą 
                ustawione wymagania zmiennych. Są one zdefiniowane jako 
                wyrażenia regularne:
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006), array('year' =&gt; '\d+'))
);</pre>
<div class="note"><table border="0" summary="Note: Zachowanie routera">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Zachowanie routera</th>
</tr>
<tr><td align="left" valign="top"><p>
                    W przeciwieństwie do Ruby on Rails, RewriteRouter z ZF 
                    dopasuje trasę i użyje domyślnej gdy trzeci parametr 
                    zawierający wymagania zmiennych nie zostanie znaleziony. 
                    Więc adres URL 'http://example.com/archive/test' zostanie 
                    dopasowany do powyższej trasy, a rok zostanie ustawiony na 
                    2006. Ta funkcjonalność może w przyszłości się zmienić, 
                    ponieważ w momencie pisania tej dokumentacji ta kwestia jest 
                    jeszcze uzgadniana.
                </p></td></tr>
</table></div>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.rewritebase"></a>7.4.3.6. Bazowy adres URL i podkatalogi</h4></div></div></div>
<p>
                Rewrite router może być użyty w podkatalogach, a bazowy adres 
                URL zostanie automatycznie wykryty przez obiekt 
                <code class="code">Zend_Controller_Request_Http</code>.
            </p>
<p>
                Jeśli bazowy adres URL jest wykrywany nieprawidłowo, możesz
                go nadpisać w obiekcie <code class="code">Zend_Controller_Request_Http</code> 
                wywołując metodę <code class="code">setBaseUrl()</code> (zobacz 
                <a href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http.baseurl" title="7.4.2.3. Bazowy Url oraz podkatalogi">Sekcja 7.4.2.3, „Bazowy Url oraz podkatalogi”</a>).
            </p>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.default-routes"></a>7.4.3.7. Domyślne trasy</h4></div></div></div>
<p>
                Zend_Controller_Router_Rewrite jest skonfigurowany z jedną domyślną
                trasą. Dopasuje on adresy w postaci <code class="code">'controller/action'</code> .
                Dodatkowo, nazwa modułu może być określoa jako pierwszy element
                ścieżki, pozwalając na użycie adresów w postaci
                <code class="code">'module/controller/action</code>. Ostatecznie domyślnie
                dopasuje dodatkowe parametry dołączone do adresu URI.
            </p>
<p>
                Kilka przykładów doopasowania tras:
            </p>
<pre class="programlisting">
// Zakładając poniższe:
// $ctrl-&gt;setControllerDirectory(array(
//     'default' =&gt; '/path/to/default/controllers',
//     'news'    =&gt; '/path/to/blog/controllers',
//     'blog'    =&gt; '/path/to/blog/controllers'
// ));

Tylko moduł:
http://example/news
    module == news

Nieprawidłowy moduł mapuje do nazwy kontrolera:
http://example/foo
    controller == foo

Moduł oraz kontroler:
http://example/blog/archive
    module     == blog
    controller == archive

Moduł, kontroler oraz akcja:
http://example/blog/archive/list
    module     == blog
    controller == archive
    action     == list

Moduł, kontroler, akcja oraz parametry:
http://example/blog/archive/list/sort/alpha/date/desc
    module     == blog
    controller == archive
    action     == list
    sort       == alpha
    date       == desc
</pre>
<p>
                Domyślną trasą jest obiekt
                <code class="code">Zend_Controller_Router_Route_Module</code> utworzony
                bez żadnych domyślnych parametrów:
            </p>
<pre class="programlisting">
// Trasa kompatybilna z pierwszą wersja routera
$compat = new Zend_Controller_Router_Route_Module();
$this-&gt;addRoute('default', $compat);</pre>
<div class="note"><table border="0" summary="Note: Dopasowanie adresów URI">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Notatka]" src="images/note.png"></td>
<th align="left">Dopasowanie adresów URI</th>
</tr>
<tr><td align="left" valign="top"><p>
                    <code class="code">Zend_Controller_Router_Rewrite</code> jest 
                    skonfigurowany z kompatybilnością wsteczną. Automatycznie dopasuje 
                    kontroler i akcję z adresu wraz z dodatkowymi parametrami.
                    Dodatkowe parametry nie wymagają dodawania nowych tras, o ile
                    nie chcemy zdefiniować dla nich domyślnych wartości lub wymagań.
                    Te dodatkowe parametry będą dostępne za pomocą metody
                    <code class="code">Zend_Controller_Action::_getParam()</code>.
                </p></td></tr>
</table></div>
<p>
                Jeśli nie potrzebujesz domyślnych tras w swoim schemacie 
                routingu, możesz je usunąć używając metody <code class="code">removeDefaultRoutes()</code>:
            </p>
<pre class="programlisting">
// Usuwa domyślną trasę
$router-&gt;removeDefaultRoutes();</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.static-routes"></a>7.4.3.8. Trasy statyczne</h4></div></div></div>
<p>
                Wszystkie powyższe przykłady używają dynamicznych tras -- tras,
                które są dopasowywane do szablonów. Czasem jakaś trasa jest 
                niezmienna, a ciągłe sprawdzanie wyrażenia regularnego może
                być zabójcze dla serwera. Rozwiązaniem takiej sytuacji jest 
                użycie statycznych tras:
            </p>
<pre class="programlisting">
$loginRoute = new Zend_Controller_Router_Route_Static('login', array('controller' =&gt; 'login', 'action' =&gt; 'form'));
$router-&gt;addRoute('login', $static);
</pre>
</div>
<div class="sect3" lang="pl">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.add-config"></a>7.4.3.9. Użycie Zend_Config z RewriteRouterem</h4></div></div></div>
<p>
                Czasem wygodniej jest uaktualnić plik konfiguracyjny z nowymi
                trasami niż zmieniać kod. Jest to możliwe za pomocą metody
                <code class="code">addConfig()</code>. Zasadniczo tworzysz konfigurację
                kompatybilną z Zend_Config, a w kodzie odczytujesz ją i 
                przekazujesz ją do RewriteRoutera.
            </p>
<pre class="programlisting">
/**
 * Przykładowy plik INI:
 * routes.archive.route = "archive/:year/*"
 * routes.archive.defaults.controller = archive
 * routes.archive.defaults.action = show
 * routes.archive.defaults.year = 2000
 * routes.archive.reqs.year = "\d+"
 * 
 * routes.news.type = "Zend_Controller_Router_Route_Static"
 * routes.news.route = "news"
 * routes.news.defaults.controller = "news"
 * routes.news.defaults.action = "list"
 */
$config = new Zend_Config_Ini($file);
$router = new Zend_Controller_Router_Rewrite();
$router-&gt;addConfig($config, 'routes');
</pre>
<p>
                W powyższym przykładzie, nakazujemy routerowi użyć sekcji 'routes'
                pliku INI aby użyć tras zdefiniowanych w tym pliku. Każdy element
                pierwszego poziomu w tej sekcji będzie użyty do zdefiiniowania
                nazwy trasy; powyższy przekład definiuje trasy 'archive' oraz 
                'news'. Wymagane jest aby każda trasa miała określony przynajmniej 
                parametr 'route' i jeden lub więcej parametrów 'defaults'; 
                opcjonalnie mogą być zdeiniowane parametry 'reqs' (skrót
                'required'). Wszystkie te parametry odpowiadają trzem argumentom
                przekazywanym do obiektu <code class="code">Zend_Controller_Router_Route_Interface</code> 
                Klucz opcji 'type' może być użyty aby określić typ
                klasy, która ma być użyta dla danej trasy; domyślnie używana jest
                klasa <code class="code">Zend_Controller_Router_Route</code>. W powyższym 
                przykładzie, trasa 'news' jest zdefiniowana aby używała
                <code class="code">Zend_Controller_Router_Route_Static</code>.
            </p>
</div>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.http"></a>7.4.4. Zend_Controller_Response_Http</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Http</code> jest obiektem odpowiedzi
            odpowiednim do użycia w środowisku HTTP. Zawiera metody
            do ustawiania, odbierania i czyszczenia nagłówków, a metoda 
            <code class="code">__toString()</code> wysyła wszystkie nagłówki na raz przed 
            wysłaniem zawartości odpowiedzi.
        </p>
<p>
            Metoda <code class="code">setHeader()</code> przyjmuje dwa argumenty, typ nagłówka
            oraz wartość nagłówka. Trzeci opcjonalny parametr, jeśli jest 
            przekazany i ma wartość true, spowoduje, że nowy nagłówek zastąpi
            inne zarejestrowane nagłówki o tym typie.
        </p>
</div>
<div class="sect2" lang="pl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.cli"></a>7.4.5. Zend_Controller_Response_Cli</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Cli</code> jest obiektem odpowiedzi
            odpowiednim do użycia w środowisku CLI. Nie ma on metod do obsługi
            nagłówków i w prosty sposób zwraca całą zawartość gdy wywoływana jest
            metoda <code class="code">__toString()</code>.
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Poprzedni</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">Początek rozdziału</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.controller.action.html">Następny</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">7.3. Rozszerzanie </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Spis treści</a></td>
<td width="40%" align="right" valign="top"> 7.5. Action Controllers</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
