<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>9.4. Zend_Db_Table</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Programmierer Referenzhandbuch">
<link rel="up" href="zend.db.html" title="Kapitel 9. Zend_Db">
<link rel="prev" href="zend.db.select.html" title="9.3. Zend_Db_Select">
<link rel="next" href="zend.db.tablerow.html" title="9.5. Zend_Db_Table_Row">
<link rel="chapter" href="zend.html" title="Kapitel 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Kapitel 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Kapitel 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Kapitel 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Kapitel 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Kapitel 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Kapitel 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Kapitel 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Kapitel 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Kapitel 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Kapitel 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Kapitel 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Kapitel 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Kapitel 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Kapitel 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Kapitel 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Kapitel 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Kapitel 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Kapitel 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Kapitel 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Kapitel 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Kapitel 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Kapitel 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Kapitel 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Kapitel 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Kapitel 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Kapitel 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Kapitel 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Kapitel 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Anhang A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="Anhang B. Urheberrecht Informationen">
<link rel="index" href="the.index.html" title="Stichwortverzeichnis">
<link rel="subsection" href="zend.db.table.html#zend.db.table.introduction" title="9.4.1. Einführung">
<link rel="subsection" href="zend.db.table.html#zend.db.table.getting-started" title="9.4.2. Erste Schritte">
<link rel="subsection" href="zend.db.table.html#zend.db.table.name-and-key" title="9.4.3. Tabellenname und Primärschlüssel">
<link rel="subsection" href="zend.db.table.html#zend.db.table.insert" title="9.4.4. Zeilen einfügen">
<link rel="subsection" href="zend.db.table.html#zend.db.table.udpate" title="9.4.5. Zeilen aktualisieren">
<link rel="subsection" href="zend.db.table.html#zend.db.table.delete" title="9.4.6. Zeilen löschen">
<link rel="subsection" href="zend.db.table.html#zend.db.table.findbykey" title="9.4.7. Zeilen mit Hilfe des Primärschlüssels finden">
<link rel="subsection" href="zend.db.table.html#zend.db.table.fetchonerow" title="9.4.8. Eine Zeile abrufen">
<link rel="subsection" href="zend.db.table.html#zend.db.table.fetchmultiple" title="9.4.9. Mehrere Zeilen abrufen">
<link rel="subsection" href="zend.db.table.html#zend.db.table.domain-logic" title="9.4.10. Domänenlogik hinzufügen">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">9.4. Zend_Db_Table</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.select.html">Zurück</a> </td>
<th width="60%" align="center">Kapitel 9. Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.tablerow.html">Weiter</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.table"></a>9.4. Zend_Db_Table</h2></div></div></div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.introduction"></a>9.4.1. Einführung</h3></div></div></div>
<p>
            Zend_Db_Table ist ein Tabellenmodul (TableModule) für das Zend Framework. Es verbindet
            sich mit deiner Datenbank über Zend_Db_Adapter, untersucht die Tabelle anhand ihres
            Schemas und unterstützt dich dann beim Verändern und Abrufen von Zeilen aus dieser 
            Tabelle.
        </p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.getting-started"></a>9.4.2. Erste Schritte</h3></div></div></div>
<p>
            Als erstes mußt du die abstrakte Zend_Db_Table Klasse mit einem vorgegebenen Datenbank
            Adapter beschicken; solange du nichts anderes angibst, werden alle Zend_Db_Table
            Instanzen diesen Datenbank Adapter verwenden.
        </p>
<pre class="programlisting">&lt;?php
// Einen Adapter erzeugen
require_once 'Zend/Db.php';
$params = array (
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'malory',
    'password' =&gt; '******',
    'dbname'   =&gt; 'camelot'
);

$db = Zend_Db::factory('PDO_MYSQL', $params);

// Erzeuge einen Standardadapter für alle Zend_Db_Table Objekte
require_once 'Zend/Db/Table.php';
Zend_Db_Table::setDefaultAdapter($db);
?&gt;
        </pre>
<p>
            Als nächstes nehmen wir an, dass du eine Tabelle mit dem Namen 'round_table' in deiner 
            Datenbank hast. Um Zend_Db_Table mit dieser Datenbanktabelle zu verwenden, erweitere
            Zend_Db_Table, um eine neue Klasse mit Namen RoundTable zu erstellen (beachte die
            "CamelCaps"-Schreibweise für den Namen 'round_table'). Dann können wir die 
            'round_table' Tabelle in der Datenbank über diese Klasse untersuchen, Zeilen verändern 
            und Ergebnisse abrufen.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table {}
$table = new RoundTable();
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.name-and-key"></a>9.4.3. Tabellenname und Primärschlüssel</h3></div></div></div>
<p>
            Standardmäßig erwartet Zend_Db_Table, dass der Tabellenname in der Datenbank der selbe 
            ist wie der Klassenname (nachdem er von der "CamelCaps"-Schreibweise in die 
            "unterstrichene_worte"-Schreibweise konvertiert wurde). Daher wird eine Zend_Db_Table
            Klasse mit Namen 'SomeTableName' auf eine SQL Tabelle mit Namen 'some_table_name' 
            abgebildet. Wenn du möchtest, dass deine Klasse auf etwas anderes als die 
            Unterstrichform des Klassennamens abgebildet wird, überschreibe bei der Definition 
            deiner Klasse die $_name Eigenschaft.
        </p>
<pre class="programlisting">&lt;?php
class ClassName extends Zend_Db_Table
{
    // Der standardmäßige Tabellennamen ist 'class_name'
    // aber wir wollen etwas anderes verwenden
    protected $_name = 'another_table_name';
}
?&gt;
        </pre>
<p>
            Standardmäßig erwartet Zend_Db_Table, dass deine Tabelle einen Primärschlüssel mit dem
            Namen 'id' hat (es ist besser, wenn diese Spalte automatisch inkrementiert wird, aber
            dies wird nicht vorausgesetzt). Wenn dein Primärschlüssel anders als 'id' heißt, 
            überschreibe bei der Definition deiner Klasse die $_primary Eigenschaft.
        </p>
<pre class="programlisting">&lt;?php
class ClassName extends Zend_Db_Table
{
    // Der standardmäßige Primärschlüssel ist 'id'
    // aber wir wollen etwas anderes verwenden
    protected $_primary = 'another_column_name';
}
?&gt;
        </pre>
<p>
            Alternativ kannst du dies in der _setup() Methode deiner abgeleiteten Klasse setzen; 
            stelle nur sicher, dass parent::_setup() aufgerufen wird, wenn du fertig bist.
        </p>
<pre class="programlisting">&lt;?php
class ClassName extends Zend_Db_Table
{
    protected function _setup()
    {
        $this-&gt;_name = 'another_table_name';
        $this-&gt;_primary = 'another_column_name';
        parent::_setup();
    }
}
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.insert"></a>9.4.4. Zeilen einfügen</h3></div></div></div>
<p>
            Um eine neue Zeile in deine Tabelle einzufügen, rufe einfach insert() mit einem 
            assoziativen Array mit Spalte:Wert Daten auf. Die Daten werden automatisch für dich in
            Anführungszeichen gesetzt und die zuletzt eingefügte ID wird zurück gegeben (beachte,
            dass sich dies von Zend_Db_Adapter::insert() unterscheidet, wo die Anzahl der 
            betroffenen Zeilen zurück gegeben wird).
        </p>
<pre class="programlisting">&lt;?php
//
// INSERT INTO round_table
//     (noble_title, first_name, favorite_color)
//     VALUES ("King", "Arthur", "blue")
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();

$data = array(
    'noble_title' =&gt; 'King',
    'first_name'  =&gt; 'Arthur',
    'favorite_color' =&gt; 'blue',
)

$id = $table-&gt;insert($data);
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.udpate"></a>9.4.5. Zeilen aktualisieren</h3></div></div></div>
<p>
            Um eine beliebige Anzahl an Zeilen in deiner Tabelle zu aktualisieren, rufe update() mit
            einem assoziativen Array mit Spalte:Wert Daten zusammen mit einer WHERE Klausel auf, um
            anzugeben welche Zeilen aktualisiert werden sollen. Die Tabelle wird aktualisiert 
            und die Anzahl der betroffenen Zeilen zurück gegeben.
        </p>
<p>
            Die zu verändernden Daten werden für dich automatisch in Anführungszeichen gesetzt, 
            aber die WHERE Klausel nicht, weshalb du sie selber mit dem Zend_Db_Adapter Objekt der 
            Tabelle in Anführungszeichen setzen musst.
        </p>
<pre class="programlisting">&lt;?php
//
// UPDATE round_table
//     SET favorite_color = "yellow"
//     WHERE first_name = "Robin"
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

$set = array(
    'favorite_color' =&gt; 'yellow',
)

$where = $db-&gt;quoteInto('first_name = ?', 'Robin');

$rows_affected = $table-&gt;update($set, $where);
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.delete"></a>9.4.6. Zeilen löschen</h3></div></div></div>
<p>
            Um eine beliebige Anzahl an Zeilen aus deiner Tabelle zu löschen, rufe delete() mit 
            einer WHERE Klausel auf, um festzulegen welche Zeilen gelöscht werden sollen.
            Die Anzahl der gelöschten Zeilen wird zurück gegeben.
        </p>
<p>
            Die WHERE Klausel wird nicht für dich in Anführungszeichen gesetzt, weshalb du sie 
            selber mit dem Zend_Db_Adapter Objekt der Tabelle in Anführungszeichen setzen musst.
        </p>
<pre class="programlisting">&lt;?php
//
// DELETE FROM round_table
//     WHERE first_name = "Patsy"
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

$where = $db-&gt;quoteInto('first_name = ?', 'Patsy');

$rows_affected = $table-&gt;delete($where);
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.findbykey"></a>9.4.7. Zeilen mit Hilfe des Primärschlüssels finden</h3></div></div></div>
<p>
            Der Einfachheit halber kannst du Zeilen aus deiner Tabelle leicht, anhand des 
            Primärschlüssels mit der find() Methode, holen. Diese Methode gibt ein Zend_Db_Table_Row
            Objekt zurück, wenn du find() nur für einen Schlüssel verwendest, oder ein 
            Zend_Db_Table_Rowset Objekt, wenn du find() für mehrere Schlüssel verwendest.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();

// SELECT * FROM round_table WHERE id = "1"
$row = $table-&gt;find(1);

// SELECT * FROM round_table WHERE id IN("1", "2", 3")
$rowset = $table-&gt;find(array(1, 2, 3));
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.fetchonerow"></a>9.4.8. Eine Zeile abrufen</h3></div></div></div>
<p>
            Während du eine Zeile einfach mittels find() anhand des Primärschlüssels finden kannst,
            möchtest du öfter auch weitere Bedingungen für das Holen einer Zeile hinzufügen. 
            Zend_Db_Table stellt fetchRow() genau für diesen Zweck bereit. Rufe fetchRow() mit einer
            WHERE Klausel (und einer optionalen ORDER Klausel) auf und Zend_Db_Table wird ein 
            Zend_Db_Table_Row Objekt mit dem ersten Datensatz zurückgeben, der deine Bedingungen
            erfüllt.
        </p>
<p>
            Beachte, dass die WHERE Klausel nicht für dich in Anführungszeichen gesetzt wird, 
            weshalb du sie  selber mit dem Zend_Db_Adapter Objekt der Tabelle in Anführungszeichen 
            setzen musst.
        </p>
<pre class="programlisting">&lt;?php
//
// SELECT * FROM round_table
//     WHERE noble_title = "Sir"
//     AND first_name = "Robin"
//     ORDER BY favorite_color
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

$where = $db-&gt;quoteInto('noble_title = ?', 'Sir')
       . $db-&gt;quoteInto('AND first_name = ?', 'Robin');

$order = 'favorite_color';

$row = $table-&gt;fetchRow($where, $order);
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.fetchmultiple"></a>9.4.9. Mehrere Zeilen abrufen</h3></div></div></div>
<p>
            Wenn du mehr als eine Zeile auf einmal abrufen möchtest, verwende die fetchAll() 
            Methode. Wie fetchRow() nimmt es eine WHERE und eine ORDER Klausel entgegen, aber es
            nimmt zusätzlich auch eine LIMIT Begrenzung für Anzahl und Offset entgegen, um die 
            Anzahl der zurückgegebenen Zeilen zu begrenzen. Es gibt ein Zend_Db_Table_Rowset Objekt
            mit den selektierten Datensätzen zurück.
        </p>
<p>
            Beachte, dass die WHERE Klausel nicht für dich in Anführungszeichen gesetzt wird, 
            weshalb du sie selber mit dem Zend_Db_Adapter Objekt der Tabelle in Anführungszeichen 
            setzen musst.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

// SELECT * FROM round_table
//     WHERE noble_title = "Sir"
//     ORDER BY first_name
//     LIMIT 10 OFFSET 20

$where = $db-&gt;quoteInto('noble_title = ?', 'Sir');
$order = 'first_name';
$count = 10;
$offset = 20;

$rowset = $table-&gt;fetchAll($where, $order, $count, $offset);
?&gt;
        </pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.domain-logic"></a>9.4.10. Domänenlogik hinzufügen</h3></div></div></div>
<p>
            Wie ein Tabellenmodul (TableModule) eignet sich Zend_Db_Table selber dafür, deine 
            eigene besondere Domänenlogik zu kapseln. Du kannst zum Beispiel die insert() und 
            update() Methoden überschreiben, um die übertragenen Daten zu verändern oder zu 
            validieren, bevor sie in die Datenbank übernommen werden.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table
{
    public function insert($data)
    {
        // füge einen Zeitstempel hinzu
        if (empty($data['created_on'])) {
            $data['created_on'] = time();
        }
        return parent::insert($data);
    }

    public function update($data)
    {
        // füge einen Zeitstempel hinzu
        if (empty($data['updated_on'])) {
            $data['updated_on'] = time();
        }
        return parent::update($data);
    }
}
?&gt;
        </pre>
<p>
            Genauso kannst du deine eigene find() Methode hinzufügen, um Datensätze mit etwas 
            anderem als dem Primärschlüssel zu suchen.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table
{
    public function findAllWithName($name)
    {
        $db = $this-&gt;getAdapter();
        $where = $db-&gt;quoteInto("name = ?", $name);
        $order = "first_name";
        return $this-&gt;fetchAll($where, $order);
    }
}
?&gt;
        </pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.select.html">Zurück</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Nach oben</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.tablerow.html">Weiter</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">9.3. Zend_Db_Select </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td>
<td width="40%" align="right" valign="top"> 9.5. Zend_Db_Table_Row</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
