<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>7.4. Bereitgestellte Unterklassen</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Programmierer Referenzhandbuch">
<link rel="up" href="zend.controller.html" title="Kapitel 7. Zend_Controller">
<link rel="prev" href="zend.controller.subclassing.html" title="7.3. Klassen ableiten">
<link rel="next" href="zend.controller.action.html" title="7.5. Action Controllers">
<link rel="chapter" href="zend.html" title="Kapitel 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Kapitel 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Kapitel 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Kapitel 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Kapitel 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Kapitel 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Kapitel 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Kapitel 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Kapitel 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Kapitel 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Kapitel 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Kapitel 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Kapitel 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Kapitel 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Kapitel 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Kapitel 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Kapitel 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Kapitel 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Kapitel 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Kapitel 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Kapitel 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Kapitel 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Kapitel 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Kapitel 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Kapitel 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Kapitel 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Kapitel 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Kapitel 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Kapitel 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Anhang A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="Anhang B. Urheberrecht Informationen">
<link rel="index" href="the.index.html" title="Stichwortverzeichnis">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.introduction" title="7.4.1. Einführung">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http" title="7.4.2. Zend_Controller_Request_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.rewriterouter" title="7.4.3. Zend_Controller_RewriteRouter">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.http" title="7.4.4. Zend_Controller_Response_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.cli" title="7.4.5. Zend_Controller_Response_Cli">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">7.4. Bereitgestellte Unterklassen</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Zurück</a> </td>
<th width="60%" align="center">Kapitel 7. Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.controller.action.html">Weiter</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.providedsubclasses"></a>7.4. Bereitgestellte Unterklassen</h2></div></div></div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.introduction"></a>7.4.1. Einführung</h3></div></div></div>
<p>
            Das Zend Framework stellt verschiedene Alternativen zu den bereit gestellten 
            Standardklassen zur Verfügung. Dies beinhaltet altive Request Objekte, Router und 
            Response Objekte.
        </p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.request.http"></a>7.4.2. Zend_Controller_Request_Http</h3></div></div></div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.introduction"></a>7.4.2.1. Einführung</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> stellt ein Request Objekt für die 
                Verwendung in einer HTTP Umgebung bereit. <code class="code">Zend_Controller_Request_Http</code>
                ist die Standard Request Klasse, die von <code class="code">Zend_Controller_Dispatcher</code>
                verwendet wird.
            </p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.dataaccess"></a>7.4.2.2. Auf Request Daten zugreifen</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> kapselt den Zugriff auf relevante Werte
                wie der Schlüssel und Wert für Controller und Action Variablen des Routers und alle
                zusätzlichen Parameter, die aus der URI ermittelt wurden. Durch den Proxy zu 
                <code class="code">Zend_Controller_Request_Http</code> erlaubt es zusätzlich den Zugriff auf 
                superglobale Werte als öffentliche Eigenschaften und verwaltet die aktuelle Basis 
                URL und Request URI. Superglobale Werte können in einem Request Objekt nicht 
                gesetzt werden, stattdessen verwendet man die setParam/getParam Methoden um 
                Benutzerparameter zu setzen oder zu erhalten.
            </p>
<div class="note"><table border="0" summary="Note: Superglobale Daten">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Superglobale Daten</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Beim Zugriff auf superglobale Daten über die öffentlichen Eigenschaften von 
                    <code class="code">Zend_Controller_Request_Http</code> ist es notwendig, darauf zu achten, 
                    dass der Eigenschaftsname (der superglobale Arrayschlüssel) einem superglobalen
                    Wert in einer bestimmten Reihenfolge entspricht: 1. GET, 2. POST, 3. COOKIE, 
                    4. SERVER, 5. ENV.
                </p></td></tr>
</table></div>
<p>
                Auf spezifische superglobale Werte kann alternativ über eine öffentliche Methode 
                zugegriffen werden. Zum Beispiel kann auf den unverarbeitete Wert von 
                <code class="code">$_POST['user']</code> durch Aufruf der <code class="code">getPost('user')</code> Methode 
                des Request Objekts zugegriffen werden. 
            </p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.baseurl"></a>7.4.2.3. Basis Url und Unterverzeichnisse</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> erlaubt, dass Zend_Controller_RewriteBase 
                in einem Unterverzeichnis verwendet werden kann. Zend_Controller_Request_Http 
                versucht, die Basis URL automatisch zu erkennen und entsprechend zu setzen.
            </p>
<p>
                Wenn man zum Beispiel seine <code class="code">index.php</code> in einem Webserverunterverzeichnis 
                mit Namen <code class="code">/projects/myapp/index.php</code> verwendet, sollte die Basis URL
                (die Rewrite Basis) auf <code class="code">/projects/myapp</code> gesetzt werden. Dieser String
                wird dann vom Anfang des Pfades entfernt, bevor irgend welche Routingtreffer 
                ermittelt werden. Dies befreit einem davon, es an den Anfang jeder Route setzen zu 
                müssen. Eine Route <code class="code">'user/:username'</code> passt auf URIs wie 
                <code class="code">http://localhost/projects/myapp/user/martel</code> und
                <code class="code">http://example.com/user/martel</code>.
            </p>
<div class="note"><table border="0" summary="Note: URL Erkennung beachtet Groß- und Kleinschreibung">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">URL Erkennung beachtet Groß- und Kleinschreibung</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Die automatische Erkennung der Basis URL beachtet die Groß- und Kleinschreibung,
                    weshalb man sicherstellen sollte, dass die URL einem Unterverzeichnis im 
                    Dateisystem entspricht (sogar auf einem Windows Rechner). Andernfalls wird auf 
                    die noRoute aktion umgeleitet.
                </p></td></tr>
</table></div>
<p>
                Sollte die Basis URL falsch erkannt werden, kann man diese auch mit einem eigenen
                Pfad mit Hilfe der <code class="code">setBaseUrl()</code> Methode der 
                <code class="code">Zend_Controller_Request_Http</code> Klasse oder der 
                <code class="code">Zend_Controller_Front</code> Klasse überschreiben. Die einfachste Methode ist 
                die von <code class="code">Zend_Controller_Front</code>, welche es an das Request Object weiter 
                leitet. Beispiel, um eine eigene Basis URL zu setzen:
            </p>
<pre class="programlisting">
/** 
 * Dispatch Request with custom base URL with Zend_Controller_Front.
 */
$router     = new Zend_Controller_RewriteRouter();
$controller = Zend_Controller_Front::getInstance();
$controller-&gt;setControllerDirectory('./application/controllers')
           -&gt;setRouter($router)
           -&gt;setBaseUrl('/projects/myapp'); // set the base url!
$response   = $controller-&gt;dispatch();</pre>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter"></a>7.4.3. Zend_Controller_RewriteRouter</h3></div></div></div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.introduction"></a>7.4.3.1. Einführung</h4></div></div></div>
<p>
        	    <code class="code">Zend_Controller_RewriteRouter</code> ist eine neue Version des Framework 
        	    Routers. Routing ist der Prozess der Übernahme und Zerteilung einer URI, um zu 
        	    ermitteln, welcher Controller und welche Aktion des Controllers die Anfrage 
        	    erhalten soll. Die Definition des Controllers, der Aktion sowie weiterer Parameter 
        	    wird in einem Objekt mit Namen <code class="code">Zend_Controller_Dispatcher_Token</code> 
        	    gekapselt, das dann vom <code class="code">Zend_Controller_Dispatcher</code> verarbeitet wird. 
        	    Das Routing geschieht nur einmal: wenn zu Beginn die Anfrage erhalten wird und 
        	    bevor der erste Controller aufgerufen wird. 
        	</p>
<p>
        	    <code class="code">Zend_Controller_RewriteRouter</code> wurde entwickelt, um mit reinen PHP 
        	    Strukturen eine mod_rewrite ähnliche Funktionalität zu erlauben. Es richtet sich 
        	    sehr frei nach dem Ruby on Rails Routing und benötigt kein tieferes Wissen über 
        	    URL Weiterleitung des Webservers. Es wurde entwickelt, um mit einer einzigen 
        	    mod_rewrite Regel zu arbeiten. 
        	</p>
<pre class="programlisting">
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php</pre>
<p>
            oder:
            </p>
<pre class="programlisting">
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 </pre>
<p>
                Der RewriteRouter kann auch mit dem IIS Webserver verwendet werden, wenn 
                <a href="http://www.isapirewrite.com" target="_top">Isapi_Rewrite</a> als Isapi 
                Erweiterung installiert wurde und folgende Umschreibungsregel verwendet wird:
            </p>
<pre class="programlisting">
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]</pre>
<div class="note"><table border="0" summary="Note: IIS Isapi_Rewrite">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">IIS Isapi_Rewrite</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Bei Verwenung von IIS, wird <code class="code">$_SERVER['REQUEST_URI']</code> entweder nicht
                    vorhanden sein oder auf einen leeren String gesetzt sein. In diesem Fall wird
                    <code class="code">Zend_Controller_Request_Http</code> versuchen, den durch die Isapi_Rewrite 
                    Erweiterung gesetzten Wert <code class="code">$_SERVER['HTTP_X_REWRITE_URL']</code> zu 
                    verwenden.
                </p></td></tr>
</table></div>
<p>Bei der verwendung von Lighttpd, ist folgende Umschreibungsregel gültig:</p>
<pre class="programlisting">
url.rewrite-once = ( ".*\.(js|ico|gif|jpg|png|css)$" =&gt; "$0", "" =&gt; "/index.php")</pre>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.usage"></a>7.4.3.2. Einen Router verwenden</h4></div></div></div>
<p>
        	    Um den RewriteRouter richtig zu verwenden, mußt du ihn instanziieren, einige 
        	    benutzerdefinierte Routen hinzufügen und in den Controller einbinden. Der folgende 
        	    Code veranschaulicht die Vorgehensweise:
            </p>
<pre class="programlisting">
/* Erstelle einen Router */

$router = new Zend_Controller_RewriteRouter();
$router-&gt;addRoute(
	'user',
	new Zend_Controller_Router_Route('user/:username', array('controller' =&gt; 'user', 'action' =&gt; 'info'))
);

/* binde ihn in den Controller ein */

$ctrl = Zend_Controller_Front::getInstance();
$ctrl-&gt;setRouter($router);</pre>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.basic"></a>7.4.3.3. Einfache Routen</h4></div></div></div>
<p>
                Das Herz des RewriteRouter ist die Definition der benutzerdefinierten Routen. 
                Routen werden durch Aufruf der <code class="code">addRoute</code> Methode des RewriteRouter 
                und der Übergabe einer neuen Instanz von <code class="code">Zend_Controller_Router_Route</code>
                erstellt:
            </p>
<pre class="programlisting">
$router-&gt;addRoute('user', new Zend_Controller_Router_Route('user/:username'));</pre>
<p>
                Der erste Parameter ist der Name der Route. Zum derzeitigen Zeitpunkt ist er 
                redundant aber wird in Zukunft in einem URL View Helper verwendet, um eine einfache 
                Erstellung von URLs in deinen Views zu ermöglichen. Wenn du die vorher 
                konfigurierte, benannte Route verwenden möchtest, kannst du sie mit den 
                <code class="code">getRoute</code> Methode des RewriteRouter  erhalten. Der zweite Parameter ist 
                eine Instanz von <code class="code">Zend_Controller_Router_Route</code>.
            </p>
<p>
                The erste Parameter für den <code class="code">Zend_Controller_Router_Route</code> Konstruktur 
                ist eine Route, die auf eine URL passt - zum Beispiel passt die obige Route 
                auf <code class="code">http://example.com/user/martel</code>. Der Doppelpunkt in einer Route 
	            markiert eine URL Variable, die durch die 
	            <code class="code">Zend_Controller_Action::_getParam</code> Methode zugänglich ist. In unserem 
	            Beispiel wird der mit 'username' benannte Parameter auf den Wert 'martel' gesetzt. 
            </p>
<div class="note"><table border="0" summary="Note: Reihenfolge der Definitionen">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Reihenfolge der Definitionen</th>
</tr>
<tr><td align="left" valign="top"><p>
            	    Routen werden in umgekehrter Reihenfolge abgeglichen, so dass man sicherstellen 
            	    muss, dass die allgemeinste Route als erstes definiert ist.
        	    </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note: Erlaubte Zeichen">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Erlaubte Zeichen</th>
</tr>
<tr><td align="left" valign="top"><p>
            	    Fürs Erste erlaubt die aktuelle Implementation die Verwendung jedes Zeichens 
            	    für den  Variablenbezeichner außer den Schrägstrich (/), es wird aber sehr 
            	    empfohlen, dass du nur  Zeichen verwendest, die für PHP Variablen verwendet 
            	    werden dürfen. In Zukunft wird die Implementation vermutlich angepasst und dies 
            	    könnte Fehler in deinen Code einführen.
        	    </p></td></tr>
</table></div>
<p>
        	    Es gibt zwei besondere Variablen, die in deinen Routen verwendet werden können - 
        	    'controller' und 'action'. Diese besonderen Variablen werden verwendet, um einen 
        	    gewählten  Controller und/oder eine Aktion in der URL zu finden. Die 'action' 
        	    Variable muß immer  entweder in der Route oder als Standardparameter definiert 
        	    sein. Die 'controller' Variable wird standardmäßig auf IndexController verweisen, 
        	    wenn sie nicht definiert wurde.
        	</p>
<div class="note"><table border="0" summary="Note: Spezielle Variablen">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Spezielle Variablen</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Die Namen dieser speziellen Variablen können unterschiedlich sein, wenn man 
                    die Standardwerte in <code class="code">Zend_Controller_Request_Http</code> mit Hilfe der 
                    setControllerKey und setActionKey Methoden verändert.
                </p></td></tr>
</table></div>
<pre class="programlisting">
$router-&gt;addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);</pre>
<p>
        	    Wenn du deinen Browser mit dieser Route auf <code class="code">http://example.com/news/latest</code> 
        	    richtest, wird der <code class="code">Zend_Controller_Dispatcher</code> die Aktion latestAction 
        	    deines Controllers NewsController ausführen.
        	</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-defaults"></a>7.4.3.4. Vorgegebene Variablenwerte</h4></div></div></div>
<p>
        	    Jede Variable in der Route kann einen vorgegebenen Wert haben. Um diesen 
        	    vorzugeben, mußt du einen dritten Parameter zur <code class="code">addRoute</code> Methode 
        	    hinzufügen. Dieser dritte Parameter ist ein Array mit den Variablennamen als 
        	    Schlüssel und den vorgegebenen Werten als Werten.
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006))
);</pre>
<p>
        	    Was nicht sofort erkennbar sein mag, ist, dass die obige Route auf URLs wie 
        		<code class="code">http://example.com/archive/2005</code> und 
        		<code class="code">http://example.com/archive</code> passt. Im letzteren Fall hat die Variable 
        		'year' den Wert 2006.
        	</p>
<p>
        	    Im obigen Beispiel haben wir keinen Controller angegeben, so dass immer auf die 
        	    noRoute Aktion des IndexController verwiesen wird. Damit es anwendbar ist, musst du 
        	    einen gültigen Controller und eine gültige Aktion als Standardwerte festlegen:
        	</p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006, 'controller' =&gt; 'archive', 'action' =&gt; 'show')
);</pre>
<p>
				This route will then result in dispatching to showAction of ArchiveController.
            </p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-requirements"></a>7.4.3.5. Anforderungen an Variablen</h4></div></div></div>
<p>
                Du kannst einen dritten Parameter hinzufügen, in dem Anforderungen an die Variablen 
        	    angegeben werden können. Diese werden als reguläre Ausdrücke definiert:
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006), array('year' =&gt; '\d+'))
);</pre>
<div class="note"><table border="0" summary="Note: Routing Verhalten">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Routing Verhalten</th>
</tr>
<tr><td align="left" valign="top"><p>
        	        Im Gegensatz zu Ruby on Rails wird <code class="code">Zend_Controller_RewriteRouter</code> 
        	        für eine Route Standardwerte verwenden, wenn die Anforderungen an die Variablen 
        	        im vierten Parameter nicht erfüllt werden. Also passt die URL 
        	        <code class="code">http://example.com/archive/test</code> auf die obige Route und setzt den 
        	        Parameter 'year' auf 2006. Diese Funktionalität kann sich in Zukunft ändern, da 
        	        sie im Moment beim Schreiben dieser Dokumentation noch diskutiert wird.
        	    </p></td></tr>
</table></div>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.rewritebase"></a>7.4.3.6. Basis URL und Unterverzeichnisse</h4></div></div></div>
<p>
                Im Gegensatz zum ursprünglichen Route kann RewriteRouter auch in 
                Unterverzeichnissen verwendet werden. Die Methode setRewriteBase() des 
                ursprünglichen RewriteRouter existiert nicht mehr. Stattdessen wird die Basis URL
                automatisch durch Zend_Controller_Request_Http ermittelt.
            </p>
<p>
                Sollte die Basis URL falsch erkannt werden, kannst du sie mit deinem eigenen Pfad 
                mit Hilfe von Zend_Controller_Request_Http durch den Aufruf der setBaseUrl() Methode setzen 
                (siehe <a href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http.baseurl" title="7.4.2.3. Basis Url und Unterverzeichnisse">Abschnitt 7.4.2.3, „Basis Url und Unterverzeichnisse“</a>).
            </p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.default-routes"></a>7.4.3.7. Standardrouten</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_RewriteRouter</code> hat eine vordefinierte Standardroute, um 
                Kompatibilität mit der ersten Version des Routers zu gewährleisten. Sie
        	    passt auf URIs in Form von <code class="code">'controller/action'</code> and erkennt außerdem 
        	    jeden zusätzlichen Parameter, der an die URI angehängt wird. Sie ist wie folgt
        	    konfiguiert:
            </p>
<pre class="programlisting">
// Route for Router v1 compatibility
$compat = new Zend_Controller_Router_Route(':controller/:action/*', array('controller' =&gt; 'index', 'action' =&gt; 'index'));
$this-&gt;addRoute('default', $compat);</pre>
<div class="note"><table border="0" summary="Note: URIs abbilden">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">URIs abbilden</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Zend_Controller_RewriteRouter wurde für Rückwärtskompatibilität konfiguriert. 
                    Es passt automatisch auf <code class="code">controller/action</code> URIs mit zusätzlichen
                    Parameter. Die zusätzlichen Parameter benötigen keine weiteren Routen, solange
                    sie keine vorgegebenen Variablenwerte oder Variablenanforderungen benötigen.
                    Auf diese zusätzlichen Parameter kann über die Zend_Controller_Action::_getParam()
                    Methode zugegriffen werden.
                </p></td></tr>
</table></div>
<p>
            	Wenn man die Standardroute nicht in seinem Routing Schema haben möchte, kann diese
            	mit Hilfe von <code class="code">removeDefaultRoutes()</code> entfernt werden:
            </p>
<pre class="programlisting">
// Entferne Standardroute
$router-&gt;removeDefaultRoutes();</pre>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.static-routes"></a>7.4.3.8. Statische Routen</h4></div></div></div>
<p>
            	Die obigen Beispiele verwenden alle dynamische Routen - Routen die zu prüfende 
            	Muster verwenden. Manchmal ist eine bestimmte Route jedoch fest verankert und die
            	Verwendung regulärer Ausdrücke wäre zuviel des Guten. Die Antwort auf solche 
            	Situationen ist die Verwendung von statischen Routen:
            </p>
<pre class="programlisting">
$loginRoute = new Zend_Controller_Router_StaticRoute('login', array('controller' =&gt; 'login', 'action' =&gt; 'form'));
$router-&gt;addRoute('login', $static);
</pre>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.add-config"></a>7.4.3.9. Zend_Config mit dem RewriteRouter verwenden</h4></div></div></div>
<p>
            	Manchmal ist es praktischer, eine Konfigurationsdatei mit neuen Routen zu 
            	aktualisieren, als den Code zu ändern. Dies ist mit Hilfe der 
            	<code class="code">addConfig()</code> Methode möglich. Im Wesentlichen kann man eine 
            	Zend_Config kompatible Konfiguration erstellen, in seinem Code einlesen und an den
            	RewriteRouter übergeben:
            </p>
<pre class="programlisting">
/**
 * Beispiel INI:
 * routes.archive.route = "archive/:year/*"
 * routes.archive.defaults.controller = archive
 * routes.archive.defaults.action = show
 * routes.archive.defaults.year = 2000
 * routes.archive.reqs.year = "\d+"
 * 
 * routes.news.type = "Zend_Controller_Router_StaticRoute"
 * routes.news.route = "news"
 * routes.news.defaults.controller = "news"
 * routes.news.defaults.action = "list"
 */
$config = new Zend_Config_Ini($file);
$router = new Zend_Controller_RewriteRouter();
$router-&gt;addConfig($config, 'routes');
</pre>
<p>
            	Im oberen Beispiel teilen wir dem Router mit, den 'routes' Bereich der INI Datei
            	für seine Routen zu verwenden. Jeder Schlüssel auf erster Ebene in diesem Bereich
            	wird verwendet, um den Namen der Routen zu definieren; das obige Beispiel definiert
            	die Routen 'archive' und 'news'. Jede Route erfordert dann mindestens einen 'route'
            	Eintrag und einen oder mehrere 'defaults' Einträge; optional können eine oder 
            	mehrere 'reqs' (kurz für 'required', d.h. erforderlich) Einträge angegeben werden.
            	Alles in allem entspricht dies den drei Argumenten, die an ein 
            	<code class="code">Zend_Controller_Router_Route_Interface</code> Objekt übergeben werden. Ein
            	Optionsschlüssel 'type' kann verwendet werden, um den Typ der Routenklasse für 
            	diese Route anzugeben; standardmäßig wird <code class="code">Zend_Controller_Router_Route</code>
            	verwendet. Im obigen Beispiel wird die 'news' Route definiert, um
            	<code class="code">Zend_Controller_Router_StaticRoute</code> zu verwenden.
            </p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.modules"></a>7.4.3.10. RewriteRouter mit modularen MVC Komponenten verwenden</h4></div></div></div>
<p>
                Ein RewriteRouter, der Module unterstützt, ist ebenfalls verfügbar: 
                Zend_Controller_ModuleRewriteRouter. Er arbeitet genauso wie 
                Zend_Controller_RewriteRouter, aber hat als Standardroute den Pfad
                ':module/:controller/:action/*'.
            </p>
<p>
                Für weitere Informationen siehe die 
                <a href="zend.controller.modular.html" title="7.7. Using a Conventional Modular Directory Structure">Abschnitt 7.7, „Using a Conventional Modular Directory Structure“</a>. 
            </p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.http"></a>7.4.4. Zend_Controller_Response_Http</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Http</code> ist ein Response Objekt, das für die 
            Verwendung in einer HTTP Umgebung geeignet ist. Es enthält Methoden für das Setzen,
            Erhalten und Entfernen von Headern und die <code class="code">__toString()</code> Methode sendet
            alle Header auf einmal bevor die Reponse Inhalte zurückgegeben werden.
        </p>
<p>
            <code class="code">setHeader()</code> nimmt zwei Argumente entgegen, einen Header Typ und den 
            Header Wert. Ein dritter, optionaler Parameter (wenn übergeben und true) erzwingt das 
            Überschreiben des vorhandenen Headers gleichen Typs mit dem neuen Header.
        </p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.cli"></a>7.4.5. Zend_Controller_Response_Cli</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Cli</code> is ein Response Object, das für die
            Verwendung in einer CLI Umgebung geeignet ist. Es hat keine Methoden für die Behandlung
            von Headern und gibt nur alle Inhalte zurück, wenn <code class="code">__toString()</code> 
            aufgerufen wird.
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Zurück</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">Nach oben</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.controller.action.html">Weiter</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">7.3. Klassen ableiten </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td>
<td width="40%" align="right" valign="top"> 7.5. Action Controllers</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
