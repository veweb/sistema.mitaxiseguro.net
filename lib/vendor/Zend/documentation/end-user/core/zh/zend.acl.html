<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>第 2 章 Zend_Acl</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="index.html" title="Zend Framework手册 中文版">
<link rel="prev" href="zend.initregistry.html" title="1.9. Zend::initRegistry($registry = 'Zend_Registry')">
<link rel="next" href="zend.acl.refining.html" title="2.2. 精细的访问控制">
<link rel="chapter" href="zend.html" title="第 1 章 Zend">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="第 3 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 4 章 Zend_Cache">
<link rel="chapter" href="zend.config.html" title="第 5 章 Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="第 6 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 7 章 Zend_Controller">
<link rel="chapter" href="zend.date.html" title="第 8 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 9 章 Zend_Db">
<link rel="chapter" href="zend.feed.html" title="第 10 章 Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="第 11 章 Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="第 12 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 13 章 Zend_Http">
<link rel="chapter" href="zend.json.html" title="第 14 章 Zend_Json">
<link rel="chapter" href="zend.locale.html" title="第 15 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 16 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 17 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 18 章 Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="第 19 章 Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="第 20 章 Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="第 21 章 Zend_Rest">
<link rel="chapter" href="zend.search.html" title="第 22 章 Zend_Search">
<link rel="chapter" href="zend.server.html" title="第 23 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 24 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 25 章 Zend_Session">
<link rel="chapter" href="zend.uri.html" title="第 26 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 27 章 Zend_Validate">
<link rel="chapter" href="zend.view.html" title="第 28 章 Zend_View">
<link rel="chapter" href="zend.validate.html" title="第 29 章 Zend_Validate">
<link rel="chapter" href="zend.xmlrpc.html" title="第 30 章 Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="附录 A. Zend Framework PHP Coding Standard">
<link rel="appendix" href="copyrights.html" title="附录 B. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="section" href="zend.acl.html#zend.acl.introduction" title="2.1. 简介">
<link rel="section" href="zend.acl.refining.html" title="2.2. 精细的访问控制">
<link rel="section" href="zend.acl.advanced.html" title="2.3. 高级用法">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">第 2 章 Zend_Acl</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.initregistry.html">上一页</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="zend.acl.refining.html">下一页</a>
</td>
</tr>
</table></div>
<div class="chapter" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title">
<a name="zend.acl"></a>第 2 章 Zend_Acl</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="zend.acl.html#zend.acl.introduction">2.1. 简介</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.acl.html#zend.acl.introduction.resources">2.1.1. 关于资源(Resource)</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.html#zend.acl.introduction.roles">2.1.2. 关于角色(Role)</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.html#zend.acl.introduction.creating">2.1.3. 创建访问控制列表(ACL)</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.html#zend.acl.introduction.role_registry">2.1.4. 注册角色(Role)</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.html#zend.acl.introduction.defining">2.1.5. 定义访问控制</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.html#zend.acl.introduction.querying">2.1.6. 查询 ACL</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.acl.refining.html">2.2. 精细的访问控制</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.acl.refining.html#zend.acl.refining.precise">2.2.1. 精细的访问控制</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.refining.html#zend.acl.refining.removing">2.2.2. 除去访问控制</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.acl.advanced.html">2.3. 高级用法</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.acl.advanced.html#zend.acl.advanced.storing">2.3.1. 保存 ACL 数据确保持久性</a></span></dt>
<dt><span class="sect2"><a href="zend.acl.advanced.html#zend.acl.advanced.assertions">2.3.2. 使用声明(Assert)来编写条件性的 ACL 规则</a></span></dt>
</dl></dd>
</dl>
</div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.acl.introduction"></a>2.1. 简介</h2></div></div></div>
<p>
        Zend_Acl 提供轻量并灵活的访问控制列表 (ACL,access control list) 功能和权限管理。一般地，应用软件可以利用这样的功能限制某些特定对象来访问特定保护的对象。
    </p>
<p>
        在本文档中，
 
         </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <span class="strong"><strong>Resource</strong></span> （资源）是一个限制访问的对象。
                </p></li>
<li><p>
                    <span class="strong"><strong>Role</strong></span> （角色）是一个可以发出请求去访问Resource的对象。
                </p></li>
</ul></div>
<p>

        简单地说就是：<span class="strong"><strong>Roles 请求访问 Resources</strong></span>。例如，如果一个人要用汽车，这样，这个人就是发出请求的 Role，而这辆汽车就是 Resource，所以使用这辆车就在控制之中了。
    </p>
<p>
         通过规范和访问控制列表（ACL）的使用，应用软件可以控制如何授权给发出请求的对象（Roles）来访问被保护的对象（Resources）。
    </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.acl.introduction.resources"></a>2.1.1. 关于资源(Resource)</h3></div></div></div>
<p>
            在 Zend_Acl 中，创建建一个 Resource 非常简单。Zend_Acl 提供了<code class="code">Zend_Acl_Resource_Interface</code> 使开发者创建 Resources 非常容易。为了使Zend_Acl把某个对象当作一个Resource，一个类只需要实现这个只包含了一个方法 <code class="code">getResourceId()</code> 的接口。 另外，<code class="code">Zend_Acl_Resource</code>是一个包含在 Zend_Acl 里作为一个基本的 Resource 实现的类，开发者可以任意扩展它。
        </p>
<p>
            Zend_Acl 提供了一个树结构，它可以添加多个 Resources (或者叫“访问控制下的区域”）。因为 Resources 被存储在这样一个树结构，所以它们可以被组织成从一般（树根）到特殊（树叶）。基于特殊Resource的查询将自动从Resource的等级结构中搜索分配给祖先Resources的规则，它允许简单的规则继承。例如，要把一个缺省的规则应用到一个城市的每个建筑物，就简单地把这个规则分配给这个城市，而不是把规则分配给每个建筑物。然而，有些建筑物也许要求例外的规则，在Zend_Acl里，很容易地通过分配例外规则给每个有这样要求的建筑物来实现。一个 Resource 可以从唯一的一个父 Resource 继承，而这个父 Resource 也有它自己的父 Resource，等等。
         </p>
<p>
            Zend_Acl 也支持基于 Resources 的权限（例如："create", "read", "update", "delete"）， 开发者可以根据 Resource 分配影响全部或者特殊权限的规则。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.acl.introduction.roles"></a>2.1.2. 关于角色(Role)</h3></div></div></div>
<p>
            象 Resources 一样，创建一个 Role 也非常简单。 Zend_Acl 提供了 <code class="code">Zend_Acl_Role_Interface</code> 使开发者创建 Roles 非常容易。为了使Zend_Acl把某个对象当作一个 Role，一个类只需要实现这个只包含了一个方法 <code class="code">getRoleId()</code> 的接口。 另外，<code class="code">Zend_Acl_Role</code>是一个包含在Zend_Acl里作为一个基本的 Role 实现的类，开发者可以任意扩展它。
        </p>
<p>
            在 Zend_Acl, 一个 Role 可以从一个或多个 Role 继承，这就是在 Role 中支持规则的继承。例如，一个用户 Role，如 “sally”，可以属于一个或多个 Role，如：“editor”和“administrator”。开发者可以分别给“editor”和“administrator”分配规则，而“sally”将从它们俩继承规则，不需要直接给“sally”分配规则。  
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                因为 Zend_Acl 支持从多个 Role 继承规则，它们彼此间可能会有冲突，有必要很清楚地解决这些冲突。Zend_Acl 通过把最近继承的 Role 作为最高优先级来解决潜在的冲突。换句话说，从最近继承的 Role 开始，一旦发现一个 “parent” Role 的规则，其它的规则将不被考虑，因为最高优先级的规则已经找到。 
             </p></td></tr>
</table></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.acl.introduction.creating"></a>2.1.3. 创建访问控制列表(ACL)</h3></div></div></div>
<p>
           ACL 可以表示任何一组物理或虚拟对象，然而，作为示范，我们将创建一个基本的内容管理系统的 ACL，在一个范围很宽的多样化区域里，它将维护若干个等级的组。为创建一个新的 ACL 对象，我们不带参数地实例化这个 ACL.
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Acl.php';

$acl = new Zend_Acl();</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
               缺省地，Zend_Acl是一个“白名单”实现，这就意味着除非开发者指定，Zend_Acl 禁止任何 Role 对任何 Resource 的任何访问权限。
            </p></td></tr>
</table></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.acl.introduction.role_registry"></a>2.1.4. 注册角色(Role)</h3></div></div></div>
<p>
            内容管理系统总是几乎需要一个等级结构的许可来决定它的用户的授权能力。作为示范，“Guest”组允许有限的访问，“Staff”适合大多数的执行日常操作的CMS用户，“Editor”组适合于发布、复核、存档和删除内容，最后“Administrator”组的任务包括所有其它组的内容并包括敏感的信息、用户管理、后台配置数据和备份/导出。这组许可可以被表示为一个 Role 注册表，允许每个组从“”组继承权限，也可以为单一的组提供独特的权限。这些许可可以表示如下：
         </p>
<div class="table">
<a name="id4732591"></a><p class="title"><b>表 2.1. 一个CMS范例的访问控制</b></p>
<table summary="一个CMS范例的访问控制" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>名称</th>
<th>独特的许可</th>
<th>从...继承的许可</th>
</tr></thead>
<tbody>
<tr>
<td>Guest</td>
<td>View</td>
<td>N/A</td>
</tr>
<tr>
<td>Staff</td>
<td>Edit, Submit, Revise</td>
<td>Guest</td>
</tr>
<tr>
<td>Editor</td>
<td>Publish, Archive, Delete</td>
<td>Staff</td>
</tr>
<tr>
<td>Administrator</td>
<td>(Granted all access)</td>
<td>N/A</td>
</tr>
</tbody>
</table>
</div>
<p>
            对于这个范例，<code class="code">Zend_Acl_Role</code>  被使用，但任何实现 <code class="code">Zend_Acl_Role_Interface</code>  的对象是可接受的。这些组可以被添加到 Role 注册表如下：
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Acl.php';

$acl = new Zend_Acl();

// 用 Zend_Acl_Role 把组添加到 Role 注册表 
require_once 'Zend/Acl/Role.php';

// Guest 不继承访问控制
$roleGuest = new Zend_Acl_Role('guest');
$acl-&gt;addRole($roleGuest);

// Staff 从 guest 继承
$acl-&gt;addRole(new Zend_Acl_Role('staff'), $roleGuest);

/* 另外, 上面的也可这样来写：
$roleGuest = $acl-&gt;addRole(new Zend_Acl_Role('staff'), 'guest');
//*/

// Editor 从 staff 继承
$acl-&gt;addRole(new Zend_Acl_Role('editor'), 'staff');

// Administrator 不继承访问控制
$acl-&gt;addRole(new Zend_Acl_Role('administrator'));</pre>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.acl.introduction.defining"></a>2.1.5. 定义访问控制</h3></div></div></div>
<p>
           现在 ACL 包含了相关的 Roles，可以建立规则来定义 Roles 如何访问 Resources。你也许注意到我们在这个范例里没有定义任何特定的 Resources， 这简单地表示这些规则适用于所有 Resources。Zend_Acl 提供一个实现，籍此，规则只需要被分配从一般到特殊，最小化规则的需求，因为 Resources 和 Roles 继承由它们祖先定义的规则。
        </p>
<p>
           因此，我们可以用最少量的代码来定义适度复杂的规则。应用上面定义的基本许可：
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Acl.php';

$acl = new Zend_Acl();

require_once 'Zend/Acl/Role.php';

$roleGuest = new Zend_Acl_Role('guest');
$acl-&gt;addRole($roleGuest);
$acl-&gt;addRole(new Zend_Acl_Role('staff'), $roleGuest);
$acl-&gt;addRole(new Zend_Acl_Role('editor'), 'staff');
$acl-&gt;addRole(new Zend_Acl_Role('administrator'));

// Guest 只可以浏览内容
$acl-&gt;allow($roleGuest, null, 'view');

/* 另外, 上面也可写为：
$acl-&gt;allow('guest', null, 'view');
//*/

// Staff 从 guest 继承浏览权限，但也要另外的权限
$acl-&gt;allow('staff', null, array('edit', 'submit', 'revise'));

// Editor 从 Staff 继承 view, edit, submit 和 revise 权限
// 但也要另外的权限
$acl-&gt;allow('editor', null, array('publish', 'archive', 'delete'));

// Administrator 不需要继承任何权限，它拥有所有的权限
$acl-&gt;allow('administrator');</pre>
<p>
                
          在上面 <code class="code">allow()</code> 中调用中 <code class="code">null</code> 的值用来表明 allow 规则适用于所有的 Resources。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.acl.introduction.querying"></a>2.1.6. 查询 ACL</h3></div></div></div>
<p>
           我们现在有一个灵活的 ACL 可以用来决定请求者在整个 web 应用里是否拥有执行功能的许可。用<code class="code">isAllowed()</code>方法来执行查询相当简单：
        </p>
<pre class="programlisting">&lt;?php
echo $acl-&gt;isAllowed('guest', null, 'view') ?
     "allowed" : "denied"; // 允许

echo $acl-&gt;isAllowed('staff', null, 'publish') ?
     "allowed" : "denied"; // 禁止

echo $acl-&gt;isAllowed('staff', null, 'revise') ?
     "allowed" : "denied"; // 允许

echo $acl-&gt;isAllowed('editor', null, 'view') ?
     "allowed" : "denied"; // 允许，因为从 guest 继承而来

echo $acl-&gt;isAllowed('editor', null, 'update') ?
     "allowed" : "denied"; // 禁止，因为对于 'update' 没有 allow 规则

echo $acl-&gt;isAllowed('administrator', null, 'view') ?
     "allowed" : "denied"; // 允许，因为 administrator 有所有权限

echo $acl-&gt;isAllowed('administrator') ?
     "allowed" : "denied"; // 允许，因为 administrator 有所有权限

echo $acl-&gt;isAllowed('administrator', null, 'update') ?
     "allowed" : "denied"; // 允许，因为 administrator 有所有权限</pre>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.initregistry.html">上一页</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="zend.acl.refining.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">1.9. Zend::initRegistry($registry = 'Zend_Registry') </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 2.2. 精细的访问控制</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
