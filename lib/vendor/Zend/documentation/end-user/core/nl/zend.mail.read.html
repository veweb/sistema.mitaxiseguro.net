<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>17.14. Reading Mail Messages</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Referentiegids voor de programmeur">
<link rel="up" href="zend.mail.html" title="Hoofdstuk 17. Zend_Mail">
<link rel="prev" href="zend.mail.smtp-secure.html" title="17.13. Securing SMTP Transport">
<link rel="next" href="zend.measure.html" title="Hoofdstuk 18. Zend_Measure">
<link rel="chapter" href="zend.html" title="Hoofdstuk 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Hoofdstuk 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Hoofdstuk 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Hoofdstuk 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Hoofdstuk 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Hoofdstuk 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Hoofdstuk 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Hoofdstuk 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Hoofdstuk 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Hoofdstuk 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Hoofdstuk 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Hoofdstuk 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Hoofdstuk 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Hoofdstuk 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Hoofdstuk 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Hoofdstuk 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Hoofdstuk 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Hoofdstuk 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Hoofdstuk 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Hoofdstuk 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Hoofdstuk 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Hoofdstuk 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Hoofdstuk 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Hoofdstuk 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Hoofdstuk 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Hoofdstuk 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Hoofdstuk 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Hoofdstuk 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Hoofdstuk 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Bijlage A. Zend Framework Programmeer Standaard">
<link rel="appendix" href="copyrights.html" title="Bijlage B. Auteursrechtinformatie">
<link rel="index" href="the.index.html" title="Register">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-example" title="17.14.1. Simple example using Pop3">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-open-local" title="17.14.2. Opening a local storage">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-open-remote" title="17.14.3. Opening a remote storage">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-fetching" title="17.14.4. Fetching messages and simple methods">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-message" title="17.14.5. Working with messages">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-folders" title="17.14.6. Using folders">
<link rel="subsection" href="zend.mail.read.html#zend.mail.read-advanced" title="17.14.7. Advanced Use">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">17.14. Reading Mail Messages</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.mail.smtp-secure.html">Terug</a> </td>
<th width="60%" align="center">Hoofdstuk 17. Zend_Mail</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.measure.html">Volgende</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="nl">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.mail.read"></a>17.14. Reading Mail Messages</h2></div></div></div>
<p>
        <code class="code">Zend_Mail</code> can read mail messages from several local or remote mail storages. All of them have the
        same basic API to count and fetch messages and some of them implement additional interfaces for not so common
        features. For a feature overview of the implemented storages see the following table.
    </p>
<div class="table">
<a name="id4844882"></a><p class="title"><b>Tabel 17.1. Mail Read Feature Overview</b></p>
<table summary="Mail Read Feature Overview" border="1">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Feature</th>
<th>Mbox</th>
<th>Maildir</th>
<th>Pop3</th>
<th>IMAP</th>
</tr></thead>
<tbody>
<tr>
<td>Storage type</td>
<td>local</td>
<td>local</td>
<td>remote</td>
<td>remote</td>
</tr>
<tr>
<td>Fetch message</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fetch mime-part</td>
<td>emulated</td>
<td>emulated</td>
<td>emulated</td>
<td>emulated</td>
</tr>
<tr>
<td>Folders</td>
<td>Yes </td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Create message/folder</td>
<td>No</td>
<td>todo</td>
<td>No</td>
<td>todo</td>
</tr>
<tr>
<td>Flags</td>
<td>No</td>
<td>todo</td>
<td>No</td>
<td>todo</td>
</tr>
</tbody>
</table>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-example"></a>17.14.1. Simple example using Pop3</h3></div></div></div>
<pre class="programlisting">&lt;?php
$mail = new Zend_Mail_Storage_Pop3(array('host'     =&gt; 'localhost',
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test'));

echo $mail-&gt;countMessages() . " messages found\n";
foreach ($mail as $message) {
    echo "Mail from '{$message-&gt;from}': {$message-&gt;subject}\n";
}
</pre>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-open-local"></a>17.14.2. Opening a local storage</h3></div></div></div>
<p>
            Mbox and Maildir are the two supported formats for local mail storages, both in their most simple formats.
        </p>
<p>
            If you want to read from a Mbox file you only need to give the filename to the constructor of
            <code class="code">Zend_Mail_Storage_Mbox</code>:
        </p>
<pre class="programlisting">&lt;?php
$mail = new Zend_Mail_Storage_Mbox(array('filename' =&gt; '/home/test/mail/inbox'));
</pre>
<p>Maildir is very similar but needs a dirname:</p>
<pre class="programlisting">&lt;?php
$mail = new Zend_Mail_Storage_Maildir(array('dirname' =&gt; '/home/test/mail/'));
</pre>
<p>Both constructors throw a <code class="code">Zend_Mail_Exception</code> if the storage can't be read.</p>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-open-remote"></a>17.14.3. Opening a remote storage</h3></div></div></div>
<p>
            For remote storages the two most popular protocols are supported: Pop3 and Imap. Both need at least a host
            and a user to connect and login. The default password is an empty string, the default port as given in the
            protocol RFC.
        </p>
<pre class="programlisting">&lt;?php
// connecting with Pop3
$mail = new Zend_Mail_Storage_Pop3(array('host'     =&gt; 'example.com'
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test'));

// connecting with Imap
$mail = new Zend_Mail_Storage_Imap(array('host'     =&gt; 'example.com'
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test'));

// example for a none standard port
$mail = new Zend_Mail_Storage_Pop3(array('host'     =&gt; 'example.com',
                                         'port'     =&gt; 1120
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test'));
</pre>
<p>
            For both storages SSL and TLS are supported. If you use SSL the default port changes as given in the RFC.
        </p>
<pre class="programlisting">&lt;?php
// examples for Zend_Mail_Storage_Pop3, same works for Zend_Mail_Storage_Imap

// use SSL on different port (default is 995 for Pop3 and 993 for Imap)
$mail = new Zend_Mail_Storage_Pop3(array('host'     =&gt; 'example.com'
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test',
                                         'ssl'      =&gt; 'SSL'));

// use TLS
$mail = new Zend_Mail_Storage_Pop3(array('host'     =&gt; 'example.com'
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test',
                                         'ssl'      =&gt; 'TLS'));
</pre>
<p>
            Both constructors can throw <code class="code">Zend_Mail_Exception</code> or <code class="code">Zend_Mail_Protocol_Exception</code>
            (extends <code class="code">Zend_Mail_Exception</code>), depending on the type of error.
        </p>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-fetching"></a>17.14.4. Fetching messages and simple methods</h3></div></div></div>
<p>
            Once you've opened the storage messages can be fetched. You need the message number, which is a counter
            starting with 1 for the first message. To fetch the message you use the method <code class="code">getMessage()</code>:
        </p>
<pre class="programlisting">&lt;?php
$message = $mail-&gt;getMessage($messageNum);
</pre>
<p>
            Array access is also supported, but won't supported any additional parameters that could be added to
            <code class="code">getMessage()</code>. As long as you don't mind and can live with defaults you may use:
        </p>
<pre class="programlisting">&lt;?php
$message = $mail[$messageNum];
</pre>
<p>For iterating over all messages the Iterator interface is implemented:</p>
<pre class="programlisting">&lt;?php
foreach ($mail as $messageNum =&gt; $message) {
    // do stuff ...
}
</pre>
<p>
            To count the messages in the storage you can either use the method <code class="code">countMessages()</code> or use array
            access:
        </p>
<pre class="programlisting">&lt;?php
// method
$maxMessage = $mail-&gt;countMessages();

// array access
$maxMessage = count($mail);
</pre>
<p>To remove a mail you use the method <code class="code">removeMessage()</code> or again array access:</p>
<pre class="programlisting">&lt;?php
// method
$mail-&gt;removeMessage($messageNum);

// array access
unset($mail[$messageNum]);
</pre>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-message"></a>17.14.5. Working with messages</h3></div></div></div>
<p>After you fetched the messages with <code class="code">getMessage()</code> you want to fetch headers, the content
        or single parts of a multipart message. All headers can be accessed via properties or the method
        <code class="code">getHeader()</code> if you want more control or have unusual header names. The header names are
        lower-cased internally, thus the case of the header name in the mail message doesn't matter. Also headers
        with a dash can be written in camel-case.</p>
<pre class="programlisting">&lt;?php
// get the message object
$message = $mail-&gt;getMessage(1);

// output subject of message
echo $message-&gt;subject . "\n";

// get content-type header
$type = $message-&gt;contentType;
</pre>
<p>If you have multiple headers with the same name i.e. the Received headers you might want it as array
        instead of a string, which is possible with the <code class="code">getHeader()</code> method.</p>
<pre class="programlisting">&lt;?php
// get header as property - the result is always a string, with new lines between the single occurrences in the message
$received = $message-&gt;received;

// the same via getHeader() method
$received = $message-&gt;getHeader('received', 'string');

// better an array with a single entry for every occurrences
$received = $message-&gt;getHeader('received', 'array');
foreach ($received as $line) {
    // do stuff
}

// if you don't define a format you'll get the internal representation (string for single headers, array for multiple)
$received = $message-&gt;getHeader('received');
if (is_string($received)) {
    // only one received header found in message
}
</pre>
<p>The method <code class="code">getHeaders()</code> returns all headers as array with the lower-cased name as
        key and the value as array for multiple headers or as string for single headers.</p>
<pre class="programlisting">&lt;?php
// dump all headers
foreach ($message-&gt;getHeaders as $name =&gt; $value) {
    if (is_string($value)) {
        echo "$name: $value\n";
        continue;
    }
    foreach ($value as $entry) {
        echo "$name: $entry\n";
    }
}
</pre>
<p>If you don't have a multipart message fetching the content is easy done via
        <code class="code">getContent()</code>. Unlike the headers the content is only fetched when needed (aka late-fetch).</p>
<pre class="programlisting">&lt;?php
// output message content for HTML
echo '&lt;pre&gt;';
echo $message-&gt;getContent();
echo '&lt;/pre&gt;';
</pre>
<p>Checking for a multipart message is done with the method <code class="code">isMultipart()</code>. If you have
        multipart message you can get an instance of <code class="code">Zend_Mail_Part</code> with the method
        <code class="code">getPart()</code>. <code class="code">Zend_Mail_Part</code> is the base class of <code class="code">Zend_Mail_Message</code>,
        so you have the same methods: <code class="code">getHeader()</code>, <code class="code">getHeaders()</code>, <code class="code">getContent()</code>,
        <code class="code">getPart()</code>, <code class="code">isMultipart</code> and the properties for headers.</p>
<pre class="programlisting">&lt;?php
// get the first none multipart part
$part = $message;
while ($part-&gt;isMultipart()) {
    $part = $message-&gt;getPart(1);
}
echo 'Type of this part is ' . strtok($part-&gt;contentType, ';') . "\n";
echo "Content:\n";
echo $part-&gt;getContent();
</pre>
<p>Zend_Mail_Part also implements RecursiveIterator, which makes it easy to scan through all parts. And
        for easy output it also implements the magic method __toString(), which returns the content.</p>
<pre class="programlisting">&lt;?php
// output first text/plain part
$foundPart = null;
foreach (RecursiveIteratorIterator($mail-&gt;getMessage(1)) as $part) {
    try {
        if (strtok($part-&gt;contentType, ';') == 'text/plain') {
            $foundPart = $part;
            break;
        }
    } catch (Zend_Mail_Exception $e) {
        // ignore
    }
}
if (!$foundPart) {
    echo 'no plain text part found';
} else {
    echo "plain text part: \n" . $foundPart;
}
</pre>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-folders"></a>17.14.6. Using folders</h3></div></div></div>
<p>
            All storages, except Pop3, support folders, also called mailboxes. The interface implemented by all storages
            supporting folders is called <code class="code">Zend_Mail_Storage_Folder_Interface</code>. Also all of these classes have an
            additional optional parameter called folder, which is the folder selected after login, in the constructor.
        </p>
<p>
            For the local storages you need to use separate classes called <code class="code">Zend_Mail_Storage_Folder_Mbox</code> or
            <code class="code">Zend_Mail_Storage_Folder_Maildir</code>. Both need one parameter called dirname with the name of the base dir.
            The format for maildir is as defined in maildir++ (with a dot as default delimiter), Mbox is a directory
            hierarchy with Mbox files. If you don't have a Mbox file called INBOX in your Mbox base dir you need to set
            an other folder in the constructor.
        </p>
<p>
            <code class="code">Zend_Mail_Storage_Imap</code> already supports folders by default. Examples for opening these storages:
        </p>
<pre class="programlisting">&lt;?php
// mbox with folders
$mail = new Zend_Mail_Storage_Folder_Mbox(array('dirname' =&gt; '/home/test/mail/'));

// mbox with a default folder not called INBOX, also works
// with Zend_Mail_Storage_Folder_Maildir and Zend_Mail_Storage_Imap
$mail = new Zend_Mail_Storage_Folder_Mbox(array('dirname' =&gt; '/home/test/mail/',
                                                'folder'  =&gt; 'Archive'));

// maildir with folders
$mail = new Zend_Mail_Storage_Folder_Maildir(array('dirname' =&gt; '/home/test/mail/'));

// maildir with colon as delimiter, as suggested in Maildir++
$mail = new Zend_Mail_Storage_Folder_Maildir(array('dirname' =&gt; '/home/test/mail/'
                                                   'delim'   =&gt; ':'));

// imap is the same with and without folders
$mail = new Zend_Mail_Storage_Imap(array('host'     =&gt; 'example.com'
                                         'user'     =&gt; 'test',
                                         'password' =&gt; 'test'));
</pre>
<p>
            With the method getFolders($root = null) you can get the folder hierarchy starting with the root folder or
            the given folder. It's returned as instance of <code class="code">Zend_Mail_Storage_Folder</code>, which implements
            <code class="code">RecursiveIterator</code> and all children are also instances of <code class="code">Zend_Mail_Storage_Folder</code>. Each of
            these instances has a local and a global name returned by the methods <code class="code">getLocalName()</code> and
            <code class="code">getGlobalName()</code>. The global name is the absolute name from the root folder (including
            delimiters), the local name is the name in the parent folder.
        </p>
<div class="table">
<a name="id4846378"></a><p class="title"><b>Tabel 17.2. Mail Folder Names</b></p>
<table summary="Mail Folder Names" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Global Name</th>
<th>Local Name</th>
</tr></thead>
<tbody>
<tr>
<td>/INBOX</td>
<td>INBOX</td>
</tr>
<tr>
<td>/Archive/2005</td>
<td>2005</td>
</tr>
<tr>
<td>List.ZF.General</td>
<td>General</td>
</tr>
</tbody>
</table>
</div>
<p>
            If you use the iterator the key of the current element is the local name. The global name is also returned
            by the magic method <code class="code">__toString()</code>. Some folders may not be selectable, which means they can't
            store messages and selecting them results in an error. This can be checked with the method
            <code class="code">isSelectable()</code>. So it's very easy to output the whole tree in a view:
        </p>
<pre class="programlisting">&lt;?php
$folders = new RecursiveIteratorIterator($this-&gt;mail-&gt;getFolders(),
                                         RecursiveIteratorIterator::SELF_FIRST);
echo '&lt;select name="folder"&gt;';
foreach ($folders as $localName =&gt; $folder) {
    $localName = str_pad('', $folders-&gt;getDepth(), '-', STR_PAD_LEFT) . $localName;
    echo '&lt;option';
    if (!$folder-&gt;isSelectable()) {
        echo ' disabled="disabled"';
    }
    echo ' value="' . htmlspecialchars($folder) . '"&gt;'
        . htmlspecialchars($localName) . '&lt;/option&gt;';
}
echo '&lt;/select&gt;';
</pre>
<p>
            The current selected folders is returned by the method <code class="code">getSelectedFolder()</code>. Changing the folder
            is done with the method <code class="code">selectFolder()</code>, which needs the global name as parameter. If you want
            to avoid to write delimiters you can also use the properties of a <code class="code">Zend_Mail_Storage_Folder</code> instance:
        </p>
<pre class="programlisting">&lt;?php
// depending on your mail storage and its settings $rootFolder-&gt;Archive-&gt;2005
// is the same as:
//   /Archive/2005
//  Archive:2005
//  INBOX.Archive.2005
//  ...
$folder = $mail-&gt;getFolders()-&gt;Archive-&gt;2005;
echo 'Last folder was ' . $mail-&gt;getSelectedFolder() . "new folder is $folder\n";
$mail-&gt;selectFolder($folder);
</pre>
</div>
<div class="sect2" lang="nl">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.mail.read-advanced"></a>17.14.7. Advanced Use</h3></div></div></div>
<div class="sect3" lang="nl">
<div class="titlepage"><div><div><h4 class="title">
<a name="id4846515"></a>17.14.7.1. Using NOOP</h4></div></div></div>
<p>
                If you're using a remote storage and have some long tasks you might need to keep the connection alive
                via noop:
            </p>
<pre class="programlisting">&lt;?php
foreach ($mail as $message) {

    // do some calculations ...

    $mail-&gt;noop(); // keep alive

    // do something else ...

    $mail-&gt;noop(); // keep alive
}
</pre>
</div>
<div class="sect3" lang="nl">
<div class="titlepage"><div><div><h4 class="title">
<a name="id4846534"></a>17.14.7.2. Caching instances</h4></div></div></div>
<p>
            <code class="code">Zend_Mail_Storage_Mbox</code>, <code class="code">Zend_Mail_Storage_Folder_Mbox</code>, <code class="code">Zend_Mail_Storage_Maildir</code> and
            <code class="code">Zend_Mail_Storage_Folder_Maildir</code> implement the magic methods <code class="code">__sleep()</code> and
            <code class="code">__wakeup()</code>, which means they are serializable. This avoids parsing the files or directory tree
            more than once. The disadvantage is that your Mbox or Maildir storage should not change. Some easy checks
            are done, like reparsing the current Mbox file if the modification time changes or reparsing the folder
            structure if a folder has vanished (which still results in an error, but you can search for an other folder
            afterwards). It's better if you have something like a signal file for changes and check it before using the
            cached instance.
            </p>
<pre class="programlisting">&lt;?php
// there's no specific cache handler/class used here,
// change the code to match your cache handler
$signal_file = '/home/test/.mail.last_change';
$mbox_basedir = '/home/test/mail/';
$cache_id = 'example mail cache ' . $mbox_basedir . $signal_file;

$cache = new Your_Cache_Class();
if (!$cache-&gt;isCached($cache_id) || filemtime($signal_file) &gt; $cache-&gt;getMTime($cache_id)) {
    $mail = new Zend_Mail_Storage_Folder_Pop3(array('dirname' =&gt; $mbox_basedir));
} else {
    $mail = $cache-&gt;get($cache_id);
}

// do stuff ...

$cache-&gt;set($cache_id, $mail);
</pre>
</div>
<div class="sect3" lang="nl">
<div class="titlepage"><div><div><h4 class="title">
<a name="id4845627"></a>17.14.7.3. Extending Protocol Classes</h4></div></div></div>
<p>
                Remote storages use two classes: <code class="code">Zend_Mail_Storage_&lt;Name&gt;</code> and
                <code class="code">Zend_Mail_Protocol_&lt;Name&gt;</code>. The protocol class translates the protocol commands and
                responses from and to PHP, like methods for the commands or variables with different structures for
                data. The other/main class implements the common interface.
            </p>
<p>
                If you need additional protocol features you can extend the protocol class and use it in the
                constructor of the main class. As an example assume we need to knock different ports before we can
                connect to POP3.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend.php';
Zend::loadClass('Zend_Mail_Storage_Pop3');

class Example_Mail_Exception extends Zend_Mail_Exception
{
}

class Example_Mail_Protocol_Exception extends Zend_Mail_Protocol_Exception
{
}

class Example_Mail_Protocol_Pop3_Knock extends Zend_Mail_Protocol_Pop3
{
    private $host, $port;

    public function __construct($host, $port = null)
    {
        // no auto connect in this class
        $this-&gt;host = $host;
        $this-&gt;port = $port;
    }

    public function knock($port)
    {
        $sock = @fsockopen($this-&gt;host, $port);
        if ($sock) {
            fclose($sock);
        }
    }

    public function connect($host = null, $port = null, $ssl = false)
    {
        if ($host === null) {
            $host = $this-&gt;host;
        }
        if ($port === null) {
            $port = $this-&gt;port;
        }
        parent::connect($host, $port);
    }
}

class Example_Mail_Pop3_Knock extends Zend_Mail_Storage_Pop3
{
    public function __construct(array $params)
    {
        // ... check $params here! ...
        $protocol = new Example_Mail_Protocol_Pop3_Knock($params['host']);

        // do our "special" thing
        foreach ((array)$params['knock_ports'] as $port) {
            $protocol-&gt;knock($port);
        }

        // get to correct state
        $protocol-&gt;connect($params['host'], $params['port']);
        $protocol-&gt;login($params['user'], $params['password']);

        // initialize parent
        parent::__construct($protocol);
    }
}

$mail = new Example_Mail_Pop3_Knock(array('host'        =&gt; 'localhost',
                                          'user'        =&gt; 'test',
                                          'password'    =&gt; 'test',
                                          'knock_ports' =&gt; array(1101, 1105, 1111)));
</pre>
<p>
                As you see we always assume we're connected, logged in and, if supported, a folder is selected in the
                constructor of the main class. Thus if you assign your own protocol class you always need to make sure
                that's done or the next method will fail if the server doesn't allow it in the current state.
            </p>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.mail.smtp-secure.html">Terug</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.mail.html">Omhoog</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.measure.html">Volgende</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">17.13. Securing SMTP Transport </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Begin</a></td>
<td width="40%" align="right" valign="top"> Hoofdstuk 18. Zend_Measure</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
