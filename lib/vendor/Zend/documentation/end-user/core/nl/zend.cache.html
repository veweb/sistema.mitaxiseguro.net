<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Hoofdstuk 4. Zend_Cache</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Referentiegids voor de programmeur">
<link rel="up" href="index.html" title="Referentiegids voor de programmeur">
<link rel="prev" href="zend.auth.adapter.digest.html" title="3.2. Digest Authentication">
<link rel="next" href="zend.cache.theory.html" title="4.2. De theorie van het cachencaching">
<link rel="chapter" href="zend.html" title="Hoofdstuk 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Hoofdstuk 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Hoofdstuk 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Hoofdstuk 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Hoofdstuk 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Hoofdstuk 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Hoofdstuk 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Hoofdstuk 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Hoofdstuk 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Hoofdstuk 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Hoofdstuk 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Hoofdstuk 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Hoofdstuk 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Hoofdstuk 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Hoofdstuk 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Hoofdstuk 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Hoofdstuk 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Hoofdstuk 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Hoofdstuk 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Hoofdstuk 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Hoofdstuk 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Hoofdstuk 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Hoofdstuk 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Hoofdstuk 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Hoofdstuk 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Hoofdstuk 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Hoofdstuk 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Hoofdstuk 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Hoofdstuk 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Bijlage A. Zend Framework Programmeer Standaard">
<link rel="appendix" href="copyrights.html" title="Bijlage B. Auteursrechtinformatie">
<link rel="index" href="the.index.html" title="Register">
<link rel="section" href="zend.cache.html#zend.cache.introduction" title="4.1. Inleiding">
<link rel="section" href="zend.cache.theory.html" title="4.2. De theorie van het cachencaching">
<link rel="section" href="zend.cache.frontends.html" title="4.3. Zend_Cache frontends">
<link rel="section" href="zend.cache.backends.html" title="4.4. Zend_Cache backends">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Hoofdstuk 4. Zend_Cache</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.auth.adapter.digest.html">Terug</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="zend.cache.theory.html">Volgende</a>
</td>
</tr>
</table></div>
<div class="chapter" lang="nl">
<div class="titlepage"><div><div><h2 class="title">
<a name="zend.cache"></a>Hoofdstuk 4. Zend_Cache</h2></div></div></div>
<div class="toc">
<p><b>Inhoudsopgave</b></p>
<dl>
<dt><span class="sect1"><a href="zend.cache.html#zend.cache.introduction">4.1. Inleiding</a></span></dt>
<dt><span class="sect1"><a href="zend.cache.theory.html">4.2. De theorie van het cachencaching</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.cache.theory.html#zend.cache.factory">4.2.1. De <code class="code">Zend_Cache</code> factory methode</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.theory.html#zend.cache.tags">4.2.2. Records taggen</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.theory.html#zend.cache.clean">4.2.3. Opschonen van de cache</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.cache.frontends.html">4.3. Zend_Cache frontends</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.cache.frontends.html#zend.cache.core">4.3.1. Zend_Cache_Core</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.frontends.html#zend.cache.frontend.output">4.3.2. Zend_Cache_Frontend_Output</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.frontends.html#zend.cache.frontend.function">4.3.3. Zend_Cache_Frontend_Function</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.frontends.html#zend.cache.frontend.class">4.3.4. Zend_Cache_Frontend_Class</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.frontends.html#zend.cache.frontends.file">4.3.5. Zend_Cache_Frontend_File</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.frontends.html#zend.cache.frontends.page">4.3.6. Zend_Cache_Frontend_Page</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.cache.backends.html">4.4. Zend_Cache backends</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.cache.backends.html#zend.cache.backends.file">4.4.1. Zend_Cache_Backend_File</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.backends.html#zend.cache.backends.sqlite">4.4.2. Zend_Cache_Backend_Sqlite</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.backends.html#zend.cache.backends.memcached">4.4.3. Zend_Cache_Backend_Memcached</a></span></dt>
<dt><span class="sect2"><a href="zend.cache.backends.html#zend.cache.backends.apc">4.4.4. Zend_Cache_Backend_APC</a></span></dt>
</dl></dd>
</dl>
</div>
<div class="sect1" lang="nl">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.cache.introduction"></a>4.1. Inleiding</h2></div></div></div>
<p>
        <code class="code">Zend_Cache</code> verstrekt een standaard functie om eender welke data te "cachen".
    </p>
<p>
      Caching in het Zend Framework word door frontends uitgevoerd, terwijl cache records door backend
      adapters worden opgeslagen (<code class="code">File</code>, <code class="code">Sqlite</code>, <code class="code">Memcache</code>...) via
      een flexibel systeem van IDs en tags. Het gebruik van deze tags laat toe eenvoudig bepaalde
      record types te verwijderen (bijvoorbeeld: "verwijder alle cache records gemarkeerd met een
      bepaalde tag").
    </p>
<p>
        De kern van de <code class="code">Zend_Cache_Core</code> module is standaard, flexibel en configurabel.
        Er bestaan echter cache frontends voor specifieke doeleinden die <code class="code">Zend_Cache_Core</code>
        uitbreiden: <code class="code">Output</code>, <code class="code">File</code>, <code class="code">Function</code> en <code class="code">Class</code>.
    </p>
<div class="example">
<a name="id4786457"></a><p class="title"><b>Voorbeeld 4.1. Een frontend verkrijgen met <code class="code">Zend_Cache::factory()</code></b></p>
<p>
            <code class="code">Zend_Cache::factory()</code> instantieert juiste objecten en bindt ze samen.
            In dit eerste voorbeeld zullen we <code class="code">Core</code> frontend gebruiken, samen met
            <code class="code">File</code> backend.
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Cache.php';

$frontendOptions = array(
   'lifeTime' =&gt; 7200, // cache levensduur van 2 uur
   'automaticSerialization' =&gt; true
);

$backendOptions = array(
    'cacheDir' =&gt; './tmp/' // Directory waar we de cache bestanden wegschrijven
);

// verkrijgen van een Zend_Cache_Core object
$cache = Zend_Cache::factory('Core', 'File', $frontendOptions, $backendOptions);

?&gt;</pre>
<p>
            Nu we een frontend hebben kunnen we eender welk type data cachen (we activeerden serialisatie).
            We kunnen bijvoorbeeld het resultaat van een zeer "dure" database query cachen. Nadat het
            in de cache is opgeslagen, is het zelfs niet meer nodig een verbinding met de database te maken;
            records worden uit de cache gehaald en gedeserialiseerd.
        </p>
<pre class="programlisting">&lt;?php

// $cache die in het vorige voorbeeld werd geïnitialiseerd

// nagaan of de cache reeds bestaat:
if(!$result = $cache-&gt;get('mijnresultaat')) {

    // geen cache; verbind met de database
    
    $db = Zend_Db::factory( [...] );
    
    $result = $db-&gt;fetchAll('SELECT * FROM enorme_tabel');
    
    $cache-&gt;save($result, 'mijnresultaat');
    
} else {

    // cache bestaat! laat het weten
    echo "Dit komt uit de cache!\n\n";
    
}

print_r($result);

?&gt;</pre>
</div>
<div class="example">
<a name="id4787238"></a><p class="title"><b>Voorbeeld 4.2. Output cachen met de <code class="code">Zend_Cache</code> output frontend</b></p>
<p>
            We markeren secties waarin we output willen cachen door er een beetje conditionele
            logica aan toe te voegen. We zetten de sectie tussen <code class="code">start()</code> en <code class="code">end()</code>
            methodes (dit wordt geïllustreerd in het eerste voorbeeld en is de voornaamste strategie
            voor het cachen).
        </p>
<p>
            Tussen de twee methodes output je je data zoals gewoonlijk - alle output zal worden gecached als
            de uitvoering de <code class="code">end()</code> methode tegenkomt. Bij de volgende uitvoering zal de hele 
            sectie worden overgeslagen ten voordele van het verkrijgen van de data uit de cache (zolang de
            cache record geldig is).
        </p>
<pre class="programlisting">&lt;?php

$frontendOptions = array(
   'lifeTime' =&gt; 30,                  // cache levensduur van een halve minuut
   'automaticSerialization' =&gt; false  // dit is sowieso standaard
);

$backendOptions = array('cacheDir' =&gt; './tmp/');

$cache = Zend_Cache::factory('Output', 'File', $frontendOptions, $backendOptions);

// we geven een unieke id door aan de start() methode
if(!$cache-&gt;start('mijnpagina')) {
    // output zoals gewoonlijk:
    
    echo 'Hallo wereld! ';
    echo 'Dit is gecached ('.time().') ';
    
    $cache-&gt;end(); // de output wordt opgeslagen en naar de browser gestuurd
}

echo 'Dit word nooit gecached ('.time().').';

?&gt;   </pre>
<p>
           Merk op dat we het resultaat van <code class="code">time()</code> tweemaal weergeven; dit is iets dynamisch
           om het voorbeeld te toetsen. Probeer het voorbeeld verschillende malen uit te voeren; je zal
           merken dat het eerste nummer niet verandert, terwijl het tweede verandert naargelang de tijd
           vordert. Dit komt omdat het eerste nummer samen met de andere output in de cache werd opgeslaan.
           Na een halve minuut (we hebben de levensduur op 30 seconden gezet) moeten de nummers opnieuw
           gelijk zijn omdat de cache record niet meer geldig is -- voor hij opnieuw word gecached. Je
           zou dit in je browser of console moeten proberen.
       </p>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Opmerking]" src="images/note.png"></td>
<th align="left">Opmerking</th>
</tr>
<tr><td align="left" valign="top"><p>
        Als je <code class="code">Zend_Cache</code> gebruikt, let dan op de belangrijke cache id (doorgegeven aan 
        <code class="code">save()</code> en <code class="code">start()</code>. Die moet uniek zijn voor elk deel data die je wil
        cachen, anders kunnen cache records die niets met elkaar te maken hebben elkaar uitwissen of,
        erger nog, afgebeeld worden in plaats van de ander.
    </p></td></tr>
</table></div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.auth.adapter.digest.html">Terug</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="zend.cache.theory.html">Volgende</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">3.2. Digest Authentication </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Begin</a></td>
<td width="40%" align="right" valign="top"> 4.2. De theorie van het cachencaching</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
