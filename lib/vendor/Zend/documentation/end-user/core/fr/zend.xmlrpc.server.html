<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>29.3. Zend_XmlRpc_Server</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.xmlrpc.html" title="Chapitre 29. Zend_XmlRpc">
<link rel="prev" href="zend.xmlrpc.client.html" title="29.2. Zend_XmlRpc_Client">
<link rel="next" href="coding-standard.html" title="Annexe A. Convention de codage PHP du Framework Zend">
<link rel="chapter" href="zend.html" title="Chapitre 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Chapitre 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Chapitre 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Chapitre 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Chapitre 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Chapitre 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Chapitre 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Chapitre 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Chapitre 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Chapitre 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Chapitre 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Chapitre 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Chapitre 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Chapitre 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Chapitre 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Chapitre 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Chapitre 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Chapitre 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Chapitre 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Chapitre 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Chapitre 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Chapitre 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Chapitre 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Chapitre 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Chapitre 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Chapitre 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Chapitre 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Chapitre 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapitre 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Annexe A. Convention de codage PHP du Framework Zend">
<link rel="appendix" href="copyrights.html" title="Annexe B. Informations de copyright">
<link rel="index" href="the.index.html" title="Index">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.introduction" title="29.3.1. Introduction">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.usage" title="29.3.2. XML-RPC Server Basic Usage">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.structure" title="29.3.3. XML-RPC Server Structure">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.conventions" title="29.3.4. Conventions">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.namespaces" title="29.3.5. Utilizing Namespaces">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.request" title="29.3.6. Custom Request Objects">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.response" title="29.3.7. Custom Responses">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.fault" title="29.3.8. Handling Exceptions via Faults">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.caching" title="29.3.9. Caching Server Definitions Between Requests">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.use" title="29.3.10. Usage Examples">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">29.3. Zend_XmlRpc_Server</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.xmlrpc.client.html">Précédent</a> </td>
<th width="60%" align="center">Chapitre 29. Zend_XmlRpc</th>
<td width="20%" align="right"> <a accesskey="n" href="coding-standard.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.xmlrpc.server"></a>29.3. Zend_XmlRpc_Server</h2></div></div></div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.introduction"></a>29.3.1. Introduction</h3></div></div></div>
<p>Zend_XmlRpc_Server is intended as a fully-featured XML-RPC server,
            following <a href="http://www.xmlrpc.com/spec" target="_top">the specifications
            outlined at www.xmlrpc.com</a>. Additionally, it implements the
            system.multicall() method, allowing boxcarring of requests.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.usage"></a>29.3.2. XML-RPC Server Basic Usage</h3></div></div></div>
<p>
            An example of the most basic use case:
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'My/Service/Class.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('My_Service_Class');
echo $server-&gt;handle();
?&gt;</pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.structure"></a>29.3.3. XML-RPC Server Structure</h3></div></div></div>
<p>
            Zend_XmlRpc_Server is composed of a variety of components, ranging
            from the server itself to request, response, and fault objects.
        </p>
<p>
            To bootstrap Zend_XmlRpc_Server, the developer must attach one or
            more classes or functions to the server, via the
            <code class="code">setClass()</code> and <code class="code">addFunction()</code> methods.
        </p>
<p>
            Once done, you may either pass a <code class="code">Zend_XmlRpc_Request</code>
            object to <code class="code">Zend_XmlRpc_Server::handle()</code>, or it will
            instantiate a <code class="code">Zend_XmlRpc_Request_Http</code> object if none
            is provided -- thus grabbing the request from
            <code class="code">php://input</code>.
        </p>
<p>
            <code class="code">Zend_XmlRpc_Server::handle()</code> then attempts to
            dispatch to the appropriate handler based on the method
            requested. It then returns either a
            <code class="code">Zend_XmlRpc_Response</code>-based object or a
            <code class="code">Zend_XmlRpc_Server_Fault</code>object. These objects both have
            <code class="code">__toString()</code> methods that create valid XML-RPC XML
            responses, allowing them to be directly echoed.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.conventions"></a>29.3.4. Conventions</h3></div></div></div>
<p>
            Zend_XmlRpc_Server allows the developer to attach functions and
            class method calls as dispatchable XML-RPC methods. Via
            Zend_Server_Reflection, it does introspection on all attached
            methods, using the function and method docblocks to determine the
            method help text and method signatures.
        </p>
<p>
            XML-RPC types do not necessarily map one-to-one to PHP types.
            However, the code will do its best to guess the appropriate type
            based on the values listed in @param and @return lines. Some XML-RPC
            types have no immediate PHP equivalent, however, and should be
            hinted using the XML-RPC type in the phpdoc. These include:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>dateTime.iso8601, a string formatted as
                    YYYYMMDDTHH:mm:ss</p></li>
<li><p>base64, base64 encoded data</p></li>
<li><p>struct, any associative array</p></li>
</ul></div>
<p>
            An example of how to hint follows:
        </p>
<pre class="programlisting">&lt;?php
/**
* This is a sample function
*
* @param base64 $val1 Base64-encoded data
* @param dateTime.iso8601 $val2 An ISO date
* @param struct $val3 An associative array
* @return struct
function myFunc($val1, $val2, $val3)
{
}</pre>
<p>
            PhpDocumentor does no validation of the types specified for params
            or return values, so this will have no impact on your API
            documentation. Providing the hinting is necessary, however, when the
            server is validating the parameters provided to the method call.
        </p>
<p>
            It is perfectly valid to specify multiple types for both params and
            return values; the XML-RPC specification even suggests that
            system.methodSignature should return an array of all possible method
            signatures (i.e., all possible combinations of param and return
            values). You may do so just as you normally would with
            PhpDocumentor, using the '|' operator:
        </p>
<pre class="programlisting">&lt;?php
/**
* This is a sample function
*
* @param string|base64 $val1 String or base64-encoded data
* @param string|dateTime.iso8601 $val2 String or an ISO date
* @param array|struct $val3 Normal indexed array or an associative array
* @return boolean|struct
function myFunc($val1, $val2, $val3)
{
}</pre>
<p>
            One note, however: allowing multiple signatures can lead to
            confusion for developers using the services; generally speaking, an
            XML-RPC method should only have a single signature.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.namespaces"></a>29.3.5. Utilizing Namespaces</h3></div></div></div>
<p>
            XML-RPC has a concept of namespacing; basically, it allows grouping
            XML-RPC methods by dot-delimited namespaces. This helps prevent
            naming collisions between methods served by different classes. As an
            example, the XML-RPC server is expected to server several methods in
            the 'system' namespace:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>system.listMethods</p></li>
<li><p>system.methodHelp</p></li>
<li><p>system.methodSignature</p></li>
</ul></div>
<p>
            Internally, these map to the methods of the same name in
            Zend_XmlRpc_Server.
        </p>
<p>
            If you want to add namespaces to the methods you serve, simply
            provide a namespace to the appropriate method when attaching a
            function or class:
        </p>
<pre class="programlisting">&lt;?php
// All public methods in My_Service_Class will be accessible as
// myservice.METHODNAME
$server-&gt;setClass('My_Service_Class', 'myservice');

// Function 'somefunc' will be accessible as funcs.somefunc
$server-&gt;addFunction('somefunc', 'funcs');</pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.request"></a>29.3.6. Custom Request Objects</h3></div></div></div>
<p>
            Most of the time, you'll simply use the default request type
            included with Zend_XmlRpc_Server, Zend_XmlRpc_Request_Http. However,
            there may be times when you need XML-RPC to be available via the CLI,
            a GUI, or other environment, or want to log incoming requests. To do
            so, you may create a custom request object that extends
            Zend_XmlRpc_Request. The most important thing to remember is to
            ensure that the getMethod() and getParams() methods are implemented
            so that the XML-RPC server can retrieve that information in order to
            dispatch the request.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.response"></a>29.3.7. Custom Responses</h3></div></div></div>
<p>
            Similar to request objects, Zend_XmlRpc_Server can return custom
            response objects; by default, a Zend_XmlRpc_Response_Http object is
            returned, which sends an appropriate Content-Type HTTP header for
            use with XML-RPC. Possible uses of a custom object would be to log
            responses, or to send responses back to STDOUT.
        </p>
<p>
            To use a custom response class, use
            Zend_XmlRpc_Server::setResponseClass() prior to calling handle().
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.fault"></a>29.3.8. Handling Exceptions via Faults</h3></div></div></div>
<p>
            Zend_XmlRpc_Server catches Exceptions generated by a dispatched
            method, and generates an XML-RPC fault response when such an
            exception is caught. By default, however, the exception messages and
            codes are not used in a fault response. This is an intentional
            decision to protect your code; many exceptions expose more
            information about the code or environment than a developer would
            necessarily intend (a prime example includes database abstraction or
            access layer exceptions).
        </p>
<p>
            Exception classes can be whitelisted to be used as fault responses,
            however. To do so, simply utilize
            Zend_XmlRpc_Server_Fault::attachFaultException() to pass an
            exception class to whitelist:
        </p>
<pre class="programlisting">&lt;?php
Zend_XmlRpc_Server_Fault::attachFaultException('My_Project_Exception');</pre>
<p>
            If you utilize an exception class that your other project exceptions
            inherit, you can then whitelist a whole family of exceptions at a
            time. Zend_XmlRpc_Server_Exceptions are always whitelisted, to
            allow reporting specific internal errors (undefined methods, etc.).
        </p>
<p>
            Any exception not specifically whitelisted will generate a fault
            response with a code of '404' and a message of 'Unknown error'.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.caching"></a>29.3.9. Caching Server Definitions Between Requests</h3></div></div></div>
<p>
            Attaching many classes to an XML-RPC server instance can utilize a
            lot of resources; each class must introspect using the Reflection
            API (via Zend_Server_Reflection), which in turn generates a list of
            all possible method signatures to provide to the server class.
        </p>
<p>
            To reduce this performance hit somewhat, Zend_XmlRpc_Server_Cache
            can be used to cache the server definition between requests. When
            combined with __autoload(), this can greatly increase performance.
        </p>
<p>
            An sample usage follows:
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend.php';
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Cache.php';

function __autoload($class)
{
    Zend::loadClass($class);
}

$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';
$server = new Zend_XmlRpc_Server();

if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    require_once 'My/Services/Glue.php';
    require_once 'My/Services/Paste.php';
    require_once 'My/Services/Tape.php';

    $server-&gt;setClass('My_Services_Glue', 'glue');   // glue. namespace
    $server-&gt;setClass('My_Services_Paste', 'paste'); // paste. namespace
    $server-&gt;setClass('My_Services_Tape', 'tape');   // tape. namespace

    Zend_XmlRpc_Server_Cache::save($cacheFile, $server);
}

echo $server-&gt;handle();</pre>
<p>
            The above example attempts to retrieve a server definition from
            xmlrpc.cache in the same directory as the script. If unsuccessful,
            it loads the service classes it needs, attaches them to the server
            instance, and then attempts to create a new cache file with the
            server definition.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.use"></a>29.3.10. Usage Examples</h3></div></div></div>
<p>
            Below are several usage examples, showing the full spectrum of
            options available to developers. Usage examples will each build
            on the previous example provided.
        </p>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case1"></a>29.3.10.1. Basic Usage</h4></div></div></div>
<p>
                The example below attaches a function as a dispatchable XML-RPC
                method and handles incoming calls.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';

/**
 * Return the MD5 sum of a value
 *
 * @param string $value Value to md5sum
 * @return string MD5 sum of value
 */
function md5Value($value)
{
    return md5($value);
}

$server = new Zend_XmlRpc_Server();
$server-&gt;addFunction('md5Value');
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case2"></a>29.3.10.2. Attaching a class</h4></div></div></div>
<p>
                The example below illustrates attaching a class' public methods
                as dispatchable XML-RPC methods.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Services/Comb.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb');
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case3"></a>29.3.10.3. Attaching several classes using namespaces</h4></div></div></div>
<p>
                The example below illustrates attaching several classes, each
                with their own namespace.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // methods called as pick.*
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case4"></a>29.3.10.4. Specifying exceptions to use as valid fault responses</h4></div></div></div>
<p>
                The example below allows any Services_Exception-derived class to
                report its code and message in the fault response.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // methods called as pick.*
echo $server-&gt;handle();</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case5"></a>29.3.10.5. Utilizing a custom request object</h4></div></div></div>
<p>
                The example below instantiates a custom request object and
                passes it to the server to handle.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Request.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // methods called as pick.*

// Create a request object
$request = new Services_Request();

echo $server-&gt;handle($request);</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case6"></a>29.3.10.6. Utilizing a custom response object</h4></div></div></div>
<p>
                The example below illustrates specifying a custom response class
                for the returned response.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass('Services_Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services_Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services_Pick', 'pick');   // methods called as pick.*

// Create a request object
$request = new Services_Request();

// Utilize a custom response
$server-&gt;setResponseClass('Services_Response');

echo $server-&gt;handle($request);</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.use.case7"></a>29.3.10.7. Cache server definitions between requests</h4></div></div></div>
<p>
                The example below illustrates caching server definitions
                between requests.
            </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/XmlRpc/Server.php';
require_once 'Zend/XmlRpc/Server/Fault.php';
require_once 'Zend/XmlRpc/Server/Cache.php';
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Specify a cache file
$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException('Services_Exception');

$server = new Zend_XmlRpc_Server();

// Attempt to retrieve server definition from cache
if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    $server-&gt;setClass('Services_Comb', 'comb');   // methods called as comb.*
    $server-&gt;setClass('Services_Brush', 'brush'); // methods called as brush.*
    $server-&gt;setClass('Services_Pick', 'pick');   // methods called as pick.*

    // Save cache
    Zend_XmlRpc_Server_Cache::save($cacheFile, $server));
}

// Create a request object
$request = new Services_Request();

// Utilize a custom response
$server-&gt;setResponseClass('Services_Response');

echo $server-&gt;handle($request);</pre>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.xmlrpc.client.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.xmlrpc.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="coding-standard.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">29.2. Zend_XmlRpc_Client </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Annexe A. Convention de codage PHP du Framework Zend</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
