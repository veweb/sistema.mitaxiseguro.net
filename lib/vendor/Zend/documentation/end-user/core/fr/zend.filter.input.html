<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>11.4. Zend_Filter_Input</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.filter.html" title="Chapitre 11. Zend_Filter">
<link rel="prev" href="zend.filter.writing_filters.html" title="11.3. Writing Filters">
<link rel="next" href="zend.gdata.html" title="Chapitre 12. Zend_Gdata">
<link rel="chapter" href="zend.html" title="Chapitre 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Chapitre 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Chapitre 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Chapitre 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Chapitre 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Chapitre 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Chapitre 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Chapitre 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Chapitre 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Chapitre 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Chapitre 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Chapitre 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Chapitre 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Chapitre 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Chapitre 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Chapitre 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Chapitre 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Chapitre 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Chapitre 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Chapitre 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Chapitre 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Chapitre 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Chapitre 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Chapitre 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Chapitre 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Chapitre 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Chapitre 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Chapitre 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapitre 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Annexe A. Convention de codage PHP du Framework Zend">
<link rel="appendix" href="copyrights.html" title="Annexe B. Informations de copyright">
<link rel="index" href="the.index.html" title="Index">
<link rel="subsection" href="zend.filter.input.html#zend.filter.input.introduction" title="11.4.1. Introduction">
<link rel="subsection" href="zend.filter.input.html#zend.filter.input.introduction.whitelist" title="11.4.2. Filtrage par liste blanche">
<link rel="subsection" href="zend.filter.input.html#zend.filter.input.introduction.blind" title="11.4.3. Filtrage à l'aveugle">
<link rel="subsection" href="zend.filter.input.html#zend.filter.input.introduction.blacklist" title="11.4.4. Filtrage par liste noire">
<link rel="subsection" href="zend.filter.input.html#zend.filter.input.theoryofoperation" title="11.4.5. Fonctionnement">
<link rel="subsection" href="zend.filter.input.html#zend.filter.input.usecases" title="11.4.6. Exemples d'utilisation">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">11.4. Zend_Filter_Input</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.filter.writing_filters.html">Précédent</a> </td>
<th width="60%" align="center">Chapitre 11. Zend_Filter</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.gdata.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.filter.input"></a>11.4. Zend_Filter_Input</h2></div></div></div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.input.introduction"></a>11.4.1. Introduction</h3></div></div></div>
<p>
     <code class="literal">Zend_Filter_Input</code> fournit des méthodes simples dédiées au filtrage
     des données passées en entrée; ces services implémentent une approche structurée et
     stricte du problème. Ce composant est à multiples facettes car il est adapté aux besoins
     de trois catégories différentes de personnes :
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
<p>Les développeurs</p>
<p>
            Bien que le filtrage des données passées en entrée ne sera jamais aussi facile
            que la solution consistant à ne rien faire, les développeurs doivent pouvoir
            s'assurer de l'intégrité de leurs données et ce sans avoir à ajouter de complexité
            inutile à leur code. <code class="literal">Zend_Filter_Input</code> fournit des méthodes simples
            adaptées aux scénarios les plus fréquents, des possibilités d'extension
            pour les scénarios moins courants et enfin une convention de nommage stricte
            qui encourage la clarté du code.
            </p>
</li>
<li>
<p>Les chefs de projet</p>
<p>
            Les chefs de projet de toute catégorie qui ont besoin de contrôler
            un groupe important de développeurs peuvent les forcer à employer une
            approche structurée du problème du filtrage de données en limitant ou
            éliminant les possibilités d'accès aux données brutes.
            </p>
</li>
<li>
<p>Les auditeurs</p>
<p>
            Les personnes qui auditent le code d'une application doivent pouvoir
            identifier rapidement et de manière fiable à quel moment et à quel endroit
            les données brutes sont employées par un développeur. Les caractéristiques du
            composant qui encouragent la clarté du code, facilitent aussi le travail des
            auditeurs en leur fournissant une distinction claire entre les différentes
            approches du problème du filtrage de données.
            </p>
</li>
</ul></div>
<p>
    Il existe une grande variété d'approches différentes du problème du filtrage de
    données et il existe aussi une grande variété de possibilités offertes aux développeurs PHP.
    Le filtrage par liste blanche, le filtrage par liste noire, les expressions régulières,
    les instructions conditionnelles et certaines fonctions PHP natives sont juste quelques exemples
    du pot pourri du filtrage de données. <code class="literal">Zend_Filter_Input</code> combine toutes ces possibilités en une
    seule et même API au comportement cohérent et aux conventions de nommage strictes. Toutes les
    méthodes adhèrent à une règle simple - si les données sont valides, elles sont renvoyées sinon
    <code class="literal">FALSE</code> est renvoyé : simplicité extrême!
    </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.input.introduction.whitelist"></a>11.4.2. Filtrage par liste blanche</h3></div></div></div>
<p>
        Les méthodes implémentant un filtrage par "liste blanche" commencent par <code class="literal">test</code>;
        <code class="literal">testAlpha()</code> et <code class="literal">testEmail()</code> en sont deux exemples.
        Ces méthodes inspectent les données passées
        en entrée selon des critères pré-définis et ne renvoient ces données que si elles adhèrent
        aux critères considérés. Si ce n'est pas le cas, <code class="literal">FALSE</code> est renvoyé. L'exemple suivant constitue
        une illustration simple :
        </p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);

        if ($nomAlpha = $filtrePost-&gt;testAlpha('nom')) {
            /* $nomAlpha ne contient que des caractères alphabétiques */
        } else {
            /* $nomAlpha est évalué comme FALSE */
        }

        ?&gt;
        </pre>
<p>
        L'exemple ci-dessus échoue dans certains cas du fait de l'évaluation booléenne de la valeur
        renvoyée par la méthode testAlpha(). Si vous voulez faire une distinction entre les valeurs
        évaluées comme <code class="literal">FALSE</code> par PHP (comme l'entier <code class="literal">0</code> ou la chaîne vide)
        et l'objet <code class="literal">FALSE</code> lui-même, vous pouvez réaliser une comparaison stricte :
        </p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);
        $nomAlpha = $filtrePost-&gt;testAlpha('nom');

        if ($nomAlpha !== FALSE) {
            /* $nomAlpha ne contient que des caractères alphabétiques */
        } else {
            /* $nomAlpha === FALSE */
        }

        ?&gt;
        </pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.input.introduction.blind"></a>11.4.3. Filtrage à l'aveugle</h3></div></div></div>
<p>
        Les méthodes implémentant un filtrage à l'aveugle commencent par <code class="literal">get</code>; <code class="literal">getAlpha()</code>
        et <code class="literal">getDigits()</code> en sont deux exemples. Ces méthodes n'inspectent pas les données passées en
        entrée mais renvoient la partie considérée comme valide de ces données.
        À titre d'exemple, <code class="literal">getAlpha()</code> renvoie uniquement les caractères alphabétiques des données,
        s'il y en a. (S'il n'y en a pas, la chaîne sera vide.) L'exemple suivant constitue
        une illustration simple :
        </p>
<pre class="programlisting">
        &lt;?php

        /* $_POST['nom_utilisateur'] = 'Jacques123Dupond'; */

        $filtrePost = new Zend_Filter_Input($_POST);
        $nomUtilisateurAlpha = $filtrePost-&gt;getAlpha('nom_utilisateur');

        /* $nomUtilisateurAlpha = 'JohnDoe'; */

        ?&gt;
        </pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.input.introduction.blacklist"></a>11.4.4. Filtrage par liste noire</h3></div></div></div>
<p>
        Les méthodes implémentant un filtrage par liste noire commencent par <code class="literal">no</code>; <code class="literal">noTags()</code>
         et <code class="literal">noPath()</code> en sont deux exemples.
        Ces méthodes sont identiques aux méthodes de filtrage à l'aveugle sauf que le critère dont elles s'assurent
        représente ce qui est invalide et non valide. Les données invalides sont supprimées puis le reste (supposé valide)
        est renvoyé. L'exemple suivant constitue une illustration simple :
        </p>
<pre class="programlisting">
        &lt;?php

        /* $_POST['commentaire'] = "&lt;b&gt;J'aime PHP!&lt;/b&gt;"; */

        $filtrePost = new Zend_Filter_Input($_POST);
        $commentaireSansBalises = $filtrePost-&gt;noTags('commentaire');

        /* $commentaireSansBalises = "J'aime PHP!"; */

        ?&gt;
        </pre>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.input.theoryofoperation"></a>11.4.5. Fonctionnement</h3></div></div></div>
<p>
        <code class="literal">Zend_Filter_Input</code> combine plusieurs approches différentes du filtrage de données en une seule et même API
        au comportement cohérent et aux conventions de nommage strictes (voir la section <a href="zend.filter.input.html#zend.filter.input.introduction" title="11.4.1. Introduction">Section 11.4.1, « Introduction »</a>). Ceci met
        <code class="literal">Zend_Filter_Input</code> sur un pied d'égalité avec les solutions existantes mais cela ne facilite pas vraiment la
        vie des personnes qui souhaitent une approche plus structurée ou plus stricte. C'est pourquoi <code class="literal">Zend_Filter_Input</code>
        force par défaut les développeurs à accéder de manière contrôlée aux données passées en entrée.
        </p>
<p>
        Deux syntaxes sont prises en charge. Dans l'approche par défaut (stricte), le seul argument passé au constructeur est le tableau devant être filtré :
        </p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);
        $email = $filtrePost-&gt;testEmail('email');

        ?&gt;
        </pre>
<p>
        <code class="literal">Zend_Filter_Input</code> affecte <code class="literal">NULL</code> au tableau passé en argument (<code class="literal">$_POST</code> dans notre exemple)
        et ainsi l'accès direct aux données n'est plus possible. (Les données brutes ne sont accessibles que via la méthode <code class="literal">getRaw()</code>,
        bien plus simple à rechercher et/ou éviter.)
        </p>
<p>
        Pour l'approche optionnelle (non-stricte), vous devez passer <code class="literal">FALSE</code> en tant que deuxième argument du constructeur.
        </p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST, FALSE);
        $email = $filtrePost-&gt;testEmail('email');

        ?&gt;
        </pre>
<p>
        L'utilisation est exactement la même, sauf que <code class="literal">Zend_Filter_Input</code> ne définit pas le tableau original (<code class="literal">$_POST</code>)
        à <code class="literal">NULL</code>, les développeurs peuvent donc toujours y avoir accès. Cette approche est déconseillée au profit de l'approche stricte.
        </p>
<p>
        <code class="literal">Zend_Filter_Input</code> est conçu en priorité pour fonctionner avec des tableaux.
        Beaucoup de sources de données sont présentes en PHP sous forme de tableaux
        (<code class="literal">$_GET</code>, <code class="literal">$_POST</code>,<code class="literal">$_COOKIE</code>, etc.) et
        les tableaux constituent en général un moyen courant de stocker les données provenant d'une source tierce.
        Si vous souhaitez filtrer un scalaire, voyez <a href="zend.filter.html" title="Chapitre 11. Zend_Filter">Chapitre 11, <i>Zend_Filter</i></a>.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.filter.input.usecases"></a>11.4.6. Exemples d'utilisation</h3></div></div></div>
<p>Filtrage strict par liste blanche (conseillé) :</p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);

        if ($email = $filtrePost-&gt;testEmail('email')) {
            /* $email est une adresse e-mail valide */
        } else {
            /* $email n'est pas une adresse e-mail valide */
        }

        ?&gt;
        </pre>
<p>Filtrage à l'aveugle strict :</p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);
        $nomAlpha = $filtrePost-&gt;getAlpha('nom');

        ?&gt;
        </pre>
<p>Filtrage strict par liste noire :</p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);
        $commentaireSansBalises = $filtrePost-&gt;noTags('commentaire');

        ?&gt;
        </pre>
<p>Filtrage non-strict par liste blanche :</p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST, FALSE);

        if ($email = $filtrePost-&gt;testEmail('email')) {
            /* $email est une adresse e-mail valide */
        } else {
            /* $email n'est pas une adresse e-mail valide */
        }

        ?&gt;
        </pre>
<p>Filtrage non-strict à l'aveugle :</p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST);
        $nomAlpha = $filtrePost-&gt;getAlpha('nom');

        ?&gt;
        </pre>
<p>Filtrage non-strict par liste noire :</p>
<pre class="programlisting">
        &lt;?php

        $filtrePost = new Zend_Filter_Input($_POST, FALSE);
        $commentaireSansBalises = $filtrePost-&gt;noTags('commentaire');

        ?&gt;
        </pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.filter.writing_filters.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.filter.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.gdata.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">11.3. Writing Filters </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> Chapitre 12. Zend_Gdata</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
