<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>13.2. Zend_Http_Client - Utilisation avancée</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.http.html" title="Chapitre 13. Zend_Http">
<link rel="prev" href="zend.http.html" title="Chapitre 13. Zend_Http">
<link rel="next" href="zend.http.client.adapters.html" title="13.3. Zend_Http_Client - Connection Adapters">
<link rel="chapter" href="zend.html" title="Chapitre 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Chapitre 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Chapitre 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Chapitre 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Chapitre 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Chapitre 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Chapitre 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Chapitre 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Chapitre 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Chapitre 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Chapitre 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Chapitre 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Chapitre 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Chapitre 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Chapitre 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Chapitre 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Chapitre 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Chapitre 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Chapitre 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Chapitre 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Chapitre 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Chapitre 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Chapitre 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Chapitre 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Chapitre 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Chapitre 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Chapitre 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Chapitre 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapitre 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Annexe A. Convention de codage PHP du Framework Zend">
<link rel="appendix" href="copyrights.html" title="Annexe B. Informations de copyright">
<link rel="index" href="the.index.html" title="Index">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.redirections" title="13.2.1. Redirections HTTP">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.cookies" title="13.2.2. Ajout de cookies et gestion de leur persistence">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.custom_headers" title="13.2.3. Définir des entêtes personnalisés">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.file_uploads" title="13.2.4. Envoi de fichiers">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.raw_post_data" title="13.2.5. Envoyer des données brutes via POST">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.http_authentication" title="13.2.6. Authentification HTTP">
<link rel="subsection" href="zend.http.client.advanced.html#zend.http.client.multiple_requests" title="13.2.7. Envoyer plusieurs requêtes avec le même client">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">13.2. Zend_Http_Client - Utilisation avancée</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.http.html">Précédent</a> </td>
<th width="60%" align="center">Chapitre 13. Zend_Http</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.http.client.adapters.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.http.client.advanced"></a>13.2. Zend_Http_Client - Utilisation avancée</h2></div></div></div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.redirections"></a>13.2.1. Redirections HTTP</h3></div></div></div>
<p>
            Par défaut, Zend_Http_Client gère automatiquement les redirections HTTP,
            et suivra jusqu'à 5 redirections. Ce comportement peut être modifié en changeant
            le paramètre de configuration 'maxredirects'.
        </p>
<p>
            Conformément à la RFC HTTP/1.1, les codes réponse HTTP 301 et 302 doivent être
            traités par le client en envoyant à nouveau la même requête à l'adresse spécifiée
            - en utilisant la même méthode de requête. Cependant, la plupart
            des clients ne réagissent pas correctement et redirige toujours via une requête GET.
            Par défaut, Zend_Http_Client agit de même - Lors d'une redirection
            basée sur la réception d'un code 301 ou 302, tous les paramètres GET et POST sont
            remis à zéro, et une requête GET est envoyée à la nouvelle adresse. Ce
            comportement peut être modifié en positionnant le paramètre de configuration 'strictredirects'
            à TRUE :
            </p>
<div class="example">
<a name="id4831455"></a><p class="title"><b>Exemple 13.16. Forcer des redirections conformes au RFC 2616 lors de la réception d'un code statut 301 and 302</b></p>
<pre class="programlisting">
&lt;?php
    // Redirections strictes
    $client-&gt;setConfig(array('strictredirects' =&gt; true)

    // Redirections non strictes
    $client-&gt;setConfig(array('strictredirects' =&gt; false)
?&gt;</pre>
</div>
<p>
        </p>
<p>
            Il est toujours possible d'obtenir le nombre de redirections effectuées
            après l'envoi d'une requête en invoquant la méthode getRedirectionsCount().
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.cookies"></a>13.2.2. Ajout de cookies et gestion de leur persistence</h3></div></div></div>
<p>
            Zend_Http_Client fournit une interface simple afin d'ajouter des cookies
            à une requête de manière à ce qu'aucune modification directe de l'entête
            ne soit nécessaire. Ceci est réalisé via la méthode setCookie(). Cette
            méthode peut être utilisée de plusieurs manières :
        	</p>
<div class="example">
<a name="id4832161"></a><p class="title"><b>Exemple 13.17. Définition de cookies via setCookie()</b></p>
<pre class="programlisting">
&lt;?php
    // Simple et facile : en fournissant un nom de cookie et une valeur
    $client-&gt;setCookie('parfum', 'pépites de chocolat');

    // en fournissant directement une chaîne de cookie encodée (nom=valeur)
    // Notez que la valeur doit être déjà encodée au format URL
    $client-&gt;setCookie('parfum=p%C3%A9pites%20de%20chocolat');

    // En fournissant un objet Zend_Http_Cookie
    $cookie = Zend_Http_Cookie::factory('parfum=p%C3%A9pites%20de%20chocolat');
    $client-&gt;setCookie($cookie);
?&gt;</pre>
</div>
<p>
            Pour plus d'information sur les objets Zend_Http_Cookie, voir
        	<a href="zend.http.cookies.html" title="13.4. Zend_Http_Cookie and Zend_Http_CookieJar">Section 13.4, « Zend_Http_Cookie and Zend_Http_CookieJar »</a>.
        </p>
<p>
            Zend_Http_Client permet également la persistance des cookies -
            ce qui permet au client de stocker tous les cookies reçus et transmis,
            et de les retransmettre automatiquement lors des requêtes suivantes.
            Cela se révèle trés utile lorsqu'il est nécessaire de s'identifier
            sur un site donné (et de recevoir ainsi un cookie de session) avant de
            pouvoir envoyer d'autres requêtes.
            </p>
<div class="example">
<a name="id4832187"></a><p class="title"><b>Exemple 13.18. Activer la persistance des cookies</b></p>
<pre class="programlisting">
&lt;?php
    // Pour activer la persistance des cookies, définissez un Magasin de cookie "Cookie Jar"
    $client-&gt;setCookieJar();

    // Première requête : s'identifier et démarrer une session
    $client-&gt;setUri('http://exemple.com/login.php');
    $client-&gt;addParameterPost('user', 'h4x0r');
    $client-&gt;addParameterPost('password', '1337');
    $client-&gt;request('POST');

    // Le magasin de cookies stocke automatiquement les
    // cookies transmis dans la réponse, un cookie de session par exemple

    // Maintenant nous pouvons envoyer notre requête suivante
    // les cookies stockés seront transmis automatiquement.
    $client-&gt;setUri('http://exemple.com/lire_actualite_membres.php');
    $client-&gt;request('GET');
?&gt;</pre>
</div>
<p>
            Pour plus d'information sur la classe Zend_Http_CookieJar, voir
        	<a href="zend.http.cookies.html#zend.http.cookies.cookiejar" title="13.4.5. The Zend_Http_CookieJar Class: Instantiation">Section 13.4.5, « The Zend_Http_CookieJar Class: Instantiation »</a>.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.custom_headers"></a>13.2.3. Définir des entêtes personnalisés</h3></div></div></div>
<p>
            Il est possible de définir des entêtes personnalisés en utilisant
            la méthode setHeaders().
            Cette méthode est très versatile et peut être utilisée de diverses
            manières comme le montre l'exemple suivant :
            </p>
<div class="example">
<a name="id4832287"></a><p class="title"><b>Exemple 13.19. Définir un entête personnalisé unique</b></p>
<pre class="programlisting">
&lt;?php
    // Définition d'un entête unique, écrasant toute valeur précédemment définie
    $client-&gt;setHeaders('Host', 'www.exemple.com');

    // La même chose d'une autre manière
    $client-&gt;setHeaders('Host: www.example.com');

    // Définition de plusieurs valeurs pour le même entête (surtout utile pour les entêtes de cookies)
    $client-&gt;setHeaders('Cookie', array(
        'PHPSESSID=1234567890abcdef1234567890abcdef',
        'language=fr'
    ));
?&gt;</pre>
</div>
<p>
        </p>
<p>
            setHeader() peut aussi être facilement utilisé pour définir des
            entêtes multiples en un seul appel, en fournissant un tableau d'entêtes
            comme paramètre unique :
            </p>
<div class="example">
<a name="id4832329"></a><p class="title"><b>Exemple 13.20. Définition de plusieurs entêtes personnalisés</b></p>
<pre class="programlisting">
&lt;?php
    // Définition de plusieurs entêtes, écrasant toute valeur précédemment définie
    $client-&gt;setHeaders(array(
        'Host' =&gt; 'www.exemple.com',
        'Accept-encoding', 'gzip,deflate',
        'X-Powered-By' =&gt; 'Zend Framework'));

    // Le tableau peut contenir uniquement des valeurs
    $client-&gt;setHeaders(array(
        'Host: www.exemple.com',
        'Accept-encoding: gzip,deflate',
        'X-Powered-By: Zend Framework'));
?&gt;</pre>
</div>
<p>
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.file_uploads"></a>13.2.4. Envoi de fichiers</h3></div></div></div>
<p>
            Il est possible d'envoyer des fichiers au travers d'HTTP en utilisant
            la méthode setFileUpload. Cette méthode attend un nom de fichier
            comme premier paramètre, un nom de formulaire comme second paramètre,
            et, en option, des données comme troisième paramètre.
            Si le troisième paramètre est null, la valeur du premier paramètre
            est supposée être un fichier sur le disque dur et Zend_Http_Client
            essaiera de lire ce fichier et de l'envoyer. Sinon la valeur du premier
            paramètre sera envoyée comme nom du fichier mais il n'est pas nécessaire
            que le fichier existe sur le disque dur.
            Le deuxième paramètre est toujours requis, et est équivalent à
            l'attribut "name" d'une balise &gt;input&lt;, si le fichier devait
            être envoyé à partir d'un formulaire HTML.
            Un quatrième paramètre optionnel fournit le type du fichier. S'il
            n'est pas spécifié et que Zend_Http_Client lit le fichier à partir
            du disque dur, la fonction mime_content_type sera utilisée pour
            tenter de définir, si possible, le type du fichier. Dans tous les
            cas, le type MIME par défaut sera 'application/octet-stream'.
            </p>
<div class="example">
<a name="id4832403"></a><p class="title"><b>Exemple 13.21. Utilisation de setFileUpload pour envoyer des fichiers</b></p>
<pre class="programlisting">
&lt;?php
    // Envoi de données arbitraires comme fichier
    $texte = 'ceci est un texte ordinaire';
    $client-&gt;setFileUpload('du_texte.txt', 'upload', $texte, 'text/plain');

    // envoi d'un fichier existant
    $client-&gt;setFileUpload('/tmp/Backup.tar.gz', 'bufile');

    // envoi des fichiers
    $client-&gt;submit('POST');
?&gt;</pre>
</div>
<p>
            Dans le premier exemple, la variable $texte est envoyée et sera
            disponible dans $_FILES['upload'] côté serveur. Dans le second
            exemple, le fichier existant /tmp/Backup.tar.gz est envoyé au
            serveur et sera disponible dans $_FILES['bufile']. Son type sera
            défini automatiquement si possible. Sinon, le type sera défini
            comme 'application/octet-stream'.
        </p>
<div class="note"><table border="0" summary="Note: Envoi de fichiers">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Envoi de fichiers</th>
</tr>
<tr><td align="left" valign="top"><p>
                Lors de l'envoi de fichiers, le type de la requête HTTP
                est automatiquement défini comme 'multipart/form-data'.
                Gardez à l'esprit que vous devez utiliser la méthode POST
                ou la méthode PUT pour envoyer des fichiers. La plupart
                des serveurs ignoreront le corps de la requête si vous
                utilisez une autre méthode.
            </p></td></tr>
</table></div>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.raw_post_data"></a>13.2.5. Envoyer des données brutes via POST</h3></div></div></div>
<p>
            Vous pouvez utiliser Zend_Http_Client pour envoyer des données
            brutes via POST en utilisant la méthode setRawData(). Cette
            méthode accepte deux paramètres : le premier contient les données
            à transmettre dans le corps de la requête. Le deuxième paramètre,
            optionnel, contient le type des données. Bien que ce paramètre
            soit optionnel, vous devriez normalement le définir avant l'envoi
            de la requête, soit via setRawData() ou via la méthode setEncType().
            </p>
<div class="example">
<a name="id4832490"></a><p class="title"><b>Exemple 13.22. Envoi de données brutes via POST</b></p>
<pre class="programlisting">
&lt;?php
    $xml = '&lt;book&gt;' .
           '  &lt;title&gt;Islands in the Stream&lt;/title&gt;' .
           '  &lt;author&gt;Ernest Hemingway&lt;/author&gt;' .
           '  &lt;year&gt;1970&lt;/year&gt;' .
           '&lt;/book&gt;';

    $client-&gt;setRawData($xml, 'text/xml')-&gt;request('POST');

    // Une autre manière de faire la même chose :
    $client-&gt;setRawData($xml)-&gt;setEncType('text/xml')-&gt;request('POST');
?&gt;</pre>
</div>
<p>
            Les données seront disponible côté serveur via la variable PHP
            $HTTP_RAW_POST_DATA ou via le flux php://input.
        </p>
<div class="note"><table border="0" summary="Note: Utiliser des données brutes POST">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Utiliser des données brutes POST</th>
</tr>
<tr><td align="left" valign="top"><p>
                Définir des données brutes POST pour une requête écrasera
                tout autre paramètre POST ou envoi de fichiers. Il est
                recommandé de ne pas utiliser les deux conjointement. Gardez
                à l'esprit que la plupart des serveurs ignoreront le corps
                de la requête si celle-ci n'utilise pas la méthode POST.
            </p></td></tr>
</table></div>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.http_authentication"></a>13.2.6. Authentification HTTP</h3></div></div></div>
<p>
            Actuellement, Zend_Http_Client propose uniquement l'authentification HTTP 'basic'.
            Cette fonctionnalité est utilisée via la méthode setAuth(). Celle-ci
            accepte trois paramètres : le nom d'utilisateur, le mot de passe et
            un type d'authentification optionnel. Comme mentionné, seule l'authentification
            'basic' est actuellement implémentée (l'ajout de l'authentification 'digest'
            est planifié).
            </p>
<div class="example">
<a name="id4832573"></a><p class="title"><b>Exemple 13.23. Définir nom d'utilisateur et mot de passe pour l'authentification HTTP</b></p>
<pre class="programlisting">
&lt;?php
    // Utilisation de l'authentification 'basic'
    $client-&gt;setAuth('shahar', 'monMotdePasse!', Zend_Http_Client::AUTH_BASIC);

    // L'authentification 'basic' étant le comportement par défaut, on peut aussi écrire ceci :
    $client-&gt;setAuth('shahar', 'monMotdePasse!');
?&gt;</pre>
</div>
<p>
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.http.client.multiple_requests"></a>13.2.7. Envoyer plusieurs requêtes avec le même client</h3></div></div></div>
<p>
            Zend_Http_Client a été également conçu spécifiquement pour gérer
            plusieurs requêtes consécutives avec la même instance. Ceci est
            utile dans les cas ou le script nécessite d'accéder à des données
            en provenance de divers emplacements ou, par exemple, lors de l'accès
            à des ressources HTTP nécessitant une authentification préalable.
        </p>
<p>
            Lorsqu'on génère plusieurs requêtes vers le même hôte, il est
            chaudement recommandé d'activer la variable de configuration
            'keepalive'. De cette manière, si le serveur supporte le mode de
            connexion 'keep-alive', la connexion au serveur sera fermée après
            l'exécution de toutes les requêtes et la destruction de l'instance.
            Ceci permet d'éviter au serveur d'ouvrir et de fermer de multiples
            connexions TCP.
        </p>
<p>
            Lorsqu'on génère plusieurs requêtes avec le même client, mais
            qu'on souhaite s'assurer que tous les paramètres spécifiques de
            chacune des requêtes sont effacés, on peut utiliser la méthode
            resetParameters(). Ceci permet de supprimer tous les paramètres
            GET et POST, le contenu des requêtes et les entêtes spécifiques
            de manière à ce qu'ils ne soient pas réutilisés lors de la requête
            suivante.
        </p>
<div class="note"><table border="0" summary="Note: Réinitialiser les paramètres">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Réinitialiser les paramètres</th>
</tr>
<tr><td align="left" valign="top"><p>
                Notez que les entêtes spécifiques non liés à la requête ne sont
                pas réinitialisés quand la méthode resetParameters est invoquée.
                En fait, seuls les entêtes 'Content-length' et Content-type' sont
                supprimés. Ceci permet de définir une seule fois les entêtes comme
                'Accept-language' ou 'Accept-encoding'.
            </p></td></tr>
</table></div>
<p>
            Une autre fonctionnalité spécifique aux requêtes consécutives est
            l'objet Magasin de Cookies ('Cookie Jar'). Il permet de sauver
            automatiquement les cookies définis par le serveur lors de la
            première requête et de les renvoyer de manière transparente lors
            de chacune des requêtes suivantes. Ceci permet, par exemple, de
            passer une étape d'authentification avant d'envoyer d'autres requêtes.
        </p>
<p>
            Si votre application nécessite une requête d'authentification par
            utilisateur, et que d'autres requêtes peuvent être effectuées via
            plusieurs scripts différents, il peut se révéler pratique de stocker
            le Magasin de cookies dans la session utilisateur. De cette manière,
            il sera possible de ne s'identifier qu'une seule fois par session.
        </p>
<div class="example">
<a name="id4831934"></a><p class="title"><b>Exemple 13.24. Exécuter plusieurs requêtes avec un seul client</b></p>
<pre class="programlisting">
&lt;?php
    // D'abord, instancier le client
    $client = new Zend_Http_Client('http://www.exemple.com/obtientdonnees.php', array(
        'keepalive' =&gt; true
    ));

    // Disposons-nous du cookie de session ?
    if (isset($_SESSION['cookiejar']) &amp;&amp;
        $_SESSION['cookiejar'] instanceof Zend_Http_CookieJar)) {

        $client-&gt;setCookieJar($_SESSION['cookiejar']);
    } else {
        // Sinon, Identifions-nous et stockons le cookie
        $client-&gt;setCookieJar();
        $client-&gt;setUri('http://www.exemple.com/connexion.php');
        $client-&gt;setParameterPost(array(
            'user' =&gt; 'shahar',
            'pass' =&gt; 'secret'
        ));
        $client-&gt;request(Zend_Http_Client::POST);

        // Maintenant, effaçons les paramètres et définissons l'URI
        // à sa valeur originale (notez que les cookies envoyés par le
        // serveur sont stockés dans le magasin de cookies)
        $client-&gt;resetParameters();
        $client-&gt;setUri('http://www.exemple.com/obtientdonnees.php');
    }

    $reponse = $client-&gt;request(Zend_Http_Client::GET);

    // Stockons les cookies dans la session pour la page suivante
    $_SESSION['cookiejar'] = $client-&gt;getCookieJar();
?&gt;</pre>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.http.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.http.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.http.client.adapters.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapitre 13. Zend_Http </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> 13.3. Zend_Http_Client - Connection Adapters</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
