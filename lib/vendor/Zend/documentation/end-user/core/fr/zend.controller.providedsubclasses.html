<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>7.4. Provided Subclasses</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guide de référence du programmeur">
<link rel="up" href="zend.controller.html" title="Chapitre 7. Zend_Controller">
<link rel="prev" href="zend.controller.subclassing.html" title="7.3. Sous-classement">
<link rel="next" href="zend.controller.action.html" title="7.5. Action Controllers">
<link rel="chapter" href="zend.html" title="Chapitre 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Chapitre 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Chapitre 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Chapitre 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Chapitre 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Chapitre 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Chapitre 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Chapitre 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Chapitre 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Chapitre 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Chapitre 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Chapitre 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Chapitre 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Chapitre 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Chapitre 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Chapitre 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Chapitre 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Chapitre 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Chapitre 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Chapitre 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Chapitre 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Chapitre 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Chapitre 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Chapitre 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Chapitre 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Chapitre 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Chapitre 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Chapitre 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapitre 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Annexe A. Convention de codage PHP du Framework Zend">
<link rel="appendix" href="copyrights.html" title="Annexe B. Informations de copyright">
<link rel="index" href="the.index.html" title="Index">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.introduction" title="7.4.1. Introduction">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http" title="7.4.2. Zend_Controller_Request_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.rewriterouter" title="7.4.3. Zend_Controller_RewriteRouter">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.http" title="7.4.4. Zend_Controller_Response_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.cli" title="7.4.5. Zend_Controller_Response_Cli">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">7.4. Provided Subclasses</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Précédent</a> </td>
<th width="60%" align="center">Chapitre 7. Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.controller.action.html">Suivant</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="fr">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.providedsubclasses"></a>7.4. Provided Subclasses</h2></div></div></div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.introduction"></a>7.4.1. Introduction</h3></div></div></div>
<p>
            Zend Framework provides several alternatives to the default classes
            provided, including alternate request objects, routers, and response
            objects.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.request.http"></a>7.4.2. Zend_Controller_Request_Http</h3></div></div></div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.introduction"></a>7.4.2.1. Introduction</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> provides a request object
                for use in an HTTP environment. In addition to extending
                <code class="code">Zend_Controller_Request_Abstract</code>, it proxies to a
                <code class="code">Zend_Http_Request</code> object. <code class="code">Zend_Controller_Request_Http</code>
                is the default request class utilised by
                <code class="code">Zend_Controller_Dispatcher</code>.
            </p>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.dataaccess"></a>7.4.2.2. Accessing Request Data</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> encapsulates access
                to relevant values such as the key name and value for the
                controller and action router variables, and all additional
                parameters parsed from the URI. By proxying to
                <code class="code">Zend_Http_Request</code> it additionally allows
                access to values contained in the superglobals as public
                members and manages the current Base URL and Request URI.
                Superglobal values cannot be set on a request object, instead use
                the setParam/getParam methods to set or retrieve user parameters.
            </p>
<div class="note"><table border="0" summary="Note: Superglobal data">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Superglobal data</th>
</tr>
<tr><td align="left" valign="top"><p>
                    When accessing superglobal data through <code class="code">Zend_Controller_Request_Http</code>
                    as public member properties, it is necessary to keep in mind that
                    the property name (superglobal array key) is matched to a superglobal
                    in a specific order of precedence: 1. GET, 2. POST, 3. COOKIE, 4. SERVER, 5. ENV.
                </p></td></tr>
</table></div>
<p>
                Specific superglobals can be accessed using a public method as an
                alternative. For example, the raw value of <code class="code">$_POST['user']</code>
                can be accessed by calling <code class="code">getPost('user')</code> on the
                request object.
            </p>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.baseurl"></a>7.4.2.3. Base Url and subdirectories</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> by proxying to
                <code class="code">Zend_Http_Request</code> allows Zend_Controller_RewriteBase
                to be used in subdirectories. Zend_Http_Request will attempt to
                automatically detect your base URL and set it accordingly.
            </p>
<p>
                For example, if you keep your
                <code class="code">index.php</code> in a webserver subdirectory named
                <code class="code">/projects/myapp/index.php</code>, base URL (rewrite base)
                should be set to <code class="code">/projects/myapp</code>. This string will
                then be stripped from the beginning of the path before
                calculating any route matches. This frees one from the necessity
                of prepending it to any of your routes. A route of
                <code class="code">'user/:username'</code> will match URIs like
                <code class="code">http://localhost/projects/myapp/user/martel</code> and
                <code class="code">http://example.com/user/martel</code>.
            </p>
<div class="note"><table border="0" summary="Note: URL detection is case sensitive">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">URL detection is case sensitive</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Automatic base URL detection is case sensitive, so make sure your URL
                    will match a subdirectory name in a filesystem (even on Windows
                    machines). If it doesn't you will get to noRoute action.
                </p></td></tr>
</table></div>
<p>
                Should base URL be detected incorrectly you can override it
                with your own base path with the help of the
                <code class="code">setBaseUrl()</code> method of either the
                <code class="code">Zend_Http_Request</code> class, the
                <code class="code">Zend_Controller_Request_Http</code> class, or the
                <code class="code">Zend_Controller_Front</code> class. The easiest
                method is to set it in <code class="code">Zend_Controller_Front</code>, 
                which will proxy it into the request object. Example usage to
                set a custom base URL:
            </p>
<pre class="programlisting">
/** 
 * Dispatch Request with custom base URL with Zend_Controller_Front.
 */
$router     = new Zend_Controller_RewriteRouter();
$controller = Zend_Controller_Front::getInstance();
$controller-&gt;setControllerDirectory('./application/controllers')
           -&gt;setRouter($router)
           -&gt;setBaseUrl('/projects/myapp'); // set the base url!
$response   = $controller-&gt;dispatch();</pre>
</div>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter"></a>7.4.3. Zend_Controller_RewriteRouter</h3></div></div></div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.introduction"></a>7.4.3.1. Introduction</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_RewriteRouter</code> is a new
                version of the framework
                router. Routing is the process of taking a URI endpoint (that part
                of the URI which comes after the base URL) and
                decomposing it into parameters to determine which
                controller and action of that
                controller should receive the request. This value of the
                controller, action and other parameters is packaged into a
                <code class="code">Zend_Controller_Request_Http</code> object which is
                then processed by <code class="code">Zend_Controller_Dispatcher</code>.
                Routing occurs only once: when the request is initially
                received and before the first controller is dispatched.
            </p>
<p>
                <code class="code">Zend_Controller_RewriteRouter</code> is designed to allow for
                mod_rewrite like functionality using pure php structures. It is
                very loosely based on Ruby on Rails routing and does not require
                any prior knowledge of webserver URL rewriting. It is designed
                to work with a single Apache mod_rewrite rule (one of):
            </p>
<pre class="programlisting">
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php</pre>
<p>
            or:
            </p>
<pre class="programlisting">
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 </pre>
<p>
                The RewriteRouter can also be used with the IIS webserver
                if <a href="http://www.isapirewrite.com" target="_top">Isapi_Rewrite</a>
                has been installed as an Isapi extension with the following rewrite rule:
            </p>
<pre class="programlisting">
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]</pre>
<div class="note"><table border="0" summary="Note: IIS Isapi_Rewrite">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">IIS Isapi_Rewrite</th>
</tr>
<tr><td align="left" valign="top"><p>
                    When using IIS, <code class="code">$_SERVER['REQUEST_URI']</code>
                    will either not exist, or be set as an empty string. In
                    this case, <code class="code">Zend_Http_Request</code> will
                    attempt to use the <code class="code">$_SERVER['HTTP_X_REWRITE_URL']</code>
                    value set by the Isapi_Rewrite extension.
                </p></td></tr>
</table></div>
<p>If using Lighttpd, the following rewrite rule is valid:</p>
<pre class="programlisting">
url.rewrite-once = ( ".*\.(js|ico|gif|jpg|png|css)$" =&gt; "$0", "" =&gt; "/index.php")</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.usage"></a>7.4.3.2. Using a router</h4></div></div></div>
<p>
                To properly use the RewriteRouter you have to instantiate it,
                add some user defined routes and inject it into the controller.
                The following code illustrates the procedure:
            </p>
<pre class="programlisting">
/* Create a router */

$router = new Zend_Controller_RewriteRouter();
$router-&gt;addRoute(
	'user',
	new Zend_Controller_Router_Route('user/:username', array('controller' =&gt; 'user', 'action' =&gt; 'info'))
);

/* Set it in a controller */

$ctrl = Zend_Controller_Front::getInstance();
$ctrl-&gt;setRouter($router);</pre>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.basic"></a>7.4.3.3. Basic Routes</h4></div></div></div>
<p>
                The heart of the RewriteRouter is the definition of user defined
                routes. Routes are created by calling the addRoute method of
                RewriteRouter and passing in a new instance of
                <code class="code">Zend_Controller_Router_Route</code>:
            </p>
<pre class="programlisting">
$router-&gt;addRoute('user', new Zend_Controller_Router_Route('user/:username'));</pre>
<p>
                The first parameter is the name of the route. It is redundant at
                the moment of writing but will be used in the future in a URL
                view helper to allow for easy URL generation in your views.
                Should you need to make use of a previously configured named
                route, you can retrieve it with the getRoute method of the
                RewriteRouter. The second parameter is an instance of
                <code class="code">Zend_Controller_Router_Route</code>.
            </p>
<p>
                The first parameter for the
                <code class="code">Zend_Controller_Router_Route</code>
                constructor is a route that will be matched to a URL -
                for example, the above route will match
                <code class="code">http://example.com/user/martel</code>. The colon in a
                route marks a URL variable. After the successful routing, values 
                of all defined variables will be injected to the Zend_Controller_Request.
                After that they will be accessible through a Zend_Controller_Request::getParam or 
                Zend_Controller_Action::_getParam methods. In our example a
                parameter named username will be set to a value of 'martel'.
            </p>
<div class="note"><table border="0" summary="Note: Reverse matching">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Reverse matching</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Routes are matched in reverse order so make sure your most
                    generic routes are defined first.
                </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note: Character useage">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Character useage</th>
</tr>
<tr><td align="left" valign="top"><p>
                    For now the current implementation allows for use of any
                    characters except a slash (/) as a variable identifier but it is
                    strongly recommended that one uses only php variable friendly
                    characters. In future the implementation will probably be
                    altered and this may introduce bugs to your code.
                </p></td></tr>
</table></div>
<p>
                There are two special variables which can be used in your routes
                - ':controller' and ':action'. These special variables will be
                used to find a controller and/or an action chosen in the URL.
                The ':action' variable must always be defined either in the route
                or as a default parameter. The ':controller' variable will
                default to the IndexController if it is not defined.
            </p>
<div class="note"><table border="0" summary="Note: Special variables">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Special variables</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Names of these special variables may be different if you choose to 
                    alter the defaults in <code class="code">Zend_Controller_Request_Http</code> 
                    by the means of setControllerKey and setActionKey methods.
                </p></td></tr>
</table></div>
<pre class="programlisting">
$router-&gt;addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);</pre>
<p>
                If you point your browser to 'http://example.com/news/latest'
                with this route defined the <code class="code">Zend_Controller_Dispatcher</code>
                will invoke the latestAction method of your NewsController class.
            </p>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-defaults"></a>7.4.3.4. Variable defaults</h4></div></div></div>
<p>
                Every variable in the route can have a default. To provide it
                you have to add a second parameter to the
                <code class="code">Zend_Controller_Router_Route</code> constructor. This
                parameter is an array with keys as variable names and
                values as desired defaults.
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006))
);</pre>
<p>
                What may not be clearly visible is that the above route will
                match URLs like 'http://example.com/archive/2005' and
                'http://example.com/archive'. In the latter case the variable
                year will have a value of 2006.
            </p>
<p>
                The above example will only result in injecting a year variable 
                to the request. No routing will take place since controller and 
                action parameters are not set. To make it more usable you have to 
                provide a valid controller and a valid action as defaults. 
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006, 'controller' =&gt; 'archive', 'action' =&gt; 'show')
);</pre>
<p>
				This route will then result in dispatching to showAction of ArchiveController.
            </p>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-requirements"></a>7.4.3.5. Variable requirements</h4></div></div></div>
<p>
                One can add a third parameter to the 
                <code class="code">Zend_Controller_Router_Route</code>
                constructor where variable requirements can
                be set. These are defined as regular expressions:
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006), array('year' =&gt; '\d+'))
);</pre>
<div class="note"><table border="0" summary="Note: Routing behavior">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Routing behavior</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Unlike Ruby on Rails, ZF RewriteRouter will match a route and
                    use a default when a third parameter variable requirement is
                    not met. So the URL of 'http://example.com/archive/test' will
                    match the above route and set the year to 2006. This
                    functionality may be altered in the future as it is being
                    discussed at the moment of writing of this documentation.
                </p></td></tr>
</table></div>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.rewritebase"></a>7.4.3.6. Base URL and subdirectories</h4></div></div></div>
<p>
                Unlike the original Router, the current RewriteRouter can be used in
                subdirectories. The original RewriteRouter's setRewriteBase()
                method is no longer available however. Instead the base URL
                will be automatically detected by Zend_Controller_Request_Http 
                (which proxies to Zend_Http_Request).
            </p>
<p>
                Should the base URL be detected incorrectly you can override it
                with your own base path with the help of Zend_Http_Request
                by calling the setBaseUrl() method (see <a href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http.baseurl" title="7.4.2.3. Base Url and subdirectories">Section 7.4.2.3, « Base Url and subdirectories »</a>).
            </p>
</div>
<div class="sect3" lang="fr">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.default-routes"></a>7.4.3.7. Default routes</h4></div></div></div>
<p>
                Zend_Controller_RewriteRouter is preconfigured with one default
                route to provide compatibility with the first version of the 
                router. It will match URIs in the shape of <code class="code">'controller/action'</code> 
                and will also match any additional parameters appended to the URI by default.
                It is configured as:
            </p>
<pre class="programlisting">
// Route for Router v1 compatibility
$compat = new Zend_Controller_Router_Route(':controller/:action/*', array('controller' =&gt; 'index', 'action' =&gt; 'index'));
$this-&gt;addRoute('default', $compat);</pre>
<div class="note"><table border="0" summary="Note: Matching URIs">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Matching URIs</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Zend_Controller_RewriteRouter is configured for backwards
                    compatibility. It will automatically match <code class="code">controller/action</code>
                    URIs with additional parameters. The additional parameters do not
                    require the addition of new routes unless they must have default values
                    or variable requirements. These additional parameters will be accessible
                    from the Zend_Controller_Action::_getParam method.
                </p></td></tr>
</table></div>
</div>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.http"></a>7.4.4. Zend_Controller_Response_Http</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Http</code> is a response object
            suitable for use in an HTTP environment. It contains methods for
            setting, retrieving, and clearing headers, and the
            <code class="code">__toString()</code> method sends all headers at once before
            returning the response content.
        </p>
<p>
            <code class="code">setHeader()</code> takes two arguments, a header type and the
            header value. A third, optional parameter, if passed and true, will
            force the new header to replace any other headers registered with
            that type.
        </p>
</div>
<div class="sect2" lang="fr">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.cli"></a>7.4.5. Zend_Controller_Response_Cli</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Cli</code> is a response object
            suitable for use in an CLI environment. It has no methods for
            handling headers, and simply returns all body content when
            <code class="code">__toString()</code> is invoked.
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Précédent</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">Niveau supérieur</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.controller.action.html">Suivant</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">7.3. Sous-classement </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td>
<td width="40%" align="right" valign="top"> 7.5. Action Controllers</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
