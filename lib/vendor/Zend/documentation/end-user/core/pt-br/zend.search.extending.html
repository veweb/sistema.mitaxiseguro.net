<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>22.7. Extensibilidade</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guia de Referência do Programador">
<link rel="up" href="zend.search.html" title="Capítulo 22. Zend_Search">
<link rel="prev" href="zend.search.charset.html" title="22.6. Conjuntos de Caracteres">
<link rel="next" href="zend.search.java-lucene.html" title="22.8. Interoperando com Java Lucene">
<link rel="chapter" href="zend.html" title="Capítulo 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Capítulo 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Capítulo 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Capítulo 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Capítulo 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Capítulo 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Capítulo 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Capítulo 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Capítulo 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Capítulo 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Capítulo 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Capítulo 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Capítulo 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Capítulo 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Capítulo 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Capítulo 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Capítulo 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Capítulo 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Capítulo 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Capítulo 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Capítulo 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Capítulo 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Capítulo 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Capítulo 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Capítulo 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Capítulo 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Capítulo 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Capítulo 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Capítulo 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Apêndice A. Padrões de Codificação do Framework Zend para PHP">
<link rel="appendix" href="copyrights.html" title="Apêndice B. Informação de Direitos Autorais">
<link rel="index" href="the.index.html" title="Índice Remissivo">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.analysis" title="22.7.1. Análise de Texto">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.scoring" title="22.7.2. Algoritmos de Pontuação">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.storage" title="22.7.3. Recipientes de Armazenagem">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">22.7. Extensibilidade</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.search.charset.html">Anterior</a> </td>
<th width="60%" align="center">Capítulo 22. Zend_Search</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.search.java-lucene.html">Próxima</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pt-br">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.search.extending"></a>22.7. Extensibilidade</h2></div></div></div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.analysis"></a>22.7.1. Análise de Texto</h3></div></div></div>
<p>A classe <code class="code">Zend_Search_Lucene_Analysis_Analyzer</code> class é
    usada pelo indexador para "tokenizar" campos de documentos de
    texto.</p>
<p>Os métodos
    <code class="code">Zend_Search_Lucene_Analysis_Analyzer::getDefault()</code> e
    <code class="code">Zend_Search_Lucene_Analysis_Analyzer::setDefault()</code> são usados
    para obter e setar, respectivamente, o analisador padrão.</p>
<p>Dessa forma você pode estipular o seu próprio analisador de textos
    ou selecioná-lo dentre uma lista de analisadores prédefinidos:
    <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text</code> e
    <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive</code>
    (default). Ambos interpretam um "token" como uma sequencia de letras.
    <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive</code>
    converte os "tokens" para caixa baixa.</p>
<p>Para selecionar um analisador utilize o código:</p>
<pre class="programlisting">&lt;?php

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new Zend_Search_Lucene_Analysis_Analyzer_Common_Text());
...
$index-&gt;addDocument($doc);

?&gt;</pre>
<p><code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common</code> foi
    projetado ser o pai de todos os analisadores definidos pelo usuário. O
    usuário só precisa definir o método <code class="code">tokenize()</code>, que receberá
    os dados de entrada como uma string e retornará um array de
    "tokens".</p>
<p>O método <code class="code">tokenize()</code> deve aplicar o método
    <code class="code">normalize()</code> a todos os "tokens". Ele permite o uso de filtros
    de "token" junto com o seu analisador.</p>
<p>Aqui está um exemplo de um analisador customizado, que aceita tanto
    palavras contendo digitos tratando-as como um único termo: </p>
<div class="example">
<a name="id4869298"></a><p class="title"><b>Exemplo 22.1. Analisador de texto customizado.</b></p>
<pre class="programlisting">&lt;?php
/** Here is a custome text analyser, which treats words with digits as one term */


/** Zend_Search_Lucene_Analysis_Analyzer_Common */
require_once 'Zend/Search/Lucene/Analysis/Analyzer/Common.php';

class My_Analyzer extends Zend_Search_Lucene_Analysis_Analyzer_Common
{
    /**
     * Tokenize text to a terms
     * Returns array of Zend_Search_Lucene_Analysis_Token objects
     *
     * @param string $data
     * @return array
     */
    public function tokenize($data)
    {
        $tokenStream = array();

        $position = 0;
        while ($position &lt; strlen($data)) {
            // skip white space
            while ($position &lt; strlen($data) &amp;&amp; !ctype_alpha($data{$position}) &amp;&amp; !ctype_digit($data{$position})) {
                $position++;
            }

            $termStartPosition = $position;

            // read token
            while ($position &lt; strlen($data) &amp;&amp; (ctype_alpha($data{$position}) || ctype_digit($data{$position}))) {
                $position++;
            }

            // Empty token, end of stream.
            if ($position == $termStartPosition) {
                break;
            }

            $token = new Zend_Search_Lucene_Analysis_Token(substr($data,
                                             $termStartPosition,
                                             $position-$termStartPosition),
                                      $termStartPosition,
                                      $position);
            $tokenStream[] = $this-&gt;normalize($token);
        }

        return $tokenStream;
    }
}

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new My_Analyzer());

?&gt;</pre>
</div>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.scoring"></a>22.7.2. Algoritmos de Pontuação</h3></div></div></div>
<p>A pontuação da consulta <code class="code">q</code> para o documento
    <code class="code">d</code> é definida como segue:</p>
<p><code class="code">score(q,d) = sum( tf(t in d) * idf(t) * getBoost(t.field in d)
    * lengthNorm(t.field in d) ) * coord(q,d) * queryNorm(q)</code></p>
<p>tf(t in d) -
    <code class="code">Zend_Search_Lucene_Search_Similarity::tf($freq)</code> - um fator de
    pontuação baseado na frequência de um termo ou frase em um
    documento.</p>
<p>idf(t) -
    <code class="code">Zend_Search_Lucene_Search_SimilaritySimilarity::tf($term,
    $reader)</code> - um fator de pontuação para um termo simples para o
    índice especificado.</p>
<p>getBoost(t.field in d) - fator de reforço para o campo.</p>
<p>lengthNorm($term) - O valor de normalização para um campo, dado o
    número total de termos contido nele. Este valor é armazenado junto com o
    índice. Estes valores, juntamente com os campos de reforço, são
    armazenados em um índice e multiplicados nas pontuações de acerto em cada
    campo, pelo código de busca.</p>
<p>Comparações em campos longos são menos precisas, e implementações
    deste método usualmente retornam valores pequenos quando o número de
    "tokens" é grande, e valores gradnes quando o número de "tokens" for
    pequeno.</p>
<p>coord(q,d) -
    <code class="code">Zend_Search_Lucene_Search_Similarity::coord($overlap,
    $maxOverlap)</code> - um fator de pontuação baseado no quociente de todos
    os termos de busca que um documento contém.</p>
<p>The presence of a large portion of the query terms indicates a
    better match with the query, so implementations of this method usually
    return larger values when the ratio between these parameters is large and
    smaller values when the ratio between them is small.</p>
<p>A existência de uma grande quantidade de termos de busca indica um
    grau maior de comparação. As implementações deste método usualmente
    retornam valores significativos quando a razão entre estes parâmetros é
    grande e vice versa. </p>
<p>queryNorm(q) - o valor de normalização para uma consulta dado a soma
    dos (squared weights) de cada termo da consulta. Este valor é então
    multiplicado pelo (weight) de cada ítem da consulta.</p>
<p>Isto não afeta a pontuação, mas a quantidade de tentativas para
    gerar pontuações em comparações entre consultas.</p>
<p>O algoritmo de pontuação pode ser customizado pela implementação da
    sua própria classe de similaridade. Para isso crie uma classe descendente
    de Zend_Search_Lucene_Search_Similarity como mostrado abaixo, então use o
    método
    <code class="code">Zend_Search_Lucene_Search_Similarity::setDefault($similarity);</code>
    para defini-la como padrão.</p>
<pre class="programlisting">&lt;?php

class MySimilarity extends Zend_Search_Lucene_Search_Similarity {
    public function lengthNorm($fieldName, $numTerms) {
        return 1.0/sqrt($numTerms);
    }

    public function queryNorm($sumOfSquaredWeights) {
        return 1.0/sqrt($sumOfSquaredWeights);
    }

    public function tf($freq) {
        return sqrt($freq);
    }

    /**
     * It's not used now. Computes the amount of a sloppy phrase match,
     * based on an edit distance.
     */
    public function sloppyFreq($distance) {
        return 1.0;
    }

    public function idfFreq($docFreq, $numDocs) {
        return log($numDocs/(float)($docFreq+1)) + 1.0;
    }

    public function coord($overlap, $maxOverlap) {
        return $overlap/(float)$maxOverlap;
    }
}

$mySimilarity = new MySimilarity();
Zend_Search_Lucene_Search_Similarity::setDefault($mySimilarity);

?&gt;</pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.storage"></a>22.7.3. Recipientes de Armazenagem</h3></div></div></div>
<p>A classe abstrata Zend_Search_Lucene_Storage_Directory define a
    funcionalidade de diretório.</p>
<p>O construtor do Zend_Search_Lucene usa como entrada uma string ou um
    objeto da classe Zend_Search_Lucene_Storage_Directory.</p>
<p>A classe Zend_Search_Lucene_Storage_Directory_Filesystem implementa
    a funcionalidade de diretório para o sistema de arquivos.</p>
<p>If string is used as an input for the Zend_Search_Lucene
    constructor, then the index reader (Zend_Search_Lucene object) treats it
    as a file system path and instantiates
    Zend_Search_Lucene_Storage_Directory_Filesystem object by
    themselves.</p>
<p>Se uma string for usada como entrada para o construtor do
    Zend_Search_Lucene, então o leitor do índice (um objeto
    Zend_Search_Lucene) a tratará como um caminho para o sistema de arquivos e
    instanciará um objeto da classe
    Zend_Search_Lucene_Storage_Directory_Filesystem.</p>
<p>Voce pode definir a sua própria implementação de diretório
    extendendo a classe Zend_Search_Lucene_Storage_Directory.</p>
<p>Métodos de Zend_Search_Lucene_Storage_Directory: </p>
<pre class="programlisting">&lt;?php

abstract class Zend_Search_Lucene_Storage_Directory {
/**
 * Closes the store.
 *
 * @return void
 */
abstract function close();


/**
 * Creates a new, empty file in the directory with the given $filename.
 *
 * @param string $name
 * @return void
 */
abstract function createFile($filename);


/**
 * Removes an existing $filename in the directory.
 *
 * @param string $filename
 * @return void
 */
abstract function deleteFile($filename);


/**
 * Returns true if a file with the given $filename exists.
 *
 * @param string $filename
 * @return boolean
 */
abstract function fileExists($filename);


/**
 * Returns the length of a $filename in the directory.
 *
 * @param string $filename
 * @return integer
 */
abstract function fileLength($filename);


/**
 * Returns the UNIX timestamp $filename was last modified.
 *
 * @param string $filename
 * @return integer
 */
abstract function fileModified($filename);


/**
 * Renames an existing file in the directory.
 *
 * @param string $from
 * @param string $to
 * @return void
 */
abstract function renameFile($from, $to);


/**
 * Sets the modified time of $filename to now.
 *
 * @param string $filename
 * @return void
 */
abstract function touchFile($filename);


/**
 * Returns a Zend_Search_Lucene_Storage_File object for a given $filename in the directory.
 *
 * @param string $filename
 * @return Zend_Search_Lucene_Storage_File
 */
abstract function getFileObject($filename);

}

?&gt;</pre>
<p>O método <code class="code">getFileObject($filename)</code> da classe
    Zend_Search_Lucene_Storage_Directory retorna um objeto
    Zend_Search_Lucene_Storage_File.</p>
<p>A classe abstrata Zend_Search_Lucene_Storage_File implementa a
    abstração de arquivo e as primitivas de leitura de arquivos de
    índice.</p>
<p>Se fizer isso, você também terá que extender a classe
    Zend_Search_Lucene_Storage_File para a sua implementação de
    diretório.</p>
<p>Somente dois métodos da classe Zend_Search_Lucene_Storage_File devem
    ser sobrecarregados em sua implementação: </p>
<pre class="programlisting">&lt;?php

class MyFile extends Zend_Search_Lucene_Storage_File {
    /**
     * Sets the file position indicator and advances the file pointer.
     * The new position, measured in bytes from the beginning of the file,
     * is obtained by adding offset to the position specified by whence,
     * whose values are defined as follows:
     * SEEK_SET - Set position equal to offset bytes.
     * SEEK_CUR - Set position to current location plus offset.
     * SEEK_END - Set position to end-of-file plus offset. (To move to
     * a position before the end-of-file, you need to pass a negative value
     * in offset.)
     * Upon success, returns 0; otherwise, returns -1
     *
     * @param integer $offset
     * @param integer $whence
     * @return integer
     */
    public function seek($offset, $whence=SEEK_SET) {
        ...
    }

    /**
     * Read a $length bytes from the file and advance the file pointer.
     *
     * @param integer $length
     * @return string
     */
    protected function _fread($length=1) {
        ...
    }
}

?&gt;</pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.search.charset.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.search.html">Acima</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.search.java-lucene.html">Próxima</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">22.6. Conjuntos de Caracteres </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td>
<td width="40%" align="right" valign="top"> 22.8. Interoperando com Java Lucene</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
