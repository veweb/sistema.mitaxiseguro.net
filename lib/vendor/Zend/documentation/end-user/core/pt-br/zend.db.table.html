<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>9.4. Zend_Db_Table</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guia de Referência do Programador">
<link rel="up" href="zend.db.html" title="Capítulo 9. Zend_Db">
<link rel="prev" href="zend.db.select.html" title="9.3. Zend_Db_Select">
<link rel="next" href="zend.db.tablerow.html" title="9.5. Zend_Db_Table_Row">
<link rel="chapter" href="zend.html" title="Capítulo 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Capítulo 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Capítulo 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Capítulo 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Capítulo 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Capítulo 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Capítulo 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Capítulo 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Capítulo 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Capítulo 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Capítulo 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Capítulo 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Capítulo 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Capítulo 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Capítulo 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Capítulo 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Capítulo 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Capítulo 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Capítulo 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Capítulo 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Capítulo 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Capítulo 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Capítulo 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Capítulo 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Capítulo 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Capítulo 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Capítulo 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Capítulo 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Capítulo 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Apêndice A. Padrões de Codificação do Framework Zend para PHP">
<link rel="appendix" href="copyrights.html" title="Apêndice B. Informação de Direitos Autorais">
<link rel="index" href="the.index.html" title="Índice Remissivo">
<link rel="subsection" href="zend.db.table.html#zend.db.table.introduction" title="9.4.1. Introdução">
<link rel="subsection" href="zend.db.table.html#zend.db.table.getting-started" title="9.4.2. Iniciando">
<link rel="subsection" href="zend.db.table.html#zend.db.table.name-and-key" title="9.4.3. Nome da Tabela e Chave Primária">
<link rel="subsection" href="zend.db.table.html#zend.db.table.insert" title="9.4.4. Inserindo Linhas">
<link rel="subsection" href="zend.db.table.html#zend.db.table.udpate" title="9.4.5. Atualizando Linhas">
<link rel="subsection" href="zend.db.table.html#zend.db.table.delete" title="9.4.6. Apagando Linhas">
<link rel="subsection" href="zend.db.table.html#zend.db.table.findbykey" title="9.4.7. Encontrando Linhas por Chave Primária">
<link rel="subsection" href="zend.db.table.html#zend.db.table.fetchonerow" title="9.4.8. Buscando Uma Linha">
<link rel="subsection" href="zend.db.table.html#zend.db.table.fetchmultiple" title="9.4.9. Buscando Múltiplas Linhas">
<link rel="subsection" href="zend.db.table.html#zend.db.table.domain-logic" title="9.4.10. Incluindo Lógica de Domínio">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">9.4. Zend_Db_Table</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.select.html">Anterior</a> </td>
<th width="60%" align="center">Capítulo 9. Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.tablerow.html">Próxima</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pt-br">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.table"></a>9.4. Zend_Db_Table</h2></div></div></div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.introduction"></a>9.4.1. Introdução</h3></div></div></div>
<p>
            Zend_Db_Table é um módulo de tabelas para o Framework Zend.  Ele
            conecta ao seu banco de dados através do Zend_Db_Adapter, examina o
			esquema de uma tabela, e então ajuda você a manipular e buscar
			linhas daquela tabela.
        </p>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.getting-started"></a>9.4.2. Iniciando</h3></div></div></div>
<p>
            A primeira coisa a fazer é alimentar a classe abstrata Zend_Db_Table
            com um adaptador de banco de dados padrão; a menos que você especifique o oposto,
            todas as instâncias de Zend_Db_Table usarão este adaptador padrão.
        </p>
<pre class="programlisting">&lt;?php
// define um adaptador
require_once 'Zend/Db.php';
$params = array (
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'malory',
    'password' =&gt; '******',
    'dbname'   =&gt; 'camelot'
);

$db = Zend_Db::factory('PDO_MYSQL', $params);

// define o adaptador padrão para todos os objetos Zend_Db_Table
require_once 'Zend/Db/Table.php';
Zend_Db_Table::setDefaultAdapter($db);
?&gt;
        </pre>
<p>
            Em seguida, vamos assume que você tem uma tabela no seu banco de dados
            chamada "round_table".  Para usar Zend_Db_Table com aquela tabela,
			simplesmente extenda Zend_Db_Table para criar uma nova classe chamada
            RoundTable (note como o nome round_table é "camelizado").
            Então nós podemos examinar, manipular linhas, e buscar resultados da 
            tabela 'round_table' no banco de dados através daquela classe.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table {}
$table = new RoundTable();
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.name-and-key"></a>9.4.3. Nome da Tabela e Chave Primária</h3></div></div></div>
<p>
            Por padrão, Zend_Db_Table espera que o nome da tabela no banco de dados
			será o mesmo que o nome da sua prória classe (após convertido de 
			CamelCaps para palavras_com_sobrescrito).  Portanto, uma classe Zend_Db_Table
            chamada AlgumNomeDeTabela mapeia para uma tabela SQL chamada 'algum_nome_de_tabela'.
            Se você quer que sua classe mapeie para algo diferente da forma com sobrescrito
			do nome da tabela, sobrescrevaa propriedade $_name quando definir sua classe.
        </p>
<pre class="programlisting">&lt;?php
class ClassName extends Zend_Db_Table
{
    // nome padrão da tabela é 'class_name'
    // mas nós queremos mapear para algo diferente
    protected $_name = 'another_table_name';
}
?&gt;
        </pre>
<p>
            Por padrão, Zend_Db_Table espera que sua tabela tenha uma chave
			primária chamada 'id'.  (É melhor que esta coluna seja
            auto-incrementável, mas isso não é requerido.)  se sua chave primária
            tem um nome diferente de 'id', você pode sobrescrever a propriedade
            $_primary quando definir a sua classe.
        </p>
<pre class="programlisting">&lt;?php
class ClassName extends Zend_Db_Table
{
    // nome padrão da chave primária é 'id'
    // mas nós queremos usar algo diferente
    protected $_primary = 'another_column_name';
}
?&gt;
        </pre>
<p>
            Alternativamente, você pode fazer estas definições no método _setup() da 
			sua classe extendida; apenas certifique-se de chamar parent::_setup()
            ao final do método.
        </p>
<pre class="programlisting">&lt;?php
class ClassName extends Zend_Db_Table
{
    protected function _setup()
    {
        $this-&gt;_name = 'another_table_name';
        $this-&gt;_primary = 'another_column_name';
        parent::_setup();
    }
}
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.insert"></a>9.4.4. Inserindo Linhas</h3></div></div></div>
<p>
            Para inserir uma nova linha na sua tabela, simplesmente chame insert()
            passando uma matriz associativa com dados coluna:valor.  Os dados
			serão protegidos para você automaticamente, e o último ID inserido
            será retornado.  (Note que isso difere de Zend_Db_Adapter::insert(), 
			em que o número de linhas afetadas será retornado.)
        </p>
<pre class="programlisting">&lt;?php
//
// INSERT INTO round_table
//     (noble_title, first_name, favorite_color)
//     VALUES ("King", "Arthur", "blue")
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();

$data = array(
    'noble_title' =&gt; 'King',
    'first_name'  =&gt; 'Arthur',
    'favorite_color' =&gt; 'blue',
)

$id = $table-&gt;insert($data);
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.udpate"></a>9.4.5. Atualizando Linhas</h3></div></div></div>
<p>
            Para atualizar qualquer número de linhas na sua tabela, chame update()
            passsando uma matriz associativa com dados coluna:valor a serem definidos,
			e uma cláusula WHERE para determinar quais linhas serão atualizadas.
            A tabela será atualizada e o número de linhas afetadas será retornado.
        </p>
<p>
            Os dados a serem definidos serão protegidos para você automaticamente, mas
            a cláusula WHERE não, então você deve protegê-la com o objeto
			Zend_Db_Adapter da tabela.
        </p>
<pre class="programlisting">&lt;?php
//
// UPDATE round_table
//     SET favorite_color = "yellow"
//     WHERE first_name = "Robin"
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

$set = array(
    'favorite_color' =&gt; 'yellow',
)

$where = $db-&gt;quoteInto('first_name = ?', 'Robin');

$rows_affected = $table-&gt;update($set, $where);
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.delete"></a>9.4.6. Apagando Linhas</h3></div></div></div>
<p>
            Para apagar qualquer número de linhas da sua tabela, chame delete()
			com uma cláusula WHERE para determinar quasi linhas serão afetadas.
			O número de linhas apagadas será retornado.
        </p>
<p>
			A cláusula WHERE não será protegida automaticamente, então você deve protegê-la 
			usando o objeto Zend_Db_Adapter da tabela.
        </p>
<pre class="programlisting">&lt;?php
//
// DELETE FROM round_table
//     WHERE first_name = "Patsy"
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

$where = $db-&gt;quoteInto('first_name = ?', 'Patsy');

$rows_affected = $table-&gt;delete($where);
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.findbykey"></a>9.4.7. Encontrando Linhas por Chave Primária</h3></div></div></div>
<p>
            Como conveniência, você pode facilmente buscar linhas da
            tabela usando valores de chaves primárias como o método find().  Este
            método retorna um objeto Zend_Db_Table_Row se você usar find()
            passando apenas uma chave, ou um objeto Zend_Db_Table_Rowset se você
			passar para find() uma matriz com múltiplas chaves.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();

// SELECT * FROM round_table WHERE id = "1"
$row = $table-&gt;find(1);

// SELECT * FROM round_table WHERE id IN("1", "2", 3")
$rowset = $table-&gt;find(array(1, 2, 3));
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.fetchonerow"></a>9.4.8. Buscando Uma Linha</h3></div></div></div>
<p>
            Você pode facilmente usar find() para buscar uma linha pela chave primária,
			mas frequentemente você precisará adicionar várias condições quando buscar 
			uma linha.. Zend_Db_Table oferece o mpetodo fetchRow() com este objetivo.
			Chame fetchRow() passando uma cláusula WHERE (e uma cláusula ORDER opcional),
			e Zend_Db_Table retornará um objeto Zend_Db_Table_Row com o primeiro registro
			que combinar com suas condições.
        </p>
<p>
			Note que a cláusula WHERE não será protegida para você, então você 
			deve protegê-la com o objeto Zend_Db_Adapter da tabela.
        </p>
<pre class="programlisting">&lt;?php
//
// SELECT * FROM round_table
//     WHERE noble_title = "Sir"
//     AND first_name = "Robin"
//     ORDER BY favorite_color
//

class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

$where = $db-&gt;quoteInto('noble_title = ?', 'Sir')
       . $db-&gt;quoteInto('AND first_name = ?', 'Robin');

$order = 'favorite_color';

$row = $table-&gt;fetchRow($where, $order);
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.fetchmultiple"></a>9.4.9. Buscando Múltiplas Linhas</h3></div></div></div>
<p>
            Se você precisa buscar muitas linhas de uma vez, use o método
			fetchAll().  Como em fetchRow(), ele recebe cláusulas WHERE e ORDER,
            mas também valores limit-count e limit-offset para restringir
            o número de linhas retornadas.  Ele irá retornar um objeto
			Zend_Db_Table_Rowset com os registros selecionados.
        </p>
<p>
			Note que a cláusula WHERE não será protegida para você, então você 
			deve protegê-la usando o objeto Zend_Db_Adapter da tabela.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table {}

$table = new RoundTable();
$db = $table-&gt;getAdapter();

// SELECT * FROM round_table
//     WHERE noble_title = "Sir"
//     ORDER BY first_name
//     LIMIT 10 OFFSET 20

$where = $db-&gt;quoteInto('noble_title = ?', 'Sir');
$order = 'first_name';
$count = 10;
$offset = 20;

$rowset = $table-&gt;fetchRow($where, $order, $count, $offset);
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.domain-logic"></a>9.4.10. Incluindo Lógica de Domínio</h3></div></div></div>
<p>
            Como um módulo de tabela, Zend_Db_Table funciona bem para encapsular
			sua lógica de domínio particular.  Por exemplo, voc~e pode sobrescrever
			os métodos insert() e update() para manipular ou validar os dados
			submetidos antes de irem para o banco de dados.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table
{
    public function insert($data)
    {
        // add a timestamp
        if (empty($data['created_on'])) {
            $data['created_on'] = time();
        }
        return parent::insert($data);
    }

    public function update($data)
    {
        // add a timestamp
        if (empty($data['updated_on'])) {
            $data['updated_on'] = time();
        }
        return parent::update($data);
    }
}
?&gt;
        </pre>
<p>
            Do mesmo modo, você pode implementar seu próprio método find() 
			que busque registros não apenas pela chave primária.
        </p>
<pre class="programlisting">&lt;?php
class RoundTable extends Zend_Db_Table
{
    public function findAllWithName($name)
    {
        $db = $this-&gt;getAdapter();
        $where = $db-&gt;quoteInto("name = ?", $name);
        $order = "first_name";
        return $this-&gt;fetchAll($where, $order);
    }
}
?&gt;
        </pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.select.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">Acima</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.tablerow.html">Próxima</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">9.3. Zend_Db_Select </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td>
<td width="40%" align="right" valign="top"> 9.5. Zend_Db_Table_Row</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
