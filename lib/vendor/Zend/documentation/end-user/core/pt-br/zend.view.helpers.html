<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>28.4. Assistentes de Visualização (Modificadores)</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Guia de Referência do Programador">
<link rel="up" href="zend.view.html" title="Capítulo 28. Zend_View">
<link rel="prev" href="zend.view.scripts.html" title="28.3. Scripts de Visualização">
<link rel="next" href="zend.xmlrpc.html" title="Capítulo 29. Zend_XmlRpc">
<link rel="chapter" href="zend.html" title="Capítulo 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Capítulo 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Capítulo 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Capítulo 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Capítulo 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Capítulo 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Capítulo 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Capítulo 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Capítulo 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Capítulo 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Capítulo 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Capítulo 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Capítulo 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Capítulo 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Capítulo 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Capítulo 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Capítulo 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Capítulo 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Capítulo 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Capítulo 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Capítulo 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Capítulo 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Capítulo 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Capítulo 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Capítulo 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Capítulo 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Capítulo 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Capítulo 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Capítulo 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Apêndice A. Padrões de Codificação do Framework Zend para PHP">
<link rel="appendix" href="copyrights.html" title="Apêndice B. Informação de Direitos Autorais">
<link rel="index" href="the.index.html" title="Índice Remissivo">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.initial" title="28.4.1. Assistentes Padrão">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.paths" title="28.4.2. Localizando os Assistentes">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.custom" title="28.4.3. Escrevendo Assistentes Personalizados">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">28.4. Assistentes de Visualização (Modificadores)</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.view.scripts.html">Anterior</a> </td>
<th width="60%" align="center">Capítulo 28. Zend_View</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.xmlrpc.html">Próxima</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="pt-br">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.view.helpers"></a>28.4. Assistentes de Visualização (Modificadores)</h2></div></div></div>
<p>
        Em seus scripts de visualização, frequentemente é necessário a execução de certas tarefas complexas repetidas vezes; exemplo: formatar uma data, gerar um elemento de formulário, ou exibir links de acionamento.  Você pode empregar classes assistentes para executar estas tarefas para você.
    </p>
<p>
        Para usar um assistente em seu script de visualização, chame-o usando $this-&gt;helperName(). Em segundo plano, Zend_View irá carregar a classe Zend_View_Helper_HelperName, instanciá-la e chamar seu método helperName().  O objeto criado é persistente dentro do escopo da instância Zend_View e será reutilizado por todas as chamadas futuras a $this-&gt;helperName().
    </p>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.initial"></a>28.4.1. Assistentes Padrão</h3></div></div></div>
<p>
            Zend_View vem com um conjunto padrão de assistentes, todos dedicados à geração de elementos de formulários. Cada um deles automaticamente escapa a saída apropriada. São eles:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                formButton($name, $value, $attribs): Cria um elemento &lt;input type="button" /&gt;.
            </p></li>
<li><p>
                formCheckbox($name, $value, $attribs, $options): Cria um elemento &lt;input type="checkbox" /&gt;.  O parâmetro $options é um array cujo primeiro valor é o valor "checked" e o segundo é o valor "unchecked" (os valores padrão são '1' e '0').  O controle sera preselecionado de acordo com o conteúdo de $value.
            </p></li>
<li><p>
                formFile($name, $value, $attribs): Cria um elemento &lt;input type="file" /&gt;.
                </p></li>
<li><p>
                formHidden($name, $value, $attribs): Cria um elemento &lt;input type="hidden" /&gt;.
            </p></li>
<li><p>
                formPassword($name, $value, $attribs): Cria um elemento &lt;input type="password" /&gt;.
            </p></li>
<li><p>
                formRadio($name, $value, $attribs, $options): Cria uma série de elementos &lt;input type="radio" /&gt;, um para cada elemento em $options.  No array $options, a chave e seu valor estão associados ao valor do controle e seu rótulo, respecitvamente. O conteúdo de $value será preselecionado.
            </p></li>
<li><p>
                formReset($name, $value, $attribs): Cria um elemento &lt;input type="reset" /&gt;.
            </p></li>
<li><p>
                formSelect($name, $value, $attribs, $options): Cria um bloco &lt;select&gt;...&lt;/select&gt;, com um &lt;option&gt;para elemento em $options.  No array $options, a chave e seu valor estão associados ao valor do controle e seu rótulo.  O conteúdo de $value será preselecionado.
            </p></li>
<li><p>
                formSubmit($name, $value, $attribs): Cria um elemento &lt;input type="submit" /&gt;.
            </p></li>
<li><p>
                formText($name, $value, $attribs): Cria um elemento &lt;input type="text" /&gt;.
            </p></li>
<li><p>
                formTextarea($name, $value, $attribs): Cria um bloco &lt;textarea&gt;...&lt;/textarea&gt;.
            </p></li>
</ul></div>
<p>
            Utilizar estes assistentees em seus scripts de visualização é muito fácil, aqui está um exemplo. Note que tudo que você necessita fazer é chamá-los; eles carregam e instanciam a sí próprios a medida que tornam-se necessários.
        </p>
<pre class="programlisting">&lt;?php
// dentro do seu script de visualização, $this aponta para a instância de Zend_View.
// digamos que você já atribuiu uma serie de valores ao array 
// $countries = array('us' =&gt; 'United States', 'il' =&gt;'Israel', 'de' =&gt; 'Germany').
?&gt;
&lt;form action="action.php" method="post"&gt;
    &lt;p&gt;&lt;label&gt;Your Email:
        &lt;?php echo $this-&gt;formText('email', 'you@example.com', array('size' =&gt; 32)) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Your Country:
        &lt;?php echo $this-&gt;formSelect('country', 'us', null, $this-&gt;countries) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Would you like to opt in?
        &lt;?php echo $this-&gt;formCheckbox('opt_in', 'yes', null, array('yes', 'no') ?&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
        </pre>
<p>
            A saída resultante do script de visualização deverá se parecer com isto:
        </p>
<pre class="programlisting">&lt;form action="action.php" method="post"&gt;
    &lt;p&gt;&lt;label&gt;Your Email:
        &lt;input type="text" name="email" value="you@example.com" size="32" /&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Your Country:
        &lt;select name="country"&gt;
            &lt;option value="us" selected="selected"&gt;United States&lt;/option&gt;
            &lt;option value="il"&gt;Israel&lt;/option&gt;
            &lt;option value="de"&gt;Germany&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Would you like to opt in?
        &lt;input type="hidden" name="opt_in" value="no" /&gt;
        &lt;input type="checkbox" name="opt_in" value="yes" checked="checked" /&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.paths"></a>28.4.2. Localizando os Assistentes</h3></div></div></div>
<p>
            Assim como os scripts de visualização, seu controlador pode especificar uma lista de caminhos onde o Zend_View deve procurar pelas classes assistentes. Por padrão, Zend_View procura pelas classes assistentes em  "Zend/View/Helper/*". Você pode instruir o Zend_View a procurar em outros locais usando os métodos setHelperPath() e addHelperPath().
        </p>
<pre class="programlisting">&lt;?php
$view = new Zend_View();
$view-&gt;setHelperPath('/path/to/more/helpers');
?&gt;
        </pre>
<p>
            De fato, você pode "empilhar" caminhos usando o método addHelperPath(). A medida que você adiciona caminhos à pilha,  Zend_View procurará no caminho mais recentemente adicionado.  Isto permite a você incrementar o conjunto original de assistentes (ou susbstituir) com os seus próprios personalizados.
        </p>
<pre class="programlisting">&lt;?php
$view = new Zend_View();
$view-&gt;addHelperPath('/path/to/some/helpers');
$view-&gt;addHelperPath('/other/path/to/helpers');

// now when you call $this-&gt;helperName(), Zend_View will look first for
// "/other/path/to/helpers/HelperName.php", then for
// "/path/to/some/helpers/HelperName", and finally for
// "Zend/View/Helpers/HelperName.php".
?&gt;
        </pre>
</div>
<div class="sect2" lang="pt-br">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.custom"></a>28.4.3. Escrevendo Assistentes Personalizados</h3></div></div></div>
<p>
            Escrever assistentes personalizados é fácil; basta seguir estas regras:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                O nome da classe deve ser no formato Zend_View_Helper_*, onde * é o nome do assistente a ser criado.  Ex:, se você criar um assistente chamado "specialPurpose", o nome da classe deverá ser "Zend_View_Helper_SpecialPurpose" (Observe a capitalização).
            </p></li>
<li><p>
                A classe deve ter um método público que coincida com o nome do assistente; este é o método que será chamado quando o seu template chamar "$this-&gt;specialPurpose()".  Em nosso exemplo "specialPurpose", o método requerido deverá ser declarado como "public function specialPurpose()". 
            </p></li>
<li><p>
                Em geral, a classe não deve ecoar ou imprimir a saída gerada.  Em lugar disso, ela deve retornar os valores a serem impressos. Os valores retornados deverão estar devidamente escapados.
            </p></li>
<li><p>
                A classe deve estar no arquivo chamado após o método assistente. Voltando ao exemplo "specialPurpose", o arquivo rebeu o nome "SpecialPurpose.php".
            </p></li>
</ul></div>
<p>
            Localize o arquivo com a classe assistente em algum dos caminhos armazenados na pilha, e o Zend_View automaticamente irá carregar, instanciar, persistir, e executar o código para você.
        </p>
<p>
            Aqui está um exemplo do assistente SpecialPurpose:
        </p>
<pre class="programlisting">&lt;?php
class Zend_View_Helper_SpecialPurpose {
    protected $_count = 0;
    public function specialPurpose()
    {
        $this-&gt;_count++;
        $output = "I have seen 'The Jerk' {$this-&gt;_count} time(s).";
        return htmlspecialchars($output);
    }
}
?&gt;
        </pre>
<p>
            Em um script de visualização, você pode chamar o assistente SpecialPurpose helper quantas vezes desejar; ele será instanciado apenas uma vez; e persistirá durante todo o tempo de vida da instãncia de Zend_View.
        </p>
<pre class="programlisting">&lt;?php
// remember, in a view script, $this refers to the Zend_View instance.
echo $this-&gt;specialPurpose();
echo $this-&gt;specialPurpose();
echo $this-&gt;specialPurpose();
?&gt;
        </pre>
<p>
            A saída deverá se parecer com isto:
        </p>
<pre class="programlisting">I have seen 'The Jerk' 1 time(s).
I have seen 'The Jerk' 2 time(s).
I have seen 'The Jerk' 3 time(s).
        </pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.view.scripts.html">Anterior</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.view.html">Acima</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.xmlrpc.html">Próxima</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">28.3. Scripts de Visualização </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td>
<td width="40%" align="right" valign="top"> Capítulo 29. Zend_XmlRpc</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
