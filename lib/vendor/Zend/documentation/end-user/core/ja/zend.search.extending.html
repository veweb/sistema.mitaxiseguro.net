<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>22.7. 拡張性</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="プログラマ向けリファレンスガイド">
<link rel="up" href="zend.search.html" title="第22章 Zend_Search">
<link rel="prev" href="zend.search.charset.html" title="22.6. 文字セット">
<link rel="next" href="zend.search.java-lucene.html" title="22.8. Java Lucene との相互運用">
<link rel="chapter" href="zend.html" title="第1章 Zend">
<link rel="chapter" href="zend.acl.html" title="第2章 Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="第3章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第4章 Zend_Cache">
<link rel="chapter" href="zend.config.html" title="第5章 Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="第6章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第7章 Zend_Controller">
<link rel="chapter" href="zend.date.html" title="第8章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第9章 Zend_Db">
<link rel="chapter" href="zend.feed.html" title="第10章 Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="第11章 Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="第12章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第13章 Zend_Http">
<link rel="chapter" href="zend.json.html" title="第14章 Zend_Json">
<link rel="chapter" href="zend.locale.html" title="第15章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第16章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第17章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第18章 Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="第19章 Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="第20章 Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="第21章 Zend_Rest">
<link rel="chapter" href="zend.search.html" title="第22章 Zend_Search">
<link rel="chapter" href="zend.server.html" title="第23章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第24章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第25章 Zend_Session">
<link rel="chapter" href="zend.uri.html" title="第26章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第27章 Zend_Validate">
<link rel="chapter" href="zend.view.html" title="第28章 Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="第29章 Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="付録 A. Zend Framework PHP 標準コーディング規約">
<link rel="appendix" href="copyrights.html" title="付録 B. 著作権に関する情報">
<link rel="index" href="the.index.html" title="目次">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.analysis" title="22.7.1. テキスト解析">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.filters" title="22.7.2. トークンのフィルタリング">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.scoring" title="22.7.3. 重み付けのアルゴリズム">
<link rel="subsection" href="zend.search.extending.html#zend.search.extending.storage" title="22.7.4. 保存先">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">22.7. 拡張性</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.search.charset.html">前のページ</a> </td>
<th width="60%" align="center">第22章 Zend_Search</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.search.java-lucene.html">次のページ</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="ja">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.search.extending"></a>22.7. 拡張性</h2></div></div></div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.analysis"></a>22.7.1. テキスト解析</h3></div></div></div>
<p>
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer</code> クラスは、
            ドキュメントのテキストフィールドをトークン化 (単語に分解)
            するために、インデクサによって使用されます。
        </p>
<p>
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer::getDefault()</code> および
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer::setDefault()</code> 
            メソッドで、デフォルトの解析器を取得あるいは設定します。
        </p>
<p>
            したがって、独自のテキスト解析器を指定したり、
            定義済みの解析器である
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text</code> および
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive</code> (デフォルト)
            の中から選んだものを指定したりできることになります。
            これらの解析器はどちらもトークンを文字列として解釈しますが、
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive</code>
            はトークンを小文字に変換します。
        </p>
<p>
            解析器を変更するには、以下のようにします。
        </p>
<pre class="programlisting">&lt;?php

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new Zend_Search_Lucene_Analysis_Analyzer_Common_Text());
...
$index-&gt;addDocument($doc);

?&gt;</pre>
<p>
            ユーザ定義の解析器のための共通の親クラスとして設計されているのが
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common</code> です。
            ユーザが定義しなければならないのは <code class="code">reset()</code> および
            <code class="code">nextToken()</code> メソッドのみで、
            これは文字列を $_input から受け取って順に返します
            (<code class="code">null</code> が最後のデータを表します)。
        </p>
<p>
            <code class="code">nextToken()</code> メソッドでは、各トークンに対して
            <code class="code">normalize()</code> メソッドを適用しなければなりません。
            これにより、作成した解析器をトークンフィルタとして使用できるようになります。
        </p>
<p>
            独自のテキスト解析器の例を示します。
            これは、数字つきの単語をひとつの言葉として扱います。

            </p>
<div class="example">
<a name="id4887845"></a><p class="title"><b>例 22.1. 独自のテキスト解析器</b></p>
<pre class="programlisting">&lt;?php
/** これは独自のテキスト解析器で、数字つきの単語をひとつの言葉として扱います */


/** Zend_Search_Lucene_Analysis_Analyzer_Common */
require_once 'Zend/Search/Lucene/Analysis/Analyzer/Common.php';

class My_Analyzer extends Zend_Search_Lucene_Analysis_Analyzer_Common
{
    private $_position;

    /**
     * トークンストリームをリセットします
     */
    public function reset()
    {
        $this-&gt;_position = 0;
    }

    /**
     * トークンストリーム API
     * 次のトークンを取得します。
     * ストリームの最後に達すると null を返します。
     *
     * @return Zend_Search_Lucene_Analysis_Token|null
     */
    public function nextToken()
    {
        if ($this-&gt;_input === null) {
            return null;
        }

        while ($this-&gt;_position &lt; strlen($this-&gt;_input)) {
            // 空白を読み飛ばします
            while ($this-&gt;_position &lt; strlen($this-&gt;_input) &amp;&amp;
                   !ctype_alnum( $this-&gt;_input[$this-&gt;_position] )) {
                $this-&gt;_position++;
            }

            $termStartPosition = $this-&gt;_position;

            // トークンを読み込みます
            while ($this-&gt;_position &lt; strlen($this-&gt;_input) &amp;&amp;
                   ctype_alnum( $this-&gt;_input[$this-&gt;_position] )) {
                $this-&gt;_position++;
            }

            // 空のトークン、あるいはストリームが終了
            if ($this-&gt;_position == $termStartPosition) {
                return null;
            }

            $token = new Zend_Search_Lucene_Analysis_Token(
                                      substr($this-&gt;_input,
                                             $termStartPosition,
                                             $this-&gt;_position - $termStartPosition),
                                      $termStartPosition,
                                      $this-&gt;_position);
            $token = $this-&gt;normalize($token);
            if ($token !== null) {
                return $token;
            }
            // トークンがスキップされた場合は継続します
        }

        return null;
    }
}

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new My_Analyzer());

?&gt;</pre>
</div>
<p>
        </p>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.filters"></a>22.7.2. トークンのフィルタリング</h3></div></div></div>
<p>
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common</code>
            解析器には、トークンをフィルタリングする仕組みもあります。
            mechanism.
        </p>
<p>
            <code class="code">Zend_Search_Lucene_Analysis_TokenFilter</code>
            クラスは、このフィルタリングの仕組みを抽象化したものです。
            自分でフィルタを作成する際には、これを継承します。
        </p>
<p>
            独自に作成するフィルタは、
            <code class="code">normalize()</code> メソッドを実装する必要があります。
            このメソッドは、入力トークンを変換したり
            トークンを読み飛ばす指示を出したりします。
        </p>
<p>
            Analysis のサブパッケージとして、これらの三つのフィルタが定義されています。
            </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                        <code class="code">Zend_Search_Lucene_Analysis_TokenFilter_LowerCase</code> フィルタ
                    </p></li>
<li><p>
                        <code class="code">Zend_Search_Lucene_Analysis_TokenFilter_ShortWords</code> フィルタ
                    </p></li>
<li><p>
                        <code class="code">Zend_Search_Lucene_Analysis_TokenFilter_StopWords</code> フィルタ
                    </p></li>
</ul></div>
<p>
        </p>
<p>
            <code class="code">LowerCase</code> フィルタは、既に
            <code class="code">Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive</code>
            解析器で使用されています。これはデフォルトの解析器です。
        </p>
<p>
            <code class="code">ShortWords</code> および <code class="code">StopWords</code>
            は、定義済み解析器あるいは独自の解析器でこのように使用します。
            </p>
<pre class="programlisting">&lt;?php
$stopWords = array('a', 'an', 'at', 'the', 'and', 'or', 'is', 'am');
$stopWordsFilter = new Zend_Search_Lucene_Analysis_TokenFilter_StopWords($stopWords);

$analyzer = new Zend_Search_Lucene_Analysis_Analyzer_Common_TextNum_CaseInsensitive();
$analyzer-&gt;addFilter($stopWordsFilter);

Zend_Search_Lucene_Analysis_Analyzer::setDefault($analyzer);
?&gt;</pre>
<p>
            </p>
<pre class="programlisting">&lt;?php
$shortWordsFilter = new Zend_Search_Lucene_Analysis_TokenFilter_ShortWords();

$analyzer = new Zend_Search_Lucene_Analysis_Analyzer_Common_TextNum_CaseInsensitive();
$analyzer-&gt;addFilter($shortWordsFilter);

Zend_Search_Lucene_Analysis_Analyzer::setDefault($analyzer);
?&gt;</pre>
<p>
        </p>
<p>
            <code class="code">Zend_Search_Lucene_Analysis_TokenFilter_StopWords</code>
            のコンストラクタには、禁止単語の配列を入力として渡します。
            この禁止単語はファイルから読み込ませることもできます。
            </p>
<pre class="programlisting">&lt;?php
$stopWordsFilter = new Zend_Search_Lucene_Analysis_TokenFilter_StopWords();
$stopWordsFilter-&gt;loadFromFile($my_stopwords_file);

$analyzer = new Zend_Search_Lucene_Analysis_Analyzer_Common_TextNum_CaseInsensitive();
$analyzer-&gt;addFilter($stopWordsFilter);

Zend_Search_Lucene_Analysis_Analyzer::setDefault($analyzer);
?&gt;</pre>
<p>
            ファイル形式は一般的なテキストファイルで、各文字列にひとつの単語が含まれるものとなります。
            '#' を指定すると、その文字列はコメントであるとみなします。
        </p>
<p>
            <code class="code">Zend_Search_Lucene_Analysis_TokenFilter_ShortWords</code>
            のコンストラクタには、オプションの引数をひとつ指定することができます。
            これは単語長の制限を表し、デフォルト値は 2 です。
        </p>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.scoring"></a>22.7.3. 重み付けのアルゴリズム</h3></div></div></div>
<p>
            クエリ <code class="literal">q</code> の、ドキュメント <code class="literal">d</code>
            に対するスコアは以下のように定義されます。
        </p>
<p>
            <code class="code">score(q,d) = sum( tf(t in d) * idf(t) * getBoost(t.field in d) * lengthNorm(t.field in d)  ) *
            coord(q,d) * queryNorm(q)</code>
        </p>
<p>
            tf(t in d) - <code class="code">Zend_Search_Lucene_Search_Similarity::tf($freq)</code> -
            ドキュメント内での単語あるいは熟語の出現頻度に基づく重み要素。
        </p>
<p>
            idf(t) - <code class="code">Zend_Search_Lucene_Search_SimilaritySimilarity::tf($term, $reader)</code> -
            指定したインデックスに対する単純な単語の重み要素。
        </p>
<p>
            getBoost(t.field in d) - 単語のフィールドの重み。
        </p>
<p>
            lengthNorm($term) - フィールド内に含まれる単語の総数を正規化した値。
            この値はインデックスに保存されます。
            これらの値はフィールドの重みとともにインデックスに保存され、
            検索コードによってヒットした各フィールドのスコアに掛けられます。
        </p>
<p>
            長いフィールドでマッチした場合は、あまり的確であるとはいえません。
            そのため、このメソッドの実装は通常、
            numTokens が大きいときにはより小さな値、
            numTokens が小さいときにはより大きな値を返すようになっています。
        </p>
<p>
            coord(q,d) - <code class="code">Zend_Search_Lucene_Search_Similarity::coord($overlap, $maxOverlap)</code> -
            ドキュメントに含まれる、検索対象の全単語の部分一致に基づく重み要素。
        </p>
<p>
            検索対象の単語のより多くの部分が存在しているほど、
            検索結果としてよいものであるといえます。そのため、このメソッドの実装は通常、
            これらのパラメータの割合が大きいときにはより大きな値、
            割合が小さいときにはより小さな値を返すようになっています。
        </p>
<p>
            queryNorm(q) -
            検索対象の各単語の重みの二乗の和で与えられる、クエリの正規化値。
            この値は、検索対象の各単語の重みに掛けられます。
        </p>
<p>
            これは重み付けには影響しません。単に別のクエリの結果との差をなくすために使用されます。
        </p>
<p>
            重み付けのアルゴリズムを変更するには、独自の Similatity
            クラスを定義します。そのためには以下のように
            Zend_Search_Lucene_Search_Similarity クラスを継承し、
            <code class="code">Zend_Search_Lucene_Search_Similarity::setDefault($similarity);</code>
            メソッドでそれをデフォルトとして設定します。
        </p>
<pre class="programlisting">&lt;?php

class MySimilarity extends Zend_Search_Lucene_Search_Similarity {
    public function lengthNorm($fieldName, $numTerms) {
        return 1.0/sqrt($numTerms);
    }

    public function queryNorm($sumOfSquaredWeights) {
        return 1.0/sqrt($sumOfSquaredWeights);
    }

    public function tf($freq) {
        return sqrt($freq);
    }

    /**
     * 現在は使用しません。曖昧検索の曖昧度を計算します。
     */
    public function sloppyFreq($distance) {
        return 1.0;
    }

    public function idfFreq($docFreq, $numDocs) {
        return log($numDocs/(float)($docFreq+1)) + 1.0;
    }

    public function coord($overlap, $maxOverlap) {
        return $overlap/(float)$maxOverlap;
    }
}

$mySimilarity = new MySimilarity();
Zend_Search_Lucene_Search_Similarity::setDefault($mySimilarity);

?&gt;</pre>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.search.extending.storage"></a>22.7.4. 保存先</h3></div></div></div>
<p>
        抽象クラス Zend_Search_Lucene_Storage_Directory では、ディレクトリ機能を提供しています。
        </p>
<p>
        Zend_Search_Lucene のコンストラクタでは、文字列あるいは
        Zend_Search_Lucene_Storage_Directory オブジェクトを入力として使用します。
        </p>
<p>
        Zend_Search_Lucene_Storage_Directory_Filesystem クラスは、
        ファイルシステム用のディレクトリ機能を実装しています。
        </p>
<p>
        Zend_Search_Lucene コンストラクタの入力に文字列を使用すると、
        インデックスリーダ (Zend_Search_Lucene オブジェクト) 
        はそれをファイルシステムのパスと解釈し、
        Zend_Search_Lucene_Storage_Directory_Filesystem
        オブジェクトのインスタンスを作成します。
        </p>
<p>
        独自のディレクトリ機能を実装するには、
        Zend_Search_Lucene_Storage_Directory クラスを継承します。
        </p>
<p>
        Zend_Search_Lucene_Storage_Directory のメソッドは以下のとおりです。
        </p>
<pre class="programlisting">&lt;?php

abstract class Zend_Search_Lucene_Storage_Directory {
/**
 * 保存先を閉じます
 *
 * @return void
 */
abstract function close();


/**
 * $filename という名前の新しい空のファイルを、ディレクトリ内に作成します
 *
 * @param string $name
 * @return void
 */
abstract function createFile($filename);


/**
 * 既存の $filename をディレクトリから削除します
 *
 * @param string $filename
 * @return void
 */
abstract function deleteFile($filename);


/**
 * $filename で指定したファイルが存在する場合に true を返します
 *
 * @param string $filename
 * @return boolean
 */
abstract function fileExists($filename);


/**
 * ディレクトリ内の $filename の長さを返します
 *
 * @param string $filename
 * @return integer
 */
abstract function fileLength($filename);


/**
 * $filename の最終更新日時を UNIX タイムスタンプで返します
 *
 * @param string $filename
 * @return integer
 */
abstract function fileModified($filename);


/**
 * ディレクトリ内の既存のファイルの名前を変更します
 *
 * @param string $from
 * @param string $to
 * @return void
 */
abstract function renameFile($from, $to);


/**
 * $filename の更新時刻を現在の時刻にします
 *
 * @param string $filename
 * @return void
 */
abstract function touchFile($filename);


/**
 * ディレクトリ内の $filename についての
 * Zend_Search_Lucene_Storage_File オブジェクトを返します
 *
 * @param string $filename
 * @return Zend_Search_Lucene_Storage_File
 */
abstract function getFileObject($filename);

}

?&gt;</pre>
<p>
        Zend_Search_Lucene_Storage_Directory クラスの
        <code class="code">getFileObject($filename)</code> メソッドは、
        Zend_Search_Lucene_Storage_File オブジェクトを返します。
        </p>
<p>
        抽象クラス Zend_Search_Lucene_Storage_File では、
        ファイルの抽象化およびインデックスファイルの基本的な読み込み機能を実装しています。
        </p>
<p>
        ディレクトリ機能を実装するには Zend_Search_Lucene_Storage_File
        クラスを継承しなければなりません。
        </p>
<p>
        Zend_Search_Lucene_Storage_File クラスを実装する際に
        オーバーロードしなければならないメソッドは 2 つだけです。
        </p>
<pre class="programlisting">&lt;?php

class MyFile extends Zend_Search_Lucene_Storage_File {
    /**
     * ファイル上の位置を指定し、そこにファイルポインタを進めます。
     * 新しい位置は、whence で指定した場所からオフセットのバイト数だけ
     * 進めた位置になります。whence に指定できる値は以下のいずれかです。
     * SEEK_SET - 先頭からオフセット分進めた位置に移動します。
     * SEEK_CUR - 現在位置からオフセット分だけ進めた位置に移動します。
     * SEEK_END - ファイルの終端からオフセット分だけ進めた位置に移動します。
     * (ファイルの終端から戻った位置を指定するには、オフセットに負の値を
     * 指定する必要があります)
     * 成功した場合に 0、それ以外の場合に -1 を返します。
     *
     * @param integer $offset
     * @param integer $whence
     * @return integer
     */
    public function seek($offset, $whence=SEEK_SET) {
        ...
    }

    /**
     * ファイルから $length バイトを読み込み、ファイルポインタを進めます。
     *
     * @param integer $length
     * @return string
     */
    protected function _fread($length=1) {
        ...
    }
}

?&gt;</pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.search.charset.html">前のページ</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.search.html">上に戻る</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.search.java-lucene.html">次のページ</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">22.6. 文字セット </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td>
<td width="40%" align="right" valign="top"> 22.8. Java Lucene との相互運用</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
