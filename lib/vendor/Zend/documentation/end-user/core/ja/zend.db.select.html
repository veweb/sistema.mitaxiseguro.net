<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>9.3. Zend_Db_Select</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="プログラマ向けリファレンスガイド">
<link rel="up" href="zend.db.html" title="第9章 Zend_Db">
<link rel="prev" href="zend.db.profiler.html" title="9.2. Zend_Db_Profiler">
<link rel="next" href="zend.db.table.html" title="9.4. Zend_Db_Table">
<link rel="chapter" href="zend.html" title="第1章 Zend">
<link rel="chapter" href="zend.acl.html" title="第2章 Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="第3章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第4章 Zend_Cache">
<link rel="chapter" href="zend.config.html" title="第5章 Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="第6章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第7章 Zend_Controller">
<link rel="chapter" href="zend.date.html" title="第8章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第9章 Zend_Db">
<link rel="chapter" href="zend.feed.html" title="第10章 Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="第11章 Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="第12章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第13章 Zend_Http">
<link rel="chapter" href="zend.json.html" title="第14章 Zend_Json">
<link rel="chapter" href="zend.locale.html" title="第15章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第16章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第17章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第18章 Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="第19章 Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="第20章 Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="第21章 Zend_Rest">
<link rel="chapter" href="zend.search.html" title="第22章 Zend_Search">
<link rel="chapter" href="zend.server.html" title="第23章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第24章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第25章 Zend_Session">
<link rel="chapter" href="zend.uri.html" title="第26章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第27章 Zend_Validate">
<link rel="chapter" href="zend.view.html" title="第28章 Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="第29章 Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="付録 A. Zend Framework PHP 標準コーディング規約">
<link rel="appendix" href="copyrights.html" title="付録 B. 著作権に関する情報">
<link rel="index" href="the.index.html" title="目次">
<link rel="subsection" href="zend.db.select.html#zend.db.select.introduction" title="9.3.1. 導入">
<link rel="subsection" href="zend.db.select.html#zend.db.select.fromcols" title="9.3.2. テーブルからのカラムの取得">
<link rel="subsection" href="zend.db.select.html#zend.db.select.joincols" title="9.3.3. JOIN されたテーブルからのカラムの取得">
<link rel="subsection" href="zend.db.select.html#zend.db.select.where" title="9.3.4. WHERE 条件">
<link rel="subsection" href="zend.db.select.html#zend.db.select.group" title="9.3.5. GROUP BY 句">
<link rel="subsection" href="zend.db.select.html#zend.db.select.having" title="9.3.6. HAVING 条件">
<link rel="subsection" href="zend.db.select.html#zend.db.select.order" title="9.3.7. ORDER BY 句">
<link rel="subsection" href="zend.db.select.html#zend.db.select.limit" title="9.3.8. 件数やオフセットによる制限">
<link rel="subsection" href="zend.db.select.html#zend.db.select.paging" title="9.3.9. ページ数や件数による制限">
<link rel="subsection" href="zend.db.select.html#id4825926" title="9.3.10. その他のメソッド">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">9.3. Zend_Db_Select</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.db.profiler.html">前のページ</a> </td>
<th width="60%" align="center">第9章 Zend_Db</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.db.table.html">次のページ</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="ja">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.select"></a>9.3. Zend_Db_Select</h2></div></div></div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.introduction"></a>9.3.1. 導入</h3></div></div></div>
<p>
            Zend_Db_Select は、データベースに依存しない方法で
            SQL の SELECT 文を作成するのを助けるためのツールです。
            もちろん完璧なものだとはいえませんが、
            クエリの移植性を高めることを助けるのに貢献するでしょう。
            さらに、クエリを SQL インジェクション攻撃から守ることも助けます。
        </p>
<p>
            Zend_Db_Select のインスタンスを生成する一番簡単な方法は、
            Zend_Db_Adapter::select() メソッドを使用することです。
        </p>
<pre class="programlisting">&lt;?php
	
require_once 'Zend/Db.php';

$params = array (
    'host'     =&gt; '127.0.0.1',
    'username' =&gt; 'malory',
    'password' =&gt; '******',
    'dbname'   =&gt; 'camelot'
);

$db = Zend_Db::factory('PDO_MYSQL', $params);

$select = $db-&gt;select();
// $select は、PDO_MYSQL アダプタでのみ使用可能なように設定された
// Zend_Db_Select オブジェクトとなります

?&gt;</pre>
<p>
            それから、このオブジェクトとメソッドを使用して
            SELECT クエリを作成し、Zend_Db_Adapter
            がクエリやデータ取得に使用するための文字列を作成します。
        </p>
<pre class="programlisting">&lt;?php
	
//
// SELECT round_table.*
// FROM `round_table` round_table
// WHERE `noble_title` = 'Sir'
// ORDER BY `first_name`
// LIMIT 10 OFFSET 20
//

// 順に指定していくこともできますし、
$select-&gt;from('round_table');
$select-&gt;where('noble_title = ?', 'Sir');
$select-&gt;order('first_name');
$select-&gt;limit(10,20);

// 一連の流れで指定することもできます
$select-&gt;from('round_table')
       -&gt;where('noble_title = ?', 'Sir')
       -&gt;order('first_name')
       -&gt;limit(10,20);

// 結果を取得します
$sql = $select-&gt;__toString();
$result = $db-&gt;fetchAll($sql);

// 別のやり方として、$select オブジェクト自身を渡すこともできます。
$result = $db-&gt;fetchAll($select);

// もうひとつの方法は、$select オブジェクトから直接 Zend_Db_Statement
// や PDOStatement を作成するものです。
$stmt = $select-&gt;query();
$result = $stmt-&gt;fetchAll();

?&gt;</pre>
<p>
            その都度クォートする代わりに、
            クエリの中でバインドパラメータを使用することもできます。
        </p>
<pre class="programlisting">&lt;?php
	
//
// SELECT round_table.*
// FROM `round_table` round_table
// WHERE noble_title = 'Sir'
// ORDER BY `first_name`
// LIMIT 10 OFFSET 20
//

$select-&gt;from('round_table', '*')
       -&gt;where('noble_title = :title')
       -&gt;order('first_name')
       -&gt;limit(10,20);

// バインドパラメータを使用して結果を取得します
$params = array('title' =&gt; 'Sir');
$result = $db-&gt;fetchAll($select, $params);

?&gt;</pre>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.fromcols"></a>9.3.2. テーブルからのカラムの取得</h3></div></div></div>
<p>
            指定したテーブルからカラムを SELECT するには、
            from() メソッドを使用してテーブル名とカラムを指定します。
            テーブル名およびカラムのどちらについてもエイリアスを使用することが可能で、
            何度でも必要なだけ from() を使用することができます。
        </p>
<pre class="programlisting">&lt;?php
	
// $db オブジェクトを作成します。ここでは Mysql アダプタを使用しているとします。
$select = $db-&gt;select();

// SELECT some_table.`a`, some_table.`b`, some_table.`c`
// FROM `some_table` some_table

$select-&gt;from('some_table', array('a', 'b', 'c'));

// SELECT bar.`col`
// FROM `foo` bar

$select-&gt;from(array('foo' =&gt; 'bar'), 'col');

?&gt;</pre>
<p>
            from() メソッドの二番目の引数は、
            カラム名を表すスカラー値あるいは複数のカラム名の配列となります。
            スカラーの値あるいは配列の要素は文字列で、
            これがカラム名として解釈されます。そして、
            クォートされてテーブルのエイリアスが前につけられます。
            二番目の引数を省略した場合のデフォルトは <code class="code">'*'</code>
            となります。これはクォートされませんが、
            前にテーブルのエイリアスがつなげられます。
            このテーブルからは結果セットにカラムを取得したくない場合は、
            空の <code class="code">array()</code> を使用します。
        </p>
<p>
            複数のカラムを、ひとつの文字列でカンマ区切りで指定することはやめましょう。
            以前のプレビュー版の Zend_Db で用いられていたこの形式は、
            現在はサポートしていません。配列形式を使用してください。
        </p>
<p>
            テーブルのエイリアスは、第二引数のすべての文字列要素に付加されます。
            しかし、その要素が Zend_Db_Expr 型のオブジェクトだった場合は、
            その文字列値をそのまま使用します。
            クォート処理やテーブルエイリアスの付加は行いません。
        </p>
<pre class="programlisting">&lt;?php

$select = $db-&gt;select();

// SELECT foo.col AS col1, bar.col AS col2
// FROM foo, bar
$select-&gt;from('foo', array(
    new Zend_Db_Expr('foo.col AS col1'),
    new Zend_Db_Expr('CURDATE()')
);
$select-&gt;from('bar', new Zend_Db_Expr('bar.col AS col2'));

?&gt;</pre>
<p>
            連想配列を用いて、テーブルのエイリアスを指定します。
            テーブル名がキー、そしてその値がエイリアスとなります。
            連想配列ではなく通常の文字列としてエイリアスを指定した場合は、
            Zend_Db_Select がテーブルエイリアスを作成します。
            デフォルトでは、作成されるテーブルエイリアスはそのテーブル名と同じになります。
            つまり、まるで SQL クエリを
            "<code class="code">SELECT foo.* FROM `foo` foo</code>"
            のように書いたのと同じことになります。
            同じテーブルを複数回使用した場合、たとえば自己結合などの場合は、
            Zend_Db_Select は各テーブルに対して一意なエイリアスを宣言します。つまり
            "<code class="code">foo_1</code>"、"<code class="code">foo_2</code>" といったようになります。
        </p>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.joincols"></a>9.3.3. JOIN されたテーブルからのカラムの取得</h3></div></div></div>
<p>
            連結したテーブルからカラムを取得するには join() メソッドを使用します。
            まず連結するテーブル名、次に連結の条件、
            そして最後に連結したテーブルから取得したいカラムを指定します。
            何度でも必要なだけ join() を使用することができます。
        </p>
<pre class="programlisting">&lt;?php
	
// $db オブジェクトを作成します。ここでは Mysql アダプタを使用しているとします。
$select = $db-&gt;select();

// SELECT foo.*, bar.*
// FROM `foo` foo
// JOIN `bar` bar ON foo.id = bar.id

$select-&gt;from('foo');
$select-&gt;join('bar', 'foo.id = bar.id');

?&gt;</pre>
<p>
            join() メソッドの最初の引数で、テーブルを指定します。
            これは from() メソッドの最初の引数と同じ形式です。つまり
            テーブル名を表す文字列、あるいはテーブル名とエイリアス名を
            対応させた連想配列となります。
        </p>
<p>
            join() メソッドの二番目の引数は、結合条件となる式です。
            ここではテーブルのエイリアスを指定できます。ただ、
            自分でエイリアスを指定しない限りは Zend_Db_Select
            が自動的にエイリアスを作成することに注意しましょう。
            結合条件を省略した場合は、CROSS JOIN
            あるいはデカルト積と同等の扱いとなります。
        </p>
<p>
            join() メソッドの三番目の引数は、
            結合するテーブルのカラムの中で select 結果に含めるものを指定します。
            これは from() メソッドの二番目の引数と同じ形式です。つまり
            カラム名を表すスカラー値あるいは複数のカラム名の配列となります。
            各スカラー値は、文字列あるいは
            Zend_Db_Expr 型のオブジェクトとなります。
            この引数を省略した場合のデフォルトは <code class="code">'*'</code> です。
            このテーブルからは結果セットにカラムを取得したくない場合は、
            空の <code class="code">array()</code> を使用します。
        </p>
<p>
            複数のカラムを、ひとつの文字列でカンマ区切りで指定することはやめましょう。
            以前のプレビュー版の Zend_Db で用いられていたこの形式は、
            現在はサポートしていません。配列形式を使用してください。
        </p>
<p>
            以下の結合形式をサポートしています。
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <span><strong class="command">INNER JOIN</strong></span> は
                    <code class="code">join()</code> あるいは <code class="code">joinInner()</code>
                    メソッドで指定します。すべての RDBMS
                    でこの結合形式をサポートしています。
                </p></li>
<li><p>
                    <span><strong class="command">LEFT JOIN</strong></span> は
                    <code class="code">joinLeft()</code> メソッドで指定します。
                    すべての RDBMS でこの結合形式をサポートしています。
                </p></li>
<li><p>
                    <span><strong class="command">RIGHT JOIN</strong></span> は
                    <code class="code">joinRight()</code> メソッドで指定します。
                    RDBMS によっては、この結合形式をサポートしていないものもあります。
                </p></li>
<li><p>
                    <span><strong class="command">FULL JOIN</strong></span> は
                    <code class="code">joinFull()</code> メソッドで指定します。
                    RDBMS によっては、この結合形式をサポートしていないものもあります。
                </p></li>
<li><p>
                    <span><strong class="command">CROSS JOIN</strong></span> は
                    <code class="code">joinCross()</code> メソッドで指定します。
                    結合条件パラメータには何も指定しません。
                    RDBMS によっては、この結合形式をサポートしていないものもあります。
                </p></li>
<li><p>
                    <span><strong class="command">NATURAL JOIN</strong></span> は
                    <code class="code">joinNatural()</code> メソッドで指定します。
                    結合条件パラメータには何も指定しません。
                    自然結合とは、ふたつのテーブルの同名のカラムを連結するものです。
                    NATURAL INNER JOIN のみをサポートしています。
                </p></li>
</ul></div>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.where"></a>9.3.4. WHERE 条件</h3></div></div></div>
<p>
            WHERE 条件を追加するには、where() メソッドを使用します。通常の文字列、
            あるいは疑問符のプレースホルダを使用した文字列と代入する値
            (値は Zend_Db_Adapter::quoteInto を使用してクォートされます)
            のいずれかを渡すことができます。
        </p>
<p>
            where() を複数回使用すると、それらの条件が AND で連結されます。
            OR 条件を指定するには orWhere() を使用します。
        </p>
<pre class="programlisting">&lt;?php
	
// $db オブジェクトを作成し、SELECT ツールを取得します
$select = $db-&gt;select();

// SELECT r.*
// FROM `round_table` r
// WHERE noble_title = 'Sir'
//   AND favorite_color = 'yellow'

$select-&gt;from(array('round_table' =&gt; 'r'));
$select-&gt;where("noble_title = 'Sir'"); // 値を埋め込む形式
$select-&gt;where('favorite_color = ?', 'yellow'); // 値をクォートする形式

// SELECT foo.*
//     FROM `foo` foo
//     WHERE bar = 'baz'
//     OR id IN('1', '2', '3')

$select-&gt;from('foo');
$select-&gt;where('bar = ?', 'baz');
$select-&gt;orWhere('id IN(?)', array(1, 2, 3));

?&gt;</pre>
<p>
            Zend_Db_Select は、WHERE 句のカラムに対しては
            クォートやエイリアスの連結を適用しません。
            PHP の変数を WHERE 句の文字列として使用する場合は、
            Zend_Db_Adapter の quoteIdentifier()
            メソッドで無効な構文を防ぐようにしましょう。
        </p>
<pre class="programlisting">&lt;?php
...
$columnName = 'bar'; // あるいは、他の信頼できない入力元から設定します
$whereExpr = $db-&gt;quoteIdentifier($columnName) . ' = ?';
$select-&gt;where($whereExpr, 'baz');
?&gt;</pre>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.group"></a>9.3.5. GROUP BY 句</h3></div></div></div>
<p>
            行をグループ化するには、必要なだけ group() メソッドを使用します。
        </p>
<pre class="programlisting">&lt;?php
	
// $db オブジェクトを作成し、SELECT ツールを取得します
$select = $db-&gt;select();

// SELECT COUNT(id)
// FROM `foo` foo
// GROUP BY `bar`, `baz`

$select-&gt;from('foo', new Zend_Db_Expr('COUNT(id)'));
$select-&gt;group('bar');
$select-&gt;group('baz');

// 上と等価な group() のコール方法
$select-&gt;group(array('bar', 'baz'));

?&gt;</pre>
<p>
            複数のカラムを、ひとつの文字列でカンマ区切りで指定することはやめましょう。
            以前のプレビュー版の Zend_Db で用いられていたこの形式は、
            現在はサポートしていません。配列形式を使用してください。
        </p>
<p>
            group() の引数のすべての文字列に対してクォートが行われます。
            しかし、その要素が Zend_Db_Expr 型のオブジェクトだった場合は、
            文字列値をクォートせずにそのまま使用します。
        </p>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.having"></a>9.3.6. HAVING 条件</h3></div></div></div>
<p>
            選択した結果に HAVING 条件を追加するには、having() メソッドを使用します。
            このメソッドは where() メソッドと同じです。
        </p>
<p>
            having() を複数回使用すると、それらの条件が AND で連結されます。
            OR 条件を指定するには orHaving() を使用します。
        </p>
<pre class="programlisting">&lt;?php
	
// $db オブジェクトを作成し、SELECT ツールを取得します
$select = $db-&gt;select();

// SELECT COUNT(id) AS count_id
//     FROM `foo` foo
//     GROUP BY `bar`, `baz`
//     HAVING count_id &gt; '1'

$select-&gt;from('foo', new Zend_Db_Expr('COUNT(id) AS count_id'));
$select-&gt;group(array('bar', 'baz'));
$select-&gt;having('count_id &gt; ?', 1);

?&gt;</pre>
<p>
            Zend_Db_Select は、HAVING 句のカラムに対しては
            クォートやエイリアスの連結を適用しません。
            PHP の変数を HAVING 句の文字列として使用する場合は、
            Zend_Db_Adapter の quoteIdentifier()
            メソッドで無効な構文を防ぐようにしましょう。
        </p>
<pre class="programlisting">&lt;?php
...
$columnName = 'count_id'; // or set by an untrusted source
$havingExpr = $db-&gt;quoteIdentifier($columnName) . ' &gt; ?';
$select-&gt;having($havingExpr, 1);
?&gt;</pre>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.order"></a>9.3.7. ORDER BY 句</h3></div></div></div>
<p>
            カラムを並べ替えるには、必要なだけ order() メソッドを使用します。
        </p>
<pre class="programlisting">&lt;?php
	
// $db オブジェクトを作成し、SELECT ツールを取得します
$select = $db-&gt;select();

// SELECT r.*
// FROM `round_table` r
// ORDER BY `noble_title` DESC, `first_name` ASC

$select-&gt;from('round_table');
$select-&gt;order('noble_title DESC');
$select-&gt;order('first_name');

// 上と等価な order() のコール方法
$select-&gt;order(array('noble_title DESC', 'first_name'));

?&gt;</pre>
<p>
            複数のカラムを、ひとつの文字列でカンマ区切りで指定することはやめましょう。
            以前のプレビュー版の Zend_Db で用いられていたこの形式は、
            現在はサポートしていません。配列形式を使用してください。
        </p>
<p>
            order() の引数のすべての文字列に対してクォートが行われます。
            しかし、その要素が Zend_Db_Expr 型のオブジェクトだった場合は、
            文字列値をクォートせずにそのまま使用します。
        </p>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.limit"></a>9.3.8. 件数やオフセットによる制限</h3></div></div></div>
<p>
            Zend_Db_Select は、LIMIT 句のサポートを抽象化した機能を提供しています。
            MySQL や PostgreSQL などの多くのデータベースでは、これは比較的簡単なことです。
            というのも "LIMIT :count [OFFSET :offset]" という構文がサポートされているからです。
        </p>
<p>
            その他のデータベースの中には、ちょっと面倒なものもあります。
            というのも、これらは LIMIT 句をサポートしていないのです。
            MS-SQL は TOP 句しかサポートしていませんし、
            Microsoft SQL Server の場合は TOP 句を使用すると同じ結果が得られます。
            Oracle や DB2 は、クエリを特別な形式に書き直して LIMIT
            をエミュレートする必要があります。
            Zend_Db_Select は、データベースアダプタにあわせて SELECT
            文を適切に書き換え、LIMIT 機能を実現しています。
        </p>
<p>
            返される結果を件数とオフセットで絞り込むためには、
            件数と (オプションで) オフセットを指定して limit() を使用します。
        </p>
<pre class="programlisting">&lt;?php
	
// まずは単純な "LIMIT :count"
$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('id');
$select-&gt;limit(10);

// MySQL/PostgreSQL/SQLite では、以下のように変換されます
//
// SELECT foo.*
// FROM "foo" foo
// ORDER BY "id" ASC
// LIMIT 10
//
// しかし Microsoft SQL Server では、このようになります
//
// SELECT TOP 10 foo.*
// FROM [foo] foo
// ORDER BY [id] ASC

// 今度は、ちょっと複雑な "LIMIT :count OFFSET :offset"
$select = $db-&gt;select();
$select-&gt;from('foo', '*');
$select-&gt;order('id');
$select-&gt;limit(10, 20);

// MySQL/PostgreSQL/SQLite では、以下のように変換されます
//
// SELECT foo.*
// FROM "foo" foo
// ORDER BY "id" ASC
// LIMIT 10 OFFSET 20
//
// Microsoft SQL Server ではオフセットはサポートされていないので
// このようになります
//
// SELECT * FROM (
//     SELECT TOP 10 * FROM (
//         SELECT TOP 30 *
//         FROM [foo] foo
//         ORDER BY [id] DESC
//     ) ORDER BY id ASC
// )
//
// Zend_Db_Adapter は、クエリの変換を自動的に行います。

?&gt;</pre>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.select.paging"></a>9.3.9. ページ数や件数による制限</h3></div></div></div>
<p>
            Zend_Db_Select は、ページを基準とした制限にも対応しています。
            結果から特定の「ページ」を取得したい場合には、limitPage()
            メソッドを使用します。取得したいページ番号を最初に、
            そしてその次に 1 ページあたりの件数を指定します。
        </p>
<pre class="programlisting">&lt;?php
	
// 基本的な select を作成します
$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('id');

// そして、1 ページあたり 10 件とした場合の 3 ページ目のみを取得します
$select-&gt;limitPage(3, 10);

// MySQL/PostgreSQL/SQLite では、以下のように変換されます
//
// SELECT foo.*
// FROM `foo` foo
// ORDER BY `id` ASC
// LIMIT 10 OFFSET 20

?&gt;</pre>
</div>
<div class="sect2" lang="ja">
<div class="titlepage"><div><div><h3 class="title">
<a name="id4825926"></a>9.3.10. その他のメソッド</h3></div></div></div>
<p>
            distinct() メソッドは、DISTINCT
            キーワードを SQL クエリに追加します。
        </p>
<pre class="programlisting">&lt;?php

// SELECT DISTINCT foo.`non_unique_column`
// FROM `foo` foo

$select = $db-&gt;select();
$select-&gt;distinct();
$select-&gt;from('foo', 'non_unique_column');

?&gt;</pre>
<p>
            forUpdate() メソッドは、FOR UPDATE
            キーワードを SQL クエリに追加します。
        </p>
<pre class="programlisting">&lt;?php

// SELECT FOR UPDATE foo.*
// FROM `foo` foo

$select = $db-&gt;select();
$select-&gt;forUpdate();
$select-&gt;from('foo');

?&gt;</pre>
<p>
            query() メソッドは、
            Zend_Db_Adapter の query() メソッドと似ています。
            アダプタの型に応じて、Zend_Db_Statement 型
            あるいは PDOStatement 型のオブジェクトを返します。
        </p>
<pre class="programlisting">&lt;?php

$select = $db-&gt;select();
$select-&gt;from('foo');
$stmt = $select-&gt;query();
$result = $stmt-&gt;fetchAll();

// これは、以下と同等です
$select = $db-&gt;select();
$select-&gt;from('foo');
$stmt = $db-&gt;query($select);
$result = $stmt-&gt;fetchAll();

?&gt;</pre>
<p>
            getPart() メソッドは、SQL クエリの一部として指定したデータを返します。
            The Zend_Db_Select クラスでは、SQL クエリの一部を表す際に
            使用する定数が定義されています。
        </p>
<pre class="programlisting">&lt;?php

// SELECT foo.*
// FROM `foo` foo
// ORDER `keyColumn`

$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('keyColumn');

print_r( $select-&gt;getPart( Zend_Db_Select::ORDER ) );

?&gt;</pre>
<p>
            reset() メソッドは、
            SQL クエリの指定した部分をクリアします。
            あるいは引数を省略した場合は、SQL
            クエリのすべての部分をクリアします。
        </p>
<pre class="programlisting">&lt;?php

// SELECT foo.*
// FROM `foo` foo
// ORDER BY `column1`

$select = $db-&gt;select();
$select-&gt;from('foo');
$select-&gt;order('column1');

// 別の order 条件を指定します
//
// SELECT foo.*
// FROM `foo` foo
// ORDER BY `column2`

// いったん削除してから定義しなおします
$select-&gt;reset( Zend_Db_Select::ORDER );
$select-&gt;order('column2');

// クエリのすべての部分を削除します
$select-&gt;reset();

?&gt;</pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.db.profiler.html">前のページ</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.db.html">上に戻る</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.db.table.html">次のページ</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">9.2. Zend_Db_Profiler </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td>
<td width="40%" align="right" valign="top"> 9.4. Zend_Db_Table</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
