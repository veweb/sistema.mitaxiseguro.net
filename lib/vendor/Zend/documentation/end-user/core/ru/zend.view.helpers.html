<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>28.4. Вспомогательные классы вида</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Руководство разработчика">
<link rel="up" href="zend.view.html" title="Глава 28. Zend_View">
<link rel="prev" href="zend.view.scripts.html" title="28.3. Скрипты вида">
<link rel="next" href="zend.xmlrpc.html" title="Глава 29. Zend_XmlRpc">
<link rel="chapter" href="zend.html" title="Глава 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Глава 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Глава 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Глава 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Глава 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Глава 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Глава 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Глава 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Глава 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Глава 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Глава 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Глава 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Глава 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Глава 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Глава 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Глава 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Глава 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Глава 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Глава 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Глава 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Глава 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Глава 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Глава 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Глава 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Глава 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Глава 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Глава 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Глава 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Глава 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Приложение A. Стандарт кодирования на PHP в Zend Framework'е">
<link rel="appendix" href="copyrights.html" title="Приложение B. Copyright Information">
<link rel="index" href="the.index.html" title="Предметный указатель">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.initial" title="28.4.1. Начальные вспомогательные классы">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.paths" title="28.4.2. Пути к вспомогательным классам">
<link rel="subsection" href="zend.view.helpers.html#zend.view.helpers.custom" title="28.4.3. Написание собственных вспомогательных классов">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">28.4. Вспомогательные классы вида</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.view.scripts.html">Пред.</a> </td>
<th width="60%" align="center">Глава 28. Zend_View</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.xmlrpc.html">След.</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="ru">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.view.helpers"></a>28.4. Вспомогательные классы вида</h2></div></div></div>
<p>
        В скрипте вида часто бывает так, что необходимо выполнять
        определенный набор функций повторно; например, формирование даты,
        генерация элементов формы, отображение ссылок. Вы можете использовать
        вспомогательные классы для выполнения этих действий.

    </p>
<p>
        Чтобы применять вспомогательные классы ("помощников") в своем скрипте вида,
        вызывайте их, используя <code class="code">$this-&gt;имяПомощника()</code>.
        <code class="code">Zend_View</code> загрузит класс <code class="code">Zend_View_Helper_ИмяПомощника</code>,
        создаст его объект, и вызовет его метод <code class="code">имяПомощника()</code>.
        Этот объект находится постоянно внутри экземпляра <code class="code">Zend_View</code>
        и повторно используется во всех вызовах <code class="code">$this-&gt;имяПомощника()</code>.       

    </p>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.initial"></a>28.4.1. Начальные вспомогательные классы</h3></div></div></div>
<p>
            <code class="code">Zend_View</code> снабжен начальным набором вспомогательных
            классов, все они имеют отношение к генерации элементов форм.
            Каждый из них автоматически выполняет соответствующее экранирование
            выходных данных. Это:   

        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">formButton($name, $value, $attribs)</code>: Создает элемент
                <code class="code">&lt;input type="button" /&gt;</code>. 

            </p></li>
<li><p>
                <code class="code">formCheckbox($name, $value, $attribs, $options)</code>:
                Создает элемент <code class="code">&lt;input type="checkbox" /&gt;</code>
                (флажок опций). Параметр <code class="code">$options</code> является массивом,
                в котором первым значением является "выбранное" (checked) значение,
                вторым — "невыбранное" значение (по умолчанию это '1' и '0').
                Если <code class="code">$value</code> соответствует "выбранному" значению,
                то этот флажок опций будет выбран.

            </p></li>
<li><p>
                <code class="code">formFile($name, $value, $attribs)</code>: Создает
                элемент <code class="code">&lt;input type="file" /&gt;</code>.

            </p></li>
<li><p>
                <code class="code">formHidden($name, $value, $attribs)</code>: Создает
                элемент <code class="code">&lt;input type="hidden" /&gt;</code>. 

            </p></li>
<li><p>
                <code class="code">formPassword($name, $value, $attribs)</code>: Создает
                элемент <code class="code">&lt;input type="password" /&gt;</code>.

            </p></li>
<li><p>
                <code class="code">formRadio($name, $value, $attribs, $options)</code>: Создает
                последовательность элементов <code class="code">&lt;input type="radio" /&gt;</code>
                (переключатель опций). В массиве <code class="code">$options</code> ключ
                элемента является значением переключателя, значение
                элемента является текстом к переключателю. Переключатель опций
                со значением <code class="code">$value</code> будет предварительно выбран.

            </p></li>
<li><p>
                <code class="code">formReset($name, $value, $attribs)</code>: Создает
                элемент <code class="code">&lt;input type="password" /&gt;</code>.

            </p></li>
<li><p>
                <code class="code">formSelect($name, $value, $attribs, $options)</code>:
                Создает блок <code class="code">&lt;select&gt;...&lt;/select&gt;</code>,
                с одной опцией <code class="code">&lt;option&gt;</code> на каждый 
                элемент массива <code class="code">$options</code>. В массиве
                <code class="code">$options</code> ключ элемента является значением опции,
                значение элемента является текстом опции. Опция со значением
                <code class="code">$value</code> будет предварительно выбрана.

            </p></li>
<li><p>
                <code class="code">formSubmit($name, $value, $attribs)</code>: Создает
                элемент <code class="code">&lt;input type="submit" /&gt;</code>.

            </p></li>
<li><p>
                <code class="code">formText($name, $value, $attribs)</code>: Создает
                элемент <code class="code">&lt;input type="text" /&gt;</code>.

            </p></li>
<li><p>
                <code class="code">formTextarea($name, $value, $attribs)</code>: Создает
                блок <code class="code">&lt;textarea&gt;...&lt;/textarea&gt;</code>.

            </p></li>
</ul></div>
<p>
            Использование их в скрипте вида очень простое, вот пример.
            Обратите внимание, что это все, что вам нужно для их вызова — они
            будут загружаться и инстанцироваться самостоятельно, когда
            будут нужны.
            

        </p>
<pre class="programlisting">&lt;?php
// внутри вашего скрипта вида $this ссылается на экземпляр Zend_View
//
// предположим, что вы уже имеете последовательность опций
// в виде массива ('us' =&gt; 'United States', 'il' =&gt;
// 'Israel', 'de' =&gt; 'Germany') именем $countries
&lt;!--
// inside your view script, $this refers to the Zend_View instance.
// 
// say that you have already assigned a series of select options under
// the name $countries as array('us' =&gt; 'United States', 'il' =&gt;
// 'Israel', 'de' =&gt; 'Germany').
--&gt;
?&gt;
&lt;form action="action.php" method="post"&gt;
    &lt;p&gt;&lt;label&gt;Your Email:
        &lt;?php echo $this-&gt;formText('email', 'you@example.com', array('size' =&gt; 32)) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Your Country:
        &lt;?php echo $this-&gt;formSelect('country', 'us', null, $this-&gt;countries) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Would you like to opt in?
        &lt;?php echo $this-&gt;formCheckbox('opt_in', 'yes', null, array('yes', 'no')) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
        </pre>
<p>
            Результирующие выходные данные этого скрипта вида будут выглядеть
            наподобие этого:

        </p>
<pre class="programlisting">&lt;form action="action.php" method="post"&gt;
    &lt;p&gt;&lt;label&gt;Your Email:
        &lt;input type="text" name="email" value="you@example.com" size="32" /&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Your Country:
        &lt;select name="country"&gt;
            &lt;option value="us" selected="selected"&gt;United States&lt;/option&gt;
            &lt;option value="il"&gt;Israel&lt;/option&gt;
            &lt;option value="de"&gt;Germany&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Would you like to opt in?
        &lt;input type="hidden" name="opt_in" value="no" /&gt;
        &lt;input type="checkbox" name="opt_in" value="yes" checked="checked" /&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
        </pre>
</div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.paths"></a>28.4.2. Пути к вспомогательным классам</h3></div></div></div>
<p>
            Как и для скриптов вида, ваш контроллер может задать
            стек путей, в которых <code class="code">Zend_View</code> должен искать
            вспомогательные классы. По умолчанию <code class="code">Zend_View</code>
            ищет вспомогательные классы в <code class="code">Zend/View/Helper/*</code>. Вы
            можете приказать <code class="code">Zend_View</code> искать в других местах,
            используя методы <code class="code">setHelperPath()</code> и
            <code class="code">addHelperPath()</code>. Кроме этого, вы можете указать префикс
            класса, используемый для вспомогательных классов, он
            обеспечивает пространство имен. Если префикс не указан, то по
            умолчанию используется 'Zend_View_Helper_'. 

        </p>
<pre class="programlisting">&lt;?php
$view = new Zend_View();

// Устанавливает путь /path/to/more/helpers с префиксом 'My_View_Helper'
$view-&gt;setHelperPath('/path/to/more/helpers', 'My_View_Helper');
?&gt;
        </pre>
<p>
            Вы можете "складывать" в стек пути, используя метод
            <code class="code">addHelperPath()</code>. Если вы добавили
            пути в стек, то <code class="code">Zend_View</code> будет искать запрошенный
            вспомогательный класс в этих путях, начиная с пути, добавленного
            последним. Это дает возможность добавлять (или даже замещать)
            к начальному набору свои собственные вспомогательные классы. 

        </p>
<pre class="programlisting">&lt;?php
$view = new Zend_View();
// Добавить /path/to/some/helpers с префиксом для классов 'My_View_Helper'
$view-&gt;addHelperPath('/path/to/some/helpers', 'My_View_Helper);
// Добавить /other/path/to/helpers с префиксом для классов 'Your_View_Helper'
$view-&gt;addHelperPath('/other/path/to/helpers', 'Your_View_Helper');

// теперь, когда вы вызываете $this-&gt;helperName(), Zend_View будет искать
// "/other/path/to/helpers/HelperName.php" с классом "My_View_Helper_HelperName", 
// затем "/path/to/some/helpers/HelperName" с классом "Your_View_Helper_HelperName", 
// и под конец "Zend/View/Helper/HelperName.php" с классом "Zend_View_Helper_HelperName".
?&gt;
        </pre>
</div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.view.helpers.custom"></a>28.4.3. Написание собственных вспомогательных классов</h3></div></div></div>
<p>
            Написание собственных вспомогательных классов является довольно простым делом —
            просто следуйте этим правилам:

        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                Имя класса должно быть <code class="code">Zend_View_Helper_*</code>,
                где * является именем самого "помощника". Например, если
                вы написали "помощника", называющегося "specialPurpose",
                имя класса должно быть "Zend_View_Helper_SpecialPurpose"
                (обратите внимание на использование главных букв).
                
                Имя класса должно быть, как минимум, заканчиваться именем
                "помощника", в котором имена начинаются с заглавной буквы. Т.е.
                если вы написали "помощника" с именем "specialPurpose", то
                минимальное имя класса должно быть "SpecialPurpose". Вы можете
                (и должны) давать классам имена с префиксом, рекомендуется
                использовать 'View_Helper' как часть этого префикса с или без
                завершающего знака подчеркивания.

            </p></li>
<li><p>
                Класс должен иметь открытый метод, имя которого
                соответствует имени "помощника". Это метод, который будет
                вызываться, когда ваш шаблон вызывает
                <code class="code">$this-&gt;specialPurpose()</code>. В нашем примере с помощником
                "specialPurpose" объявление требуемого метода должно быть
                <code class="code">public function specialPurpose()</code>. 
 
            </p></li>
<li><p>
                Обычно класс не должен выполнять вывод, вместо этого
                он должен возвращать значение для вывода. Возвращаемое значение
                должно быть экранировано должным образом. 

            </p></li>
<li><p>
                Класс должен быть в файле, названном по имени метода.
                Снова используя пример с помощником "specialPurpose", мы
                должны дать файлу имя "SpecialPurpose.php".

            </p></li>
</ul></div>
<p>
            Размещайте вспомогательный класс где-либо в одном из находящихся в стеке путей
            к "помощникам", и <code class="code">Zend_View</code> будет автоматически загружать,
            инстанцировать, сохранять и выполнять его. 

        </p>
<p>
            Вот пример кода нашего помощника "SpecialPurpose":

        </p>
<pre class="programlisting">&lt;?php
class My_View_Helper_SpecialPurpose {
    protected $_count = 0;
    public function specialPurpose()
    {
        $this-&gt;_count++;
        $output = "I have seen 'The Jerk' {$this-&gt;_count} time(s).";
        return htmlspecialchars($output);
    }
}
?&gt;
        </pre>
<p>
            Далее в скрипте вида вы можете вызывать помощника SpecialPurpose
            столько раз, сколько вам нужно. Он будет инстанцирован один раз,
            и сохраняется в течение существования экземпляра Zend_View.

        </p>
<pre class="programlisting">&lt;?php
// помните, что в скрипте вида $this ссылается на экземпляр Zend_View
echo $this-&gt;specialPurpose();
echo $this-&gt;specialPurpose();
echo $this-&gt;specialPurpose();
?&gt;
        </pre>
<p>
            Результат должен выглядеть наподобие этого:

        </p>
<pre class="programlisting">I have seen 'The Jerk' 1 time(s).
I have seen 'The Jerk' 2 time(s).
I have seen 'The Jerk' 3 time(s).
        </pre>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.view.scripts.html">Пред.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.view.html">Уровень выше</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.xmlrpc.html">След.</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">28.3. Скрипты вида </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td>
<td width="40%" align="right" valign="top"> Глава 29. Zend_XmlRpc</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
