<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>7.4. Готовые подклассы</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="Руководство разработчика">
<link rel="up" href="zend.controller.html" title="Глава 7. Zend_Controller">
<link rel="prev" href="zend.controller.subclassing.html" title="7.3. Создание подклассов">
<link rel="next" href="zend.controller.action.html" title="7.5. Контроллеры действий">
<link rel="chapter" href="zend.html" title="Глава 1. Zend">
<link rel="chapter" href="zend.acl.html" title="Глава 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Глава 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Глава 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Глава 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Глава 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Глава 7. Zend_Controller">
<link rel="chapter" href="zend.date.html" title="Глава 8. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Глава 9. Zend_Db">
<link rel="chapter" href="zend.feed.html" title="Глава 10. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Глава 11. Zend_Filter">
<link rel="chapter" href="zend.gdata.html" title="Глава 12. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Глава 13. Zend_Http">
<link rel="chapter" href="zend.json.html" title="Глава 14. Zend_Json">
<link rel="chapter" href="zend.locale.html" title="Глава 15. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Глава 16. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Глава 17. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Глава 18. Zend_Measure">
<link rel="chapter" href="zend.mime.html" title="Глава 19. Zend_Mime">
<link rel="chapter" href="zend.pdf.html" title="Глава 20. Zend_Pdf">
<link rel="chapter" href="zend.rest.html" title="Глава 21. Zend_Rest">
<link rel="chapter" href="zend.search.html" title="Глава 22. Zend_Search">
<link rel="chapter" href="zend.server.html" title="Глава 23. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Глава 24. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Глава 25. Zend_Session">
<link rel="chapter" href="zend.uri.html" title="Глава 26. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Глава 27. Zend_Validate">
<link rel="chapter" href="zend.view.html" title="Глава 28. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Глава 29. Zend_XmlRpc">
<link rel="appendix" href="coding-standard.html" title="Приложение A. Стандарт кодирования на PHP в Zend Framework'е">
<link rel="appendix" href="copyrights.html" title="Приложение B. Copyright Information">
<link rel="index" href="the.index.html" title="Предметный указатель">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.introduction" title="7.4.1. Введение">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http" title="7.4.2. Zend_Controller_Request_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.rewriterouter" title="7.4.3. Zend_Controller_Router_Rewrite">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.http" title="7.4.4. Zend_Controller_Response_Http">
<link rel="subsection" href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.response.cli" title="7.4.5. Zend_Controller_Response_Cli">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">7.4. Готовые подклассы</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Пред.</a> </td>
<th width="60%" align="center">Глава 7. Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.controller.action.html">След.</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="ru">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.providedsubclasses"></a>7.4. Готовые подклассы</h2></div></div></div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.introduction"></a>7.4.1. Введение</h3></div></div></div>
<p>
            Zend Framework предоставляет некоторые альтернативы принятым по
            умолчанию классам, в которые входят объекты запросов, маршрутизаторы
            и объекты ответов. 

        </p>
</div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.request.http"></a>7.4.2. Zend_Controller_Request_Http</h3></div></div></div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.introduction"></a>7.4.2.1. Введение</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> предоставляет
                объект запроса для использования в среде HTTP.
                <code class="code">Zend_Controller_Request_Http</code> является классом
                запроса, используемым <code class="code">Zend_Controller_Dispatcher</code>
                по умолчанию.   

            </p>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.dataaccess"></a>7.4.2.2. Доступ к данным запроса</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> инкапсулирует доступ
                к релевантным значениям, таким, как ключевое имя и значение
                для переменных маршрутизатора и все дополнительные параметры,
                полученные из URI. Посредством передачи к
                <code class="code">Zend_Controller_Request_Http</code> он также предоставяет
                доступ к значениям, содержащимся в суперглобальных переменных
                как к открытым членам и управляет текущим базовым URL и URI
                запроса. Суперглобальные значения не могут быть установлены в
                объекте запроса, за исключением методов setParam/getParam
                для установки или извлечения пользовательских переменных. 

            </p>
<div class="note"><table border="0" summary="Note: Суперглобальные данные">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Суперглобальные данные</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Когда обращаетесь к суперглобальным переменным через
                    <code class="code">Zend_Controller_Request_Http</code> как к открытым
                    свойствам объекта, необходимо помнить, что имя свойства
                    (ключ суперглобального массива) проверяется на наличие в
                    суперглобальных массивах в определенном порядке: 1. GET,
                    2. POST, 3. COOKIE, 4. SERVER, 5. ENV.

                </p></td></tr>
</table></div>
<p>
                К определенным суперглобальным массивам можно также обращаться
                через открытые методы. Например, можно получить необработанное
                значение <code class="code">$_POST['user']</code> посредством вызова метода
                <code class="code">getPost('user')</code> в объекте запроса.

            </p>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.request.http.baseurl"></a>7.4.2.3. Базовый URL и поддиректории</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> позволяет использовать
                Zend_Controller_Router_Rewrite в поддиректориях.
                Zend_Controller_Request_Http будет пытаться автоматически 
                определить ваш базовый URL и установить его.

            </p>
<p>
                Например, если вы храните файл загрузки <code class="code">index.php</code> в
                поддиректории веб-сервера, которая называется
                <code class="code">/projects/myapp/index.php</code>, то базовый URL
                (базовый адрес перезаписи) должен быть установлен в
                <code class="code">/projects/myapp</code>. Эта стока будет исключаться из
                начала пути перед любыми вычислениями соответствий маршрутов.
                Это освобождает от необходимости ее указывания в начале каждого
                маршрута. Маршрут <code class="code">'user/:username'</code> будет
                соответствовать URI вида
                <code class="code">http://localhost/projects/myapp/user/martel</code> и
                <code class="code">http://example.com/user/martel</code>.

            </p>
<div class="note"><table border="0" summary="Note: Определение URL чувствительно к регистру">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Определение URL чувствительно к регистру</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Автоматическое определение базового URL является
                    чувствительно к регистру, поэтому убедитесь, что ваш URL
                    соответствует имени поддиректории в файловой системе (даже
                    на платформе Windows). Если не соответствует, то будет
                    вызываться действие <code class="code">noRoute</code>. 

                </p></td></tr>
</table></div>
<p>
                Если базовый URL определяется некорректно, вы можете заменить
                его своим базовым путем с помощью метода
                <code class="code">setBaseUrl()</code>, который есть в классах
                <code class="code">Zend_Http_Request</code>,
                <code class="code">Zend_Controller_Request_Http</code> и
                <code class="code">Zend_Controller_Front</code>. Легче всего установить его
                через  <code class="code">Zend_Controller_Front</code>, который передаст его
                объекту запроса. Пример установки своего базового URL: 

            </p>
<pre class="programlisting">
$router     = new Zend_Controller_Router_Rewrite();
$controller = Zend_Controller_Front::getInstance();
$controller-&gt;setControllerDirectory('./application/controllers')
           -&gt;setRouter($router)
           -&gt;setBaseUrl('/projects/myapp'); // set the base url!
$response   = $controller-&gt;dispatch();</pre>
</div>
</div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter"></a>7.4.3. Zend_Controller_Router_Rewrite</h3></div></div></div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.introduction"></a>7.4.3.1. Введение</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Router_Rewrite</code> является стандартным 
                маршрутизатором фреймворка. Маршрутизация является
                процессом принятия конечной точки URI (той части URI, которая
                идет после базового URL) и ее разложения на параметры
                для определения того, какой контроллер и какое действие этого
                контроллера должны получить запрос. Значения контроллера,
                действия и необязательных параметров упаковывается в объект
                <code class="code">Zend_Controller_Request_Http</code>, который затем
                обрабатывается <code class="code">Zend_Controller_Dispatcher_Standard</code>.
                Маршрутизация производится только один раз – когда вначале
                получен запрос и до того, как первый контроллер будет запущен.

            </p>
<p>
                <code class="code">Zend_Controller_Router_Rewrite</code> предназначен для
                того, чтобы обеспечить функциональность, подобную mod_rewrite,
                с применением чистого php. Он отчасти основан на маршрутизации
                в Ruby on Rails и не требует каких-либо предварительных знаний
                о перезаписи URL веб-сервером. Он спроектирован для работы с
                единственным правилом mod_rewrite, пример которого приведен
                ниже:

            </p>
<pre class="programlisting">
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php</pre>
<p>
            или:
            </p>
<pre class="programlisting">
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 </pre>
<p>
                Rewrite Router может также использоваться с веб-сервером IIS,
                если
                <a href="http://www.isapirewrite.com" target="_top">Isapi_Rewrite</a>
                был установлен как расширение Isapi со следующими правилами
                перезаписи: 

            </p>
<pre class="programlisting">
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]</pre>
<div class="note"><table border="0" summary="Note: IIS Isapi_Rewrite">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">IIS Isapi_Rewrite</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Если используется IIS, то
                    <code class="code">$_SERVER['REQUEST_URI']</code>
                    не будет существовать, либо будет установлен как пустая
                    строка. В этом случае
                    <code class="code">Zend_Controller_Request_Http</code> попытается
                    использовать <code class="code">$_SERVER['HTTP_X_REWRITE_URL']</code>,
                    значение которого устанавливается расширением Isapi_Rewrite.  

                </p></td></tr>
</table></div>
<p>
               Если используется Lighttpd, то валидным будет следующее
               правило перезаписи:

            </p>
<pre class="programlisting">
url.rewrite-once = ( ".*\.(js|ico|gif|jpg|png|css)$" =&gt; "$0", "" =&gt; "/index.php")</pre>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.usage"></a>7.4.3.2. Использование маршрутизатора</h4></div></div></div>
<p>
                Чтобы использовать Rewrite Router, нужно инстанцировать его,
                добавить маршруты и установить его в контроллере. Следующий код
                демонстрирует эту процедуру:

            </p>
<pre class="programlisting">
/* Создание маршрутизатора */

// возвращает используемый по умолчанию маршрутизатор
$router = $ctrl-&gt;getRouter();

$router-&gt;addRoute(
	'user',
	new Zend_Controller_Router_Route('user/:username', array('controller' =&gt; 'user', 'action' =&gt; 'info'))
);
</pre>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.basic"></a>7.4.3.3. Основные маршруты</h4></div></div></div>
<p>
                Сущностью RewriteRouter является определение пользовательских
                маршрутов. Маршруты создаются вызовом метода
                <code class="code">addRoute()</code> и передачей ему нового
                экземпляра <code class="code">Zend_Controller_Router_Route</code>: 

            </p>
<pre class="programlisting">
$router-&gt;addRoute('user', new Zend_Controller_Router_Route('user/:username'));</pre>
<p>
	              Первым параметром является имя маршрута. Сейчас он
                является избыточным, но в будущем будет использоваться в
                вспомогательном классе вида (view) для легкой генерации URL
                в ваших видах. Если нужно воспользоваться ранее
                сконфигурированным маршрутом, то можно получить его
                с помощью метода <code class="code">getRoute</code>. Вторым параметром
                является экземпляр <code class="code">Zend_Controller_Router_Route</code>.

            </p>
<p>
                Первым параметром для конструктора
                <code class="code">Zend_Controller_Router_Route</code> является маршрут,
                который будет сопоставляться с URL – например, маршрут в примере
                выше будет соответствовать
                <code class="code">http://example.com/user/martel</code>. Двоеточие в
                маршруте обозначает переменную URL. После успешной
                маршрутизации значения всех определенных переменных будут
                добавлены в Zend_Controller_Request. К ним можно будет получить
                доступ через методы Zend_Controller_Request::getParam или
                Zend_Controller_Action::_getParam. В нашем примере параметру под
                именем username будет присвоено значение 'martel'.

            </p>
<div class="note"><table border="0" summary="Note: Порядок сопоставления">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Порядок сопоставления</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Маршруты сопоставляются в обратном порядке, поэтому
                    удостоверьтесь, что наиболее общие маршруты определены
                    первыми.

                </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note: Использование символов">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Использование символов</th>
</tr>
<tr><td align="left" valign="top"><p>
	                  Текущая реализация позволяет использовать любые символы,
	                  кроме прямой косой черты (/), в идентификаторе переменной,
                    но сильно рекомендуется использовать в них только символы,
                    допустимые для переменных в php. Есть вероятность, что в
                    будущем реализация изменится, и это может вызвать ошибки в
                    вашем коде.

                </p></td></tr>
</table></div>
<p>
            	  Есть две специальные переменные, которые можно использовать в
            	  маршрутах — ':controller' и ':action'. Эти специальные
                переменные могут использоваться для получения контроллера и/или
                действия, выбранных в URL. Переменная ':action' всегда должна
                быть определена в маршруте или как параметр по умолчанию.
                Переменная 'controller' по умолчанию будет
                <code class="code">IndexController</code>, если не была определена.

            </p>
<div class="note"><table border="0" summary="Note: Специальные переменные">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Специальные переменные</th>
</tr>
<tr><td align="left" valign="top"><p>
                    Имена специальных переменных могут отличаться, если вы
                    измените значения по умолчанию в
                    <code class="code">Zend_Controller_Request_Http</code> через методы
                    setControllerKey и setActionKey.

                </p></td></tr>
</table></div>
<pre class="programlisting">
$router-&gt;addRoute(
    'user', new Zend_Controller_Router_Route(':controller/:action')
);</pre>
<p>
	              Если вы наберете в вашем броузере адрес
                'http://example.com/news/latest', то при сопоставлении с таким
                маршрутом <code class="code">Zend_Controller_Dispatcher</code> вызовет метод
                latestAction в вашем классе контроллера NewsController.

            </p>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-defaults"></a>7.4.3.4. Значения по умолчанию</h4></div></div></div>
<p>
                Любая переменная в маршруте может иметь значение по умолчанию.
                Для его определения вы должны добавить второй параметр для
                конструктора <code class="code">Zend_Controller_Router_Route</code>. Этот
                параметр является массивом с ключами, соответствующими именам
                переменных, и значениями, соответствующими желаемым значениям
                этих переменных по умолчанию.

            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive', new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006))
);</pre>
<p>
                Этот маршрут будет соответствовать таким URL, как
                'http://example.com/archive/2005' и
                'http://example.com/archive'. В последнем случае переменная
                ':year' будет иметь значение 2006. 

            </p>
<p>
                В примере выше результатом будет только добавление переменной
                ':year' в запрос. Маршрутизация не будет выполняться корректно
                до тех пор, пока не будут установлены параметры контроллера и
                действия. Для того, чтобы сделать этот код более полезным, вы
                должны указать конкретные контроллер и действие как значения по
                умолчанию.
 
            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006, 'controller' =&gt; 'archive', 'action' =&gt; 'show')
);</pre>
<p>
                Результатом будет вызов действия showAction в классе контроллера
                ArchiveController. 

            </p>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.variable-requirements"></a>7.4.3.5. Требования к переменным</h4></div></div></div>
<p>
	              Можно добавить третий параметр в вызове конструктора
                <code class="code">Zend_Controller_Router_Route</code>, в котором 
                устанавливаются требования к переменным. Они указываются в виде
                регулярных выражений.

            </p>
<pre class="programlisting">
$router-&gt;addRoute(
    'archive',
    new Zend_Controller_Router_Route('archive/:year', array('year' =&gt; 2006), array('year' =&gt; '\d+'))
);</pre>
<div class="note"><table border="0" summary="Note: Особенности маршрутизации">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Особенности маршрутизации</th>
</tr>
<tr><td align="left" valign="top"><p>
	                  В отличие от Ruby on Rails, ZF RewriteRouter будет
                    использовать значение по умолчанию, если нет соответствия
                    требованиям, определенным в третьем параметре. Таким
                    образом, в случае URL
                    <code class="code">http://example.com/archive/test</code>
                    год будет равен 2006. Это поведение может быть изменено в
                    будущем, так как все еще было предметом обсуждения во время
                    написания этой документации.

                </p></td></tr>
</table></div>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.rewritebase"></a>7.4.3.6. Базовый URL и поддиректории</h4></div></div></div>
<p>
                Rewrite Router может использоваться в поддиректориях, базовый URL автоматически определяется в Zend_Controller_Request_Http.     

            </p>
<p>
                Если базовый URL определяется некорректно, то вы можете
                переопределить его через метод <code class="code">setBaseUrl()</code> объекта
                <code class="code">Zend_Controller_Request_Http</code> (см.
                <a href="zend.controller.providedsubclasses.html#zend.controller.providedsubclasses.request.http.baseurl" title="7.4.2.3. Базовый URL и поддиректории">Раздел 7.4.2.3, «Базовый URL и поддиректории»</a>).

            </p>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.default-routes"></a>7.4.3.7. Маршруты по умолчанию</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Router_Rewrite</code> изначально
                сконфигурирован с одним маршрутом по умолчанию. Он будет
                соответствовать URI вида <code class="code">'controller/action'</code>. Кроме
                этого, имя модуля может быть определено как первый элемент пути,
                что позволяет использовать URI вида
                <code class="code">'module/controller/action</code>.
                Он будет также соответствовать любым дополнительным
                параметрам, по умолчанию добавляемым в конец URI.

            </p>
<p>
                Некоторые примеры того, как сопоставляются маршруты:
            </p>
<pre class="programlisting">
// Допустим следующее:
// $ctrl-&gt;setControllerDirectory(array(
//     'default' =&gt; '/path/to/default/controllers',
//     'news'    =&gt; '/path/to/blog/controllers',
//     'blog'    =&gt; '/path/to/blog/controllers'
// ));

Только модуль:
http://example/news
    module == news

Если модуль неверный, то считается, что это имя контроллера:
http://example/foo
    controller == foo

Модуль + контроллер:
http://example/blog/archive
    module     == blog
    controller == archive

Модуль + контроллер + действие:
http://example/blog/archive/list
    module     == blog
    controller == archive
    action     == list

Модуль + контроллер + действие + параметры:
http://example/blog/archive/list/sort/alpha/date/desc
    module     == blog
    controller == archive
    action     == list
    sort       == alpha
    date       == desc
</pre>
<p>
                Маршрутом, используемым по умолчанию, является объект
                <code class="code">Zend_Controller_Router_Route_Module</code>,
                инстанцированный без значений по умолчанию.  

            </p>
<pre class="programlisting">
// Маршрут для совместимости с первой версией маршрутизатора
$compat = new Zend_Controller_Router_Route_Module();
$this-&gt;addRoute('default', $compat);</pre>
<div class="note"><table border="0" summary="Note: Сопоставление URI">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Замечание]" src="images/note.png"></td>
<th align="left">Сопоставление URI</th>
</tr>
<tr><td align="left" valign="top"><p>
                    <code class="code">Zend_Controller_Router_Rewrite</code> сконфигурирован c учетом обратной совместимости. Он будет автоматически использовать маршрут
                    <code class="code">controller/action</code> с дополнительными
                    параметрами. Дополнительные параметры не требуют добавления
                    новых маршрутов, если они не должны иметь значений по
                    умолчанию или требований к переменным. Эти дополнительные
                    параметры будут доступны через метод
                    <code class="code">Zend_Controller_Action::_getParam</code>.

                </p></td></tr>
</table></div>
<p>
                Если вы не хотите использовать маршрут по умолчанию, то можете
                удалить его, используя метод <code class="code">removeDefaultRoutes()</code>:

            </p>
<pre class="programlisting">
// Удаление маршрута по умолчанию
$router-&gt;removeDefaultRoutes();</pre>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.static-routes"></a>7.4.3.8. Статические маршруты</h4></div></div></div>
<p>
                В примерах выше все импользуемые маршруты были динамическими –
                маршруты, которые содержат паттерны для сопоставления с URI.
                Тем не менее, определенные маршруты могут быть
                неизменными, и применение к ним методов регулярных выражений
                будет совершенно излишним. Решением данной ситуации будет
                использование статических маршрутов:
                

            </p>
<pre class="programlisting">
$loginRoute = new Zend_Controller_Router_Route_Static('login', array('controller' =&gt; 'login', 'action' =&gt; 'form'));
$router-&gt;addRoute('login', $static);
</pre>
</div>
<div class="sect3" lang="ru">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.providedsubclasses.rewriterouter.add-config"></a>7.4.3.9. Использование Zend_Config вместе с RewriteRouter</h4></div></div></div>
<p>
                Иногда было бы более удобным обновлять конфигурационные данные
                для новых маршрутов, чем изменять код. Это возможно через метод
                <code class="code">addConfig()</code>. По существу, вы создаете конфигурацию,
                совместимую с Zend_Config, считываете ее в своем коде и
                передаете RewriteRouter.

            </p>
<pre class="programlisting">
/**
 * Пример INI:
 * routes.archive.route = "archive/:year/*"
 * routes.archive.defaults.controller = archive
 * routes.archive.defaults.action = show
 * routes.archive.defaults.year = 2000
 * routes.archive.reqs.year = "\d+"
 * 
 * routes.news.type = "Zend_Controller_Router_Route_Static"
 * routes.news.route = "news"
 * routes.news.defaults.controller = "news"
 * routes.news.defaults.action = "list"
 */
$config = new Zend_Config_Ini($file);
$router = new Zend_Controller_Router_Rewrite();
$router-&gt;addConfig($config, 'routes');
</pre>
<p>
                В примере выше мы говорим маршрутизатору, чтобы он использовал
                раздел 'routes' в файле INI для определения своих маршрутов.
                Ключ первого уровня в этом разделе используется для имени
                маршрута, в примере выше определяются маршруты 'archive' и
                'news'. Каждый маршрут требует, как минимум, запись 'route',
                одну или более записей 'defaults', необязательно может быть одна
                или более записей 'reqs' (сокращение от 'required'). Все это
                соответствет трем аргументам, предоставляемым объекту
                <code class="code">Zend_Controller_Router_Route_Interface</code>.
                Опция 'type' может использоваться для определения класса,    
                используемого для данного маршрута, по умолчанию используется
                класс <code class="code">Zend_Controller_Router_Route</code>. В примере выше
                для маршрута 'news' должен использоваться класс
                <code class="code">Zend_Controller_Router_Route_Static</code>.    
                

            </p>
</div>
</div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.http"></a>7.4.4. Zend_Controller_Response_Http</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Http</code> является объектом ответа,
            пригодным к использованию в среде HTTP. Он содержит методы для
            установки, получения и удаления заголовков, а также метод
            <code class="code">__toString()</code>, который отправляет все заголовки
            одновременно до того, как будет возвращено содержимое ответа. 

        </p>
<p>
            <code class="code">setHeader()</code> принимает два аргумента – тип заголовка и
            значение заголовка. Если передан третий необязательный параметр и он
            имеет значение <code class="code">true</code>, то производится принудительная
            замена значения заголовка с тем же типом, если он уже был
            зарегистрирован.

        </p>
</div>
<div class="sect2" lang="ru">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.providedsubclasses.response.cli"></a>7.4.5. Zend_Controller_Response_Cli</h3></div></div></div>
<p>
            <code class="code">Zend_Controller_Response_Cli</code> является объектом ответа,
            подходящим для использования в среде CLI. Он не имеет методов для
            управления заголовками и просто возвращает все содержимое ответа при
            вызове метода <code class="code">__toString()</code>. 

        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.subclassing.html">Пред.</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">Уровень выше</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.controller.action.html">След.</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">7.3. Создание подклассов </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td>
<td width="40%" align="right" valign="top"> 7.5. Контроллеры действий</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
